/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 38);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_color__ = __webpack_require__(14);

/**
 * Preset of render state for OVER compositing,
 * @see T. Porter and T. Duff, "Compositing Digital Images", Proceedings of
 *      SIGGRAPH'84, 18 (1984).
 */
const BLEND_OVER_RENDER_STATE = {
    blend: true,
    blendFuncSrcRgb: 770 /* SRC_ALPHA */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
/* harmony export (immutable) */ __webpack_exports__["a"] = BLEND_OVER_RENDER_STATE;

/**
 * State of the WebGL rendering pipeline. Doesn't include object bindings since
 * the context handles them.
 */
class RenderState {
    /**
     * Creates a new render state object.
     *
     * @param state Object with state properties that values differ from default
     *      ones.
     */
    constructor(...state) {
        this.clearColor = __WEBPACK_IMPORTED_MODULE_0__util_color__["c" /* create */](0, 0, 0, 0);
        this.clearDepth = 1;
        this.clearStencil = 0;
        this.colorMaskR = true;
        this.colorMaskG = true;
        this.colorMaskB = true;
        this.colorMaskAlpha = true;
        this.blend = false;
        this.blendEquationRgb = 32774 /* ADD */;
        this.blendEquationAlpha = 32774 /* ADD */;
        this.blendFuncSrcRgb = 1 /* ONE */;
        this.blendFuncDstRgb = 0 /* ZERO */;
        this.blendFuncSrcAlpha = 1 /* ONE */;
        this.blendFuncDstAlpha = 0 /* ZERO */;
        this.cullFace = false;
        this.cullFaceMode = 1029 /* BACK */;
        this.frontFaceMode = 2305 /* COUNTERCLOCKWISE */;
        this.depthTest = false;
        this.depthFunc = 513 /* LESS */;
        this.depthRangeNear = 0;
        this.depthRangeFar = 1;
        this.depthMask = true;
        this.dither = true;
        this.drawBuffers = [36064 /* COLOR_ATTACHMENT0 */];
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.sampleAlphaToCoverage = false;
        this.sampleCoverage = false;
        this.sampleCoverageValue = 1;
        this.sampleCoverageInvert = false;
        this.scissorTest = false;
        this.scissorX = 0;
        this.scissorY = 0;
        // Actual defaults aren't known here since they depend upon context. -1's
        // as "do not change" values.
        this.scissorWidth = -1;
        this.scissorHeight = -1;
        this.stencilTest = false;
        this.stencilReference = 0;
        this.stencilMask = 0xff;
        this.stencilWriteMask = 0xff;
        this.stencilFrontFunc = 519 /* ALWAYS */;
        this.stencilFrontFailOp = 7680 /* KEEP */;
        this.stencilFrontDepthFailOp = 7680 /* KEEP */;
        this.stencilFrontDepthPassOp = 7680 /* KEEP */;
        this.stencilBackFunc = 519 /* ALWAYS */;
        this.stencilBackFailOp = 7680 /* KEEP */;
        this.stencilBackDepthFailOp = 7680 /* KEEP */;
        this.stencilBackDepthPassOp = 7680 /* KEEP */;
        this.viewportX = 0;
        this.viewportY = 0;
        // Actual defaults aren't known here since they depend upon context. -1's
        // as "do not change" values.
        this.viewportWidth = -1;
        this.viewportHeight = -1;
        Object.assign(this, ...state);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = RenderState;



/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["e"] = create;
/* harmony export (immutable) */ __webpack_exports__["d"] = copy;
/* unused harmony export areEqual */
/* unused harmony export areCollinear */
/* unused harmony export areFuzzyEqual */
/* harmony export (immutable) */ __webpack_exports__["b"] = add;
/* harmony export (immutable) */ __webpack_exports__["k"] = sub;
/* unused harmony export mulv */
/* harmony export (immutable) */ __webpack_exports__["h"] = muln;
/* unused harmony export divv */
/* unused harmony export divn */
/* unused harmony export mod */
/* unused harmony export mix */
/* unused harmony export rotate */
/* unused harmony export rotate45 */
/* harmony export (immutable) */ __webpack_exports__["j"] = rotate90;
/* unused harmony export rotateNeg90 */
/* unused harmony export invert */
/* harmony export (immutable) */ __webpack_exports__["g"] = length;
/* unused harmony export distance */
/* harmony export (immutable) */ __webpack_exports__["i"] = normalize;
/* unused harmony export dot */
/* harmony export (immutable) */ __webpack_exports__["f"] = crossZ;
/* unused harmony export bboxesOverlap */
/* unused harmony export pointIsInBBox */
/* harmony export (immutable) */ __webpack_exports__["c"] = computeBBoxForPoints;
/* unused harmony export getLineFromPoints */
/* unused harmony export getSignedDistanceToLine */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__ = __webpack_require__(16);

/**
 * Creates a new vector and initializes it with given components.
 *
 * @param x X component of the vector.
 * @param y Y component of the vector.
 * @returns The vector.
 */
function create(x, y) {
    return { x, y };
}
const ZERO = create(0, 0);
/* harmony export (immutable) */ __webpack_exports__["a"] = ZERO;

const ORIGIN = ZERO;
/* unused harmony export ORIGIN */

const POSITIVE_X = create(1, 0);
/* unused harmony export POSITIVE_X */

const NEGATIVE_X = create(-1, 0);
/* unused harmony export NEGATIVE_X */

const POSITIVE_Y = create(0, 1);
/* unused harmony export POSITIVE_Y */

const NEGATIVE_Y = create(0, -1);
/* unused harmony export NEGATIVE_Y */

/**
 * Copies a vector to another one.
 *
 * @param src The source vector.
 * @param dst The vector the source vector will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0)) {
    dst.x = src.x;
    dst.y = src.y;
    return dst;
}
/**
 * Checks if two vectors are strictly equal component-wise.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are equal and `false` otherwise.
 */
function areEqual(v1, v2) {
    return v1.x == v2.x && v1.y == v2.y;
}
/**
 * Checks if two vectors are collinear.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are collinear and `false` otherwise.
 */
function areCollinear(v1, v2) {
    return v1.x / v2.x == v1.y / v2.y;
}
/**
 * Checks if corresponding components of two vectors are all within given
 * tolerance from each other.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @param tolerance The tolerance.
 * @returns `true` if the vectors are "fuzzy" equal and `false` otherwise.
 */
function areFuzzyEqual(v1, v2, tolerance = __WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__["a" /* DEFAULT_TOLERANCE */]) {
    return (Object(__WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__["b" /* default */])(v1.x, v2.x, tolerance) &&
        Object(__WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__["b" /* default */])(v1.y, v2.y, tolerance));
}
/**
 * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function add(a, b, dst = create(0, 0)) {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
    return dst;
}
/**
 * Subtracts a vector from another one and stores the result to a third one, i.e.
 * `dst = a - b`.
 *
 * @param a The minuend vector.
 * @param b The subtrahend vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function sub(a, b, dst = create(0, 0)) {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
    return dst;
}
/**
 * Multiplies two vectors component-wise and stores the result into a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mulv(a, b, dst = create(0, 0)) {
    dst.x = a.x * b.x;
    dst.y = a.y * b.y;
    return dst;
}
/**
 * Multiplies a vector by a scalar and stores the result into a third vector.
 *
 * @param a The vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function muln(a, n, dst = create(0, 0)) {
    dst.x = a.x * n;
    dst.y = a.y * n;
    return dst;
}
/**
 * Divides a vector by another one component wise and stores the result into a
 * third one.
 *
 * @param a The dividend vector.
 * @param b The divisor vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divv(a, b, dst = create(0, 0)) {
    dst.x = a.x / b.x;
    dst.y = a.y / b.y;
    return dst;
}
/**
 * Divides a vector by a scalar and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divn(a, n, dst = create(0, 0)) {
    dst.x = a.x / n;
    dst.y = a.y / n;
    return dst;
}
/**
 * Calculates the reminder after division of a's components by n and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mod(a, n, dst = create(0, 0)) {
    dst.x = a.x % n;
    dst.y = a.y % n;
    return dst;
}
/**
 * Linearly interpolates between two vectors, i.e. computes
 * `(1 - factor) * a + factor * b`, and writes the result into a third vector.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param factor The interpolation factor.
 * @param dst The vector the result will be written to.
 * @returns `dst`.
 */
function mix(a, b, factor, dst = create(0, 0)) {
    dst.x = (1 - factor) * a.x + factor * b.x;
    dst.y = (1 - factor) * a.y + factor * b.y;
    return dst;
}
/**
 * Rotates a vector by a given angle and stores the result into a second vector.
 * Positive direction is from +X to +Y.
 *
 * @param v The vector to rotate.
 * @param angle The angle of rotation.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate(v, angle, dst = create(0, 0)) {
    const x = v.x;
    const y = v.y;
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    dst.x = angleCos * x - angleSin * y;
    dst.y = angleSin * x + angleCos * y;
    return dst;
}
/**
 * Rotates a vector by 45 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, Math.PI / 4, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate45(v, dst = create(0, 0)) {
    const y = v.y;
    const s = Math.SQRT1_2;
    dst.y = s * v.x + s * v.y;
    dst.x = s * v.x - s * y;
    return dst;
}
/**
 * Rotates a vector by 90 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, Math.PI / 2, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate90(v, dst = create(0, 0)) {
    const y = v.y;
    dst.y = v.x;
    dst.x = -y;
    return dst;
}
/**
 * Rotates a vector by -90 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, -Math.PI / 2, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotateNeg90(v, dst = create(0, 0)) {
    const y = v.y;
    dst.y = -v.x;
    dst.x = y;
    return dst;
}
/**
 * Inverts signs of components of a vector and stores the result into a second
 * vector. Analogous to `rotate(v, Math.PI, dst)` (or `rotate(v, -Math.PI, dst)`,
 * which is the same), but faster.
 *
 * @param v The vector to invert.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function invert(v, dst = create(0, 0)) {
    dst.x = -v.x;
    dst.y = -v.y;
    return dst;
}
/**
 * Computes length of a vector.
 *
 * @param v The vector.
 * @returns The length.
 */
function length(v) {
    return Math.hypot(v.x, v.y);
}
/**
 * Computes distance between ends of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The distance, i.e. `length(sub(a, b))`.
 */
function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
}
/**
 * Divides a vector by its length (thus making it a unit vector) and stores the
 * result to another one.
 *
 * @param v The vector to be normalized.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function normalize(v, dst = create(0, 0)) {
    return divn(v, length(v), dst);
}
/**
 * Computes dot product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The dot product.
 */
function dot(a, b) {
    return a.x * b.x + a.y * b.y;
}
/**
 * Computes Z-component of a cross product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns Z-component of the cross product.
 */
function crossZ(a, b) {
    return a.x * b.y - a.y * b.x;
}
const EMPTY = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
};
/* unused harmony export EMPTY */

const UNIT_BBOX = {
    minX: -1,
    maxX: 1,
    minY: -1,
    maxY: 1
};
/* unused harmony export UNIT_BBOX */

/**
 * Checks if two bounding boxes overlap.
 *
 * @param bbox1 A bounding box.
 * @param bbox2 Another bounding box.
 * @returns `true` if given bounding boxes do overlap and `false` otherwise.
 */
function bboxesOverlap(bbox1, bbox2) {
    let leftBBox;
    let rightBBox;
    if (bbox1.minX < bbox2.minX) {
        leftBBox = bbox1;
        rightBBox = bbox2;
    }
    else {
        leftBBox = bbox2;
        rightBBox = bbox1;
    }
    let topBBox;
    let bottomBBox;
    if (bbox1.maxY > bbox2.maxY) {
        topBBox = bbox1;
        bottomBBox = bbox2;
    }
    else {
        topBBox = bbox2;
        bottomBBox = bbox1;
    }
    return rightBBox.minX < leftBBox.maxX && bottomBBox.maxY > topBBox.minY;
}
/**
 * Checks if a 2D point lies inside a bounding box or on its border.
 *
 * @param point The point.
 * @param bbox The bounding box.
 * @returns `true` if the point is inside of the box and `false` otherwise.
 */
function pointIsInBBox(point, bbox) {
    return bbox.minX <= point.x && point.x <= bbox.maxX &&
        bbox.minY <= point.y && point.y <= bbox.maxY;
}
/**
 * Computes bounding box of an array of points and stores it to a given object.
 *
 * @param points The array of points.
 * @param dst The bbox the result will be written to. Left unmodified if the array
 *      of points is empty.
 * @returns `dst`.
 */
function computeBBoxForPoints(points, dst = { minX: 0, maxX: 0, minY: 0, maxY: 0 }) {
    if (points.length === 0) {
        return dst;
    }
    dst.minX = dst.maxX = points[0].x;
    dst.minY = dst.maxY = points[0].y;
    for (let i = 1; i < points.length; ++i) {
        const { x, y } = points[i];
        if (x < dst.minX) {
            dst.minX = x;
        }
        if (x > dst.maxX) {
            dst.maxX = x;
        }
        if (y < dst.minY) {
            dst.minY = y;
        }
        if (y > dst.maxY) {
            dst.maxY = y;
        }
    }
    return dst;
}
const X_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_X
};
/* unused harmony export X_AXIS */

const Y_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Y
};
/* unused harmony export Y_AXIS */

function getLineFromPoints(p1, p2, dst = {
    origin: create(0, 0),
    tangent: create(0, 0)
}) {
    copy(p1, dst.origin);
    sub(p2, p1, dst.tangent);
    return dst;
}
/**
 * Computes signed distance from a point to a line.
 *
 * @param p The point.
 * @param l1 Start point of the line.
 * @param l2 End point of the line.
 * @returns Distance from the point to the line. It'll be greater than 0 if the
 *      point lies to the left of the line and less than 0 otherwise.
 */
function getSignedDistanceToLine(p, l) {
    const tangent = l.tangent;
    return dot(sub(p, l.origin), create(-tangent.y, tangent.x)) / length(tangent);
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_iterable__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_pow_of_2__ = __webpack_require__(44);


/**
 * Gives size of a GL type.
 *
 * @param type The type.
 * @returns Size of the type in bytes.
 */
function getTypeSize(type) {
    switch (type) {
        case 5120 /* BYTE */:
        case 5121 /* UNSIGNED_BYTE */:
            return 1;
        case 5122 /* SHORT */:
        case 5123 /* UNSIGNED_SHORT */:
            return 2;
        case 5124 /* INT */:
        case 5125 /* UNSIGNED_INT */:
        case 5126 /* FLOAT */:
            return 4;
    }
}
/**
 * Description of how particular attributes of a vertex are packed into a vertex
 * buffer.
 */
class AttributeMapping extends Map {
    /**
     * Creates a new attribute mapping with a set of attributes of given types and
     * sizes. Automatically computes offsets of the attributes.
     *
     * @param mapping The mapping from attribute IDs to types and sizes.
     * @param alignment Desired alignment of attributes in the vertex data
     *      structure. Must be a power of 2.
     */
    constructor(mapping, alignment = 4 /* ALIGN_4_BYTES */) {
        let offset = 0;
        super(Object(__WEBPACK_IMPORTED_MODULE_0__util_iterable__["c" /* mapIterable */])(mapping, ([idx, { type, size, normalized }]) => {
            const pointer = [
                idx,
                {
                    type,
                    size,
                    normalized,
                    offset
                }
            ];
            const attributeSize = size * getTypeSize(type);
            const newOffset = Object(__WEBPACK_IMPORTED_MODULE_1__util_pow_of_2__["a" /* align */])(offset + attributeSize, -alignment);
            // FIXME(dmikis) Check this only in debug mode.
            if (newOffset - offset > attributeSize) {
                console.warn(`${newOffset - offset} byte padding's inserted`);
            }
            offset = newOffset;
            return pointer;
        }));
        this.vertexByteSize = offset;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = AttributeMapping;



/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = countVertices;
/* harmony export (immutable) */ __webpack_exports__["a"] = countIndices;
/**
 * @returns Integer number of vertices that fit into a region of specified in bytes size.
 */
function countVertices(vertexByteSize, attribMapping) {
    return vertexByteSize / attribMapping.vertexByteSize | 0;
}
/**
 * @returns Integer number of indices that fit into a region of specified in bytes size.
 */
function countIndices(indexByteSize, type) {
    switch (type) {
        case 5123 /* UNSIGNED_SHORT */:
            return indexByteSize >> 1;
        case 5125 /* UNSIGNED_INT */:
            return indexByteSize >> 2;
        default:
            return -1;
    }
}


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Simple pub/sub implementation. The emitter is supposed to emit only one type of event,
 * if someone has to emit events of different types, multiple emitters should be created.
 */
class EventEmitter {
    constructor() {
        this._listeners = new Set();
    }
    /**
     * Adds listener.
     */
    addListener(listener) {
        this._listeners.add(listener);
    }
    /**
     * Removes listener.
     */
    removeListener(listener) {
        this._listeners.delete(listener);
    }
    /**
     * Calls all the added listeners, the order (e.g. of adding) is not guaranteed.
     */
    fire(data) {
        for (const listener of this._listeners) {
            listener(data);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EventEmitter;

/**
 * Event emitter with no payload emitted.
 */
class VoidEventEmitter extends EventEmitter {
    fire() {
        super.fire(undefined);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = VoidEventEmitter;



/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__memory_relative_location__ = __webpack_require__(62);

function memoryLocationProvider(primitive) {
    return primitive.memorySubChunk;
}
function initBatch(primitive) {
    const subChunk = primitive.memorySubChunk;
    return {
        firstPrimitive: primitive,
        page: subChunk.memoryChunk.page,
        vertexByteOffset: subChunk.vertexByteOffset,
        vertexByteLength: subChunk.vertexByteLength,
        indexByteOffset: subChunk.indexByteOffset,
        indexByteLength: subChunk.indexByteLength
    };
}
/**
 * Renderer of primitives (objects that are physically presented in the scene). Most of the camera-related
 * staff (uniforms of camera position and projection matrix) is defined here.
 */
class PrimitiveRenderer {
    constructor(context, renderState, defaultProgram) {
        this._context = context;
        this._defaultProgram = defaultProgram;
        this._renderState = renderState;
    }
    /**
     * @param target The target to render primitives into.
     * @param uniforms Set of global uniforms.
     */
    render(target, uniforms) {
        this._bindProgram(this._program, uniforms);
        this._bindRenderState(this._renderState);
        this._bindRenderTarget(target);
        for (const cameraPosition of uniforms.cameraPositions) {
            this._program.setVector2Uniform('lookAtHigh', cameraPosition.lookAtHigh);
            this._program.setVector2Uniform('lookAtLow', cameraPosition.lookAtLow);
            this._renderPrimitives(this.primitives);
        }
    }
    destroy() {
        this._program.destroy();
    }
    /**
     * Batches primitives that can be rendered by a single draw call, that is critical for performance.
     * Performance gain from this method is possible (while it is not strictly required) if primitives
     * are sorted by memory offset and there are no many "holes" between them.
     * By default it batches primitives only by their locations in memory, but subclasses can
     * override _canBatch() method to break a batch at specific place, e.g. if a shader needs a texture and
     * two adjacent primitives don't share one these primitives must be in different batches
     */
    batchPrimitives(primitives) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__memory_relative_location__["a" /* batchAllocatedObjects */])(primitives, memoryLocationProvider, initBatch, this._canBatch);
    }
    /**
     * Determines if two primitives can be rendered in one batch (by a single draw call). It should be overridden
     * in subclasses if their primitives have more complex rules of batching (e.g. binding a shared texture).
     */
    _canBatch(a, b) {
        return a.memorySubChunk.memoryChunk.page === b.memorySubChunk.memoryChunk.page;
    }
    _bindProgram(program, uniforms) {
        this._context.bindProgram(program);
        program.setMatrix4Uniform('viewProjMatrix', uniforms.viewProjMatrix);
    }
    _bindRenderState(state) {
        this._context.bindRenderState(state);
    }
    _bindRenderTarget(target) {
        this._context.bindRenderTarget(target);
    }
    get _program() {
        return this._defaultProgram;
    }
    ;
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PrimitiveRenderer;



/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_primitive_presentation_class__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_event_emitter__ = __webpack_require__(4);


/**
 * Base abstract class that represent an object that comes from API.
 * Concrete primitives are supposed to control one or more engine's renderables according to
 * business rules (style/visibility updates on zooming) that also come from API.
 */
class ApiPrimitive {
    constructor(styles) {
        this._isVisible = false;
        this._presentationClass = new __WEBPACK_IMPORTED_MODULE_0__style_primitive_presentation_class__["a" /* default */](styles);
        this.onUpdate = new __WEBPACK_IMPORTED_MODULE_1__util_event_emitter__["b" /* VoidEventEmitter */]();
        this.isDestroyed = false;
    }
    /**
     * Notifies primitive about zoom changed. It monitors if something's (visibility/style) changed
     * and calls appropriate callback.
     */
    setZoom(zoom) {
        const style = this._presentationClass.getStyle(zoom);
        if (style && style !== this._style) {
            this._style = style;
            this.onStyleChanged(style);
        }
        this.updateVisibility();
    }
    updateVisibility() {
        const isVisible = this.checkVisibility();
        if (isVisible !== this._isVisible) {
            this._isVisible = isVisible;
            this.onVisibilityChanged(isVisible);
        }
    }
    checkVisibility() {
        return !!this._style;
    }
    destroy() {
        this.isDestroyed = true;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ApiPrimitive;



/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["e"] = create;
/* unused harmony export copy */
/* unused harmony export areEqual */
/* unused harmony export areFuzzyEqual */
/* unused harmony export areCollinear */
/* unused harmony export add */
/* harmony export (immutable) */ __webpack_exports__["n"] = sub;
/* harmony export (immutable) */ __webpack_exports__["j"] = mulv;
/* harmony export (immutable) */ __webpack_exports__["i"] = muln;
/* unused harmony export divv */
/* unused harmony export divn */
/* unused harmony export length */
/* unused harmony export distance */
/* harmony export (immutable) */ __webpack_exports__["k"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["g"] = dot;
/* harmony export (immutable) */ __webpack_exports__["f"] = cross;
/* harmony export (immutable) */ __webpack_exports__["l"] = rotateX;
/* unused harmony export rotateY */
/* harmony export (immutable) */ __webpack_exports__["m"] = rotateZ;
/* unused harmony export getPlaneLineIntersection */
/* harmony export (immutable) */ __webpack_exports__["h"] = getPlaneRayIntersection;
/* unused harmony export getPlanePlaneIntersection */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__matrix3__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__ = __webpack_require__(16);


/**
 * Creates a new vector and initializes it with given components.
 *
 * @param x X component of the vector.
 * @param y Y component of the vector.
 * @param z Z component of the vector.
 * @returns The vector.
 */
function create(x, y, z) {
    return { x, y, z };
}
const ORIGIN = create(0, 0, 0);
/* harmony export (immutable) */ __webpack_exports__["a"] = ORIGIN;

const POSITIVE_X = create(1, 0, 0);
/* unused harmony export POSITIVE_X */

const NEGATIVE_X = create(-1, 0, 0);
/* unused harmony export NEGATIVE_X */

const POSITIVE_Y = create(0, 1, 0);
/* harmony export (immutable) */ __webpack_exports__["b"] = POSITIVE_Y;

const NEGATIVE_Y = create(0, -1, 0);
/* unused harmony export NEGATIVE_Y */

const POSITIVE_Z = create(0, 0, 1);
/* harmony export (immutable) */ __webpack_exports__["c"] = POSITIVE_Z;

const NEGATIVE_Z = create(0, 0, -1);
/* unused harmony export NEGATIVE_Z */

/**
 * Copies a vector to another one.
 *
 * @param src The source vector.
 * @param dst The vector the source vector will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0, 0)) {
    dst.x = src.x;
    dst.y = src.y;
    dst.z = src.z;
    return dst;
}
/**
 * Checks if two vectors are strictly equal component-wise.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are equal and `false` otherwise.
 */
function areEqual(v1, v2) {
    return v1.x == v2.x && v1.y == v2.y && v1.z == v2.z;
}
/**
 * Checks if corresponding components of two vectors are all within given
 * tolerance from each other.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @param tolerance The tolerance.
 * @returns `true` if the vectors are "fuzzy" equal and `false` otherwise.
 */
function areFuzzyEqual(v1, v2, tolerance = __WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__["a" /* DEFAULT_TOLERANCE */]) {
    return (Object(__WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__["b" /* default */])(v1.x, v2.x, tolerance) &&
        Object(__WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__["b" /* default */])(v1.y, v2.y, tolerance) &&
        Object(__WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__["b" /* default */])(v1.z, v2.z, tolerance));
}
/**
 * Checks if two vectors are collinear.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are collinear and `false` otherwise.
 */
function areCollinear(v1, v2) {
    const lambdaX = v1.x / v2.x;
    const lambdaY = v1.y / v2.y;
    const lambdaZ = v1.z / v2.z;
    return lambdaX == lambdaY && lambdaY == lambdaZ;
}
/**
 * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function add(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
    dst.z = a.z + b.z;
    return dst;
}
/**
 * Subtracts a vector from another one and stores the result to a third one, i.e.
 * `dst = a - b`.
 *
 * @param a The minuend vector.
 * @param b The subtrahend vector.
 * @param dst The vector the result will be stored to.
 */
function sub(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
    dst.z = a.z - b.z;
    return dst;
}
/**
 * Multiplies two vectors component-wise and stores the result into a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mulv(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x * b.x;
    dst.y = a.y * b.y;
    dst.z = a.z * b.z;
    return dst;
}
/**
 * Multiplies a vector by a scalar and stores the result into a third vector.
 *
 * @param a The vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function muln(a, n, dst = create(0, 0, 0)) {
    dst.x = a.x * n;
    dst.y = a.y * n;
    dst.z = a.z * n;
    return dst;
}
/**
 * Divides a vector by another one component wise and stores the result into a
 * third one.
 *
 * @param a The dividend vector.
 * @param b The divisor vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divv(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x / b.x;
    dst.y = a.y / b.y;
    dst.z = a.z / b.z;
    return dst;
}
/**
 * Divides a vector by a scalar and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divn(a, n, dst = create(0, 0, 0)) {
    dst.x = a.x / n;
    dst.y = a.y / n;
    dst.z = a.z / n;
    return dst;
}
/**
 * Computes length of a vector.
 *
 * @param v The vector.
 * @returns The length.
 */
function length(v) {
    return Math.hypot(v.x, v.y, v.z);
}
/**
 * Computes distance between ends of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The distance, i.e. `length(sub(a, b))`.
 */
function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
}
/**
 * Divides a vector by its length (thus making it a unit vector) and stores the
 * result to another one.
 *
 * @param v The vector to be normalized.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function normalize(v, dst = create(0, 0, 0)) {
    return divn(v, length(v), dst);
}
/**
 * Computes dot product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The dot product.
 */
function dot(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}
/**
 * Computes cross product of two vectors and stores it to a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function cross(a, b, dst = create(0, 0, 0)) {
    // Write components to a separate variables so we don't produce incorrect
    // results in cases when a == dst or b == dst.
    const x = a.y * b.z - a.z * b.y;
    const y = a.z * b.x - a.x * b.z;
    const z = a.x * b.y - a.y * b.x;
    dst.x = x;
    dst.y = y;
    dst.z = z;
    return dst;
}
/**
 * Rotates vector about the X axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +Y to +Z
 * @param dst The vector the result will be stored to.
 */
function rotateX(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const y = v.y;
    dst.x = v.x;
    dst.y = y * cos - v.z * sin;
    dst.z = y * sin + v.z * cos;
    return dst;
}
/**
 * Rotates vector about the Y axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +X to +Z
 * @param dst The vector the result will be stored to.
 */
function rotateY(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    // handle the case when source and destination are the same object: related components can break each other
    v = (v === dst) ? copy(v) : v;
    dst.x = v.x * cos + v.z * sin;
    dst.y = v.y;
    dst.z = -v.x * sin + v.z * cos;
    return dst;
}
/**
 * Rotates vector about the Z axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +X to +Y
 * @param dst The vector the result will be stored to.
 */
function rotateZ(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    // handle the case when source and destination are the same object: related components can break each other
    v = (v === dst) ? copy(v) : v;
    dst.x = v.x * cos - v.y * sin;
    dst.y = v.x * sin + v.y * cos;
    dst.z = v.z;
    return dst;
}
const X_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_X
};
/* unused harmony export X_AXIS */

const Y_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Y
};
/* unused harmony export Y_AXIS */

const Z_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Z
};
/* unused harmony export Z_AXIS */

const XY = {
    normal: POSITIVE_Z,
    distance: 0
};
/* harmony export (immutable) */ __webpack_exports__["d"] = XY;

const YZ = {
    normal: POSITIVE_X,
    distance: 0
};
/* unused harmony export YZ */

const ZX = {
    normal: POSITIVE_Y,
    distance: 0
};
/* unused harmony export ZX */

/**
 * Computes intersection of a plane and a line.
 *
 * @param p The plane.
 * @param l The line.
 * @returns The point or `null` if the line is parallel to the plane.
 */
function getPlaneLineIntersection(p, l) {
    const dotLP = dot(l.tangent, p.normal);
    // If plane normal and line tangent vector are perpendicular intersection is
    // either an empty set or the line itself.
    if (dotLP == 0) {
        return null;
    }
    const intersection = copy(l.tangent);
    muln(intersection, (p.distance - dot(p.normal, l.origin)) / dotLP, intersection);
    add(intersection, l.origin, intersection);
    return intersection;
}
/**
 * Computes an intersection of a plane and a ray and stores it into a given
 * vector.
 *
 * @param plane The plane.
 * @param ray The ray.
 * @param dst The vector the intersection point will be stored to. If there's no
 *      intersection, this vector will be left unmodified.
 * @returns The `dst` or `null` if the ray doesn't have a common point with the
 *      plane.
 */
function getPlaneRayIntersection(plane, ray, dst = create(0, 0, 0)) {
    const dotRP = dot(ray.direction, plane.normal);
    if (dotRP === 0) {
        // The plane normal and the ray direction vector are perpendicular, so
        // intersection is either an empty set or the ray itself.
        return null;
    }
    const lambda = (plane.distance - dot(plane.normal, ray.origin)) / dotRP;
    if (lambda < 0) {
        // The intersection point is on a line that contains the ray, but not on
        // the ray itself.
        return null;
    }
    copy(ray.direction, dst);
    muln(dst, lambda, dst);
    add(dst, ray.origin, dst);
    return dst;
}
/**
 * Computes intersection of two planes.
 *
 * @param p1 The first plane.
 * @param p2 The second plane.
 * @returns The line or `null` if the planes are parallel to each other.
 */
function getPlanePlaneIntersection(p1, p2) {
    const n1 = p1.normal;
    const n2 = p2.normal;
    if (areCollinear(n1, n2)) {
        return null;
    }
    const tangent = cross(n1, n2);
    normalize(tangent);
    return {
        tangent,
        origin: __WEBPACK_IMPORTED_MODULE_0__matrix3__["b" /* solve */](__WEBPACK_IMPORTED_MODULE_0__matrix3__["a" /* fromRows */](n1, n2, tangent), create(p1.distance, p2.distance, 0))
    };
}


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Base class for primitive objects that are ready to be fed to the renderer.
 */
class RenderablePrimitive {
    constructor(memorySubChunk) {
        this.memorySubChunk = memorySubChunk;
    }
    destroy() {
        this.memorySubChunk.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderablePrimitive;



/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = create;
/* unused harmony export zero */
/* harmony export (immutable) */ __webpack_exports__["c"] = copy;
/* unused harmony export rotateX */
/* unused harmony export rotateY */
/* unused harmony export rotateZ */
/* harmony export (immutable) */ __webpack_exports__["g"] = translate;
/* unused harmony export scale */
/* harmony export (immutable) */ __webpack_exports__["e"] = lookAt;
/* harmony export (immutable) */ __webpack_exports__["f"] = perspective;
/* unused harmony export mul */
/* harmony export (immutable) */ __webpack_exports__["b"] = apply;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector3__ = __webpack_require__(7);

// TODO(dmikis) RoMatrix4?
const IDENTITY = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];
/* harmony export (immutable) */ __webpack_exports__["a"] = IDENTITY;

const MATRIX_SIZE = 16;
/**
 * Creates and returns a new **uninitialized** matrix.
 */
function create() {
    return new Array(MATRIX_SIZE);
}
/**
 * Zeroes a matrix.
 *
 * @param dst The matrix.
 * @returns `dst`.
 */
function zero(dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = 0;
    }
    return dst;
}
/**
 * Copies a matrix to another one.
 *
 * @param src The matrix to be copied.
 * @param dst The matrix the `src` will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = src[i];
    }
    return dst;
}
/**
 * Applies a rotation around the X axis by a given angle to a given matrix.
 * Positive direction is from positive Y to positive Z.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateX(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    //
    // 1   0    0 0
    // 0 cos -sin 0
    // 0 sin  cos 0
    // 0   0    0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i];
        const m1i = src[i + 1];
        const m2i = src[i + 2];
        dst[i + 1] = m1i * angleCos - m2i * angleSin;
        dst[i + 2] = m1i * angleSin + m2i * angleCos;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a rotation around the Y axis by a given angle to a given matrix.
 * Positive direction is from positive X to positive Z.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateY(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    //
    // cos 0 -sin 0
    // 0   1    0 0
    // sin 0  cos 0
    // 0    0   0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m2i = src[i + 2];
        dst[i] = m0i * angleCos - m2i * angleSin;
        dst[i + 1] = src[i + 1];
        dst[i + 2] = m0i * angleSin + m2i * angleCos;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a rotation around the X axis by a given angle to a given matrix.
 * Positive direction is from positive X to positive Y.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateZ(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    // cos -sin 0 0
    // sin  cos 0 0
    //   0    0 1 0
    //   0    0 0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m1i = src[i + 1];
        dst[i] = m0i * angleCos - m1i * angleSin;
        dst[i + 1] = m0i * angleSin + m1i * angleCos;
        dst[i + 2] = src[i + 2];
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a translation by a given vector to a given matrix.
 *
 * @param src The matrix to be multiplied by the translation matrix.
 * @param translation The translation vector.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function translate(src, translation, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m4i = dst[i + 3] = src[i + 3];
        dst[i] = src[i] + m4i * translation.x;
        dst[i + 1] = src[i + 1] + m4i * translation.y;
        dst[i + 2] = src[i + 2] + m4i * translation.z;
    }
    return dst;
}
/**
 * Applies a scale matrix by given factors (packed into a vector) to a given
 * matrix.
 *
 * @param src The matrix to be multiplied by the scale matrix.
 * @param factor The vector the scale factors packed into.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function scale(src, factor, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i] * factor.x;
        dst[i + 1] = src[i + 1] * factor.y;
        dst[i + 2] = src[i + 2] * factor.z;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
// The matrix:
// xAxis.x yAxis.x zAxis.x -eye.x
// xAxis.y yAxis.y zAxis.y -eye.y
// xAxis.z yAxis.z zAxis.z -eye.z
//       0       0       0 1
// where xAxis, yAxis and zAxis — axes of the eye coordinate system, eye —
// origin of the eye coordinate system.
const lookAtMatrix = copy(IDENTITY);
/**
 * Applies a matrix of transformation into a coordinate system of a camera
 * defined by its position, a point it's looking at and an up direction vector.
 *
 * @param src The matrix to be multiplied by the scale matrix.
 * @param eye The position of the camera.
 * @param center The point the camera's looking at.
 * @param up The up vector.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function lookAt(src, eye, center, up, dst = create()) {
    const zAxis = __WEBPACK_IMPORTED_MODULE_0__vector3__["n" /* sub */](eye, center);
    __WEBPACK_IMPORTED_MODULE_0__vector3__["k" /* normalize */](zAxis, zAxis);
    const xAxis = __WEBPACK_IMPORTED_MODULE_0__vector3__["f" /* cross */](up, zAxis);
    __WEBPACK_IMPORTED_MODULE_0__vector3__["k" /* normalize */](xAxis, xAxis);
    const yAxis = __WEBPACK_IMPORTED_MODULE_0__vector3__["f" /* cross */](zAxis, xAxis);
    lookAtMatrix[0] = xAxis.x;
    lookAtMatrix[1] = yAxis.x;
    lookAtMatrix[2] = zAxis.x;
    lookAtMatrix[4] = xAxis.y;
    lookAtMatrix[5] = yAxis.y;
    lookAtMatrix[6] = zAxis.y;
    lookAtMatrix[8] = xAxis.z;
    lookAtMatrix[9] = yAxis.z;
    lookAtMatrix[10] = zAxis.z;
    lookAtMatrix[12] = -__WEBPACK_IMPORTED_MODULE_0__vector3__["g" /* dot */](xAxis, eye);
    lookAtMatrix[13] = -__WEBPACK_IMPORTED_MODULE_0__vector3__["g" /* dot */](yAxis, eye);
    lookAtMatrix[14] = -__WEBPACK_IMPORTED_MODULE_0__vector3__["g" /* dot */](zAxis, eye);
    return mul(src, lookAtMatrix, dst);
}
/**
 * Applies a perspective matrix to a given one.
 *
 * @param src The matrix to be multiplied by the perspective matrix.
 * @param fov Vertical field of view angle.
 * @param aspectRatio Screen aspect ratio.
 * @param zNear Z-coordinate of near clipping plane.
 * @param zFar Z-coordinate of far clipping plane.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function perspective(src, fov, aspect, zNear, zFar, dst = create()) {
    const p11 = 1 / Math.tan(0.5 * fov);
    const p00 = p11 / aspect;
    const p22 = (zNear + zFar) / (zNear - zFar);
    const p32 = 2 * zNear * zFar / (zNear - zFar);
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i] * p00;
        dst[i + 1] = src[i + 1] * p11;
        const m2i = src[i + 2];
        const m3i = src[i + 3];
        dst[i + 2] = m2i * p22 + m3i * p32;
        dst[i + 3] = -m2i;
    }
    return dst;
}
/**
 * Multiplies a matrix by another one, i.e. `dst = m * src`.
 *
 * @param src The right matrix.
 * @param m The left matrix.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function mul(src, m, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m1i = src[i + 1];
        const m2i = src[i + 2];
        const m3i = src[i + 3];
        for (let j = 0; j < 4; ++j) {
            dst[i + j] = m0i * m[j] + m1i * m[4 + j] + m2i * m[8 + j] +
                m3i * m[12 + j];
        }
    }
    return dst;
}
/**
 * Applies a matrix to a vector.
 *
 * @param m The matrix.
 * @param v The vector.
 * @returns Normalized product of multiplying the vector by the matrix.
 */
function apply(m, v, dst = __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0)) {
    const w = m[3] * v.x + m[7] * v.y + m[11] * v.z + m[15];
    const x = (m[0] * v.x + m[4] * v.y + m[8] * v.z + m[12]) / w;
    const y = (m[1] * v.x + m[5] * v.y + m[9] * v.z + m[13]) / w;
    const z = (m[2] * v.x + m[6] * v.y + m[10] * v.z + m[14]) / w;
    dst.x = x;
    dst.y = y;
    dst.z = z;
    return dst;
}


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gputypes__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(73);


const WORD_BYTE_SIZE = 4;
/* harmony export (immutable) */ __webpack_exports__["a"] = WORD_BYTE_SIZE;

/**
 * Generates triangles of a fan of a given length as if it is continuous and
 * starts with 0.
 *
 * @param count Number of vertices in the fan.
 * @returns Iterator over indices of triangles.
 */
function* generateFan(count) {
    for (let i = 2; i < count; ++i) {
        yield 0;
        yield i - 1;
        yield i;
    }
}
/**
 * Generates triangles of a strip of a given length as if it is continuous and
 * starts with 0.
 *
 * @param count Number of vertices in the fan.
 * @returns Iterator over indices of triangles.
 */
function* generateStrip(count) {
    yield 0;
    yield 1;
    yield 2;
    let offset0 = 1;
    let offset1 = 2;
    for (let i = 3; i < count; ++i) {
        yield i - offset0;
        yield i - offset1;
        yield i;
        const tmp = offset0;
        offset0 = offset1;
        offset1 = tmp;
    }
}
/**
 * Vertex buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.
 * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.
 */
class VertexBuffer {
    /**
     * @param byteSize Initial size of the buffer in bytes. As it gets filled by words
     *      the size must be a multiply of 4.
     */
    constructor(byteSize) {
        this._nextWordOffset = 0;
        this._initBuffers(byteSize);
    }
    /**
     * @returns true if there is no free space remaining in buffer.
     */
    get isFull() {
        return this._nextWordOffset >= this._uint32View.length;
    }
    /**
     * @returns The number of words (4 bytes values) already written.
     */
    get occupiedSize() {
        return this._nextWordOffset;
    }
    /**
     * @return Max number of bytes this buffer is able to store. It can be increased by the extend() method.
     */
    get byteSize() {
        return this._uint32View.byteLength;
    }
    /**
     * Extends buffer to the new size. The new size must be not less than current one and it must be a multiply of 4.
     */
    extend(newByteSize) {
        // TODO assert newByteLength is larger than current _arrayBuffer and its is a multiply of the word size.
        const oldUint32View = this._uint32View;
        this._initBuffers(newByteSize);
        this._uint32View.set(oldUint32View);
    }
    /**
     * Appends value as a uint32 number.
     */
    pushUint32(value) {
        this._uint32View[this._nextWordOffset++] = value;
    }
    /**
     * Appends value as a float32 number.
     */
    pushFloat32(value) {
        this._float32View[this._nextWordOffset++] = value;
    }
    /**
     * @returns uint8 view of this buffer. The size of the view matches the amount of written data.
     */
    asUint32Array() {
        return this._uint32View.subarray(0, this.occupiedSize);
    }
    _initBuffers(byteLength) {
        const arrayBuffer = new ArrayBuffer(byteLength);
        this._uint32View = new Uint32Array(arrayBuffer);
        this._float32View = new Float32Array(arrayBuffer);
    }
    /**
     * Moves "tail" data (from the offset specified to the end of the buffer) of one buffer to another. The cursors of
     * buffers will be appropriately updated to reflect data changes.
     */
    static transferDataTail(src, dst, srcWordOffset, dstOffset = 0) {
        const tailLength = src.occupiedSize - srcWordOffset;
        const srcTail = src._uint32View.subarray(srcWordOffset, src.occupiedSize);
        dst._uint32View.set(srcTail, dstOffset);
        dst._nextWordOffset = tailLength;
        src._nextWordOffset = srcWordOffset;
    }
}
/**
 * Index buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.
 * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.
 */
class IndexBuffer {
    /**
     * @param size Initial size of the buffer.
     */
    constructor(size) {
        this._nextIndexOffset = 0;
        this._uint16View = new Uint16Array(size);
    }
    /**
     * @returns The number of indices already written.
     */
    get occupiedSize() {
        return this._nextIndexOffset;
    }
    /**
     * @return Max number of indices this buffer is able to store. It can be increased by the extend() method.
     */
    get size() {
        return this._uint16View.length;
    }
    /**
     * Extends buffer to the new size.
     */
    extend(newSize) {
        // TODO assert newByteLength is larger than current _arrayBuffer
        const oldUint16View = this._uint16View;
        this._uint16View = new Uint16Array(newSize);
        this._uint16View.set(oldUint16View);
    }
    /**
     * Appends index to the end of the buffer.
     */
    push(index) {
        this._uint16View[this._nextIndexOffset++] = index;
    }
    /**
     * @returns uint16 view of this buffer. The size of the view matches the amount of written data.
     */
    asUint16Array() {
        return new Uint16Array(this._uint16View.buffer, 0, this.occupiedSize);
    }
    /**
     * Moves "tail" data (from the offset specified to the end of the buffer) of one buffer to another. The offsets of
     * buffers will be appropriately updated to reflect data changes.
     * baseIndex will be deducted from all moved indices.
     */
    static transferDataTail(src, dst, baseIndex, srcOffset, dstOffset = 0) {
        for (let i = srcOffset, j = dstOffset; i < src.occupiedSize; i++, j++) {
            dst._uint16View[j] = src._uint16View[i] - baseIndex;
        }
        dst._nextIndexOffset = src.occupiedSize - srcOffset;
        src._nextIndexOffset = srcOffset;
    }
}
/**
 * Base buffer writer implementation. Can write unsigned short indices and
 * provides facilities for child classes to handle writing vertex data. Defines
 * a concept of current mesh. Basically, it mean that all vertices and indices
 * written to a writer between two `endMesh` calls (or construction of the writer
 * and an `endMesh` call) must be considered belonging to one atomic piece of
 * geometry and should not be spitted between separate buffers.
 */
class BufferWriter {
    /**
     * Creates a new writer and allocates initial amount of memory to store data.
     * Also implicitly "start" a mesh.
     *
     * @param vertexByteSize
     * @param initVertexBufferSize Init size (in vertices) of growing vertex buffers.
     * @param maxVertexBufferSize Max size (in vertices) of vertex buffers.
     * @param initIndexBufferUint16Size Init size (in uint16 number) of growing index buffers.
     */
    constructor(vertexByteSize, initVertexBufferSize = 0x400, maxVertexBufferSize = 0x10000, initIndexBufferUint16Size = 0xc00) {
        this._vertexByteSize = vertexByteSize;
        this._initVertexBufferByteSize = vertexByteSize * initVertexBufferSize;
        this._maxVertexBufferByteSize = vertexByteSize * maxVertexBufferSize;
        this._initIndexBufferUint16Size = initIndexBufferUint16Size;
        this._vertexBuffer = new VertexBuffer(this._initVertexBufferByteSize);
        this._vertexBuffers = [this._vertexBuffer];
        this._indexBuffer = new IndexBuffer(this._initIndexBufferUint16Size);
        this._indexBuffers = [this._indexBuffer];
        this._currentMeshVertexOffset = 0;
        this._currentMeshIndexOffset = 0;
        this._currentMeshBaseIndex = 0;
    }
    /**
     * Writes a bunch of indices to the underlying storage as unsigned short
     * numbers. If current storage doesn't have enough space to accommodate
     * given indices, the writer will automatically resize it. The writer
     * automatically adds base index to the supplied values, so from a user
     * point of view first vertex of a mesh has index 0 and there's no need
     * to take into account it's offset while generating mesh's topology.
     *
     * @param indices Array of indices to write.
     */
    writeIndices(indices) {
        this._ensureEnoughIndexBufferSpace(indices.length);
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (let i = 0; i < indices.length; ++i) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from an array of indices of a triangle strip
     * (as in GL) and writes generated triplets to the managed index buffer.
     * @see OpenGL ES 2.0 Spec, §2.6.1
     *
     * @param indices Indices of the strip.
     */
    writeIndicesForStrip(indices) {
        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (const i of generateStrip(indices.length)) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from a continuous triangle strip of a given
     * length and writes generated triplets to managed index buffer.
     * @see OpenGL ES 2.0 Spec, §2.6.1
     *
     * @param indexCount
     * @param baseIndexInMesh
     */
    writeIndicesForContinuousStrip(indexCount, baseIndexInMesh = 0) {
        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex + baseIndexInMesh;
        for (const i of generateStrip(indexCount)) {
            buffer.push(baseIndex + i);
        }
    }
    /**
     * Generates triangle indices from an array of indices of a triangle fan (as
     * in GL) and writes generated triplets to the managed index buffer.
     * @see OpenGL ES 2.0 Spec, §2.6.1
     *
     * @param indices Indices of the strip.
     */
    writeIndicesForFan(indices) {
        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (const i of generateFan(indices.length)) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from a continuous triangle fan of a given length
     * and writes generated triplets to managed index buffer.
     * @see OpenGL ES 2.0 Spec, §2.6.1
     *
     * @param indexCount
     * @param baseIndexInMesh
     */
    writeIndicesForContinuousFan(indexCount, baseIndexInMesh = 0) {
        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));
        const buffer = this._indexBuffer;
        const baseIndex = baseIndexInMesh + this._currentMeshBaseIndex;
        for (const i of generateFan(indexCount)) {
            buffer.push(baseIndex + i);
        }
    }
    /**
     * Ends current mesh and implicitly starts a new one.
     *
     * @returns Internal index of vertex and index buffers the mesh was written
     *      to and its memory location in them.
     */
    endMesh() {
        const currentMeshVertexOffset = this._currentMeshVertexOffset;
        const vertexOccupiedSize = this._vertexBuffer.occupiedSize;
        this._currentMeshVertexOffset = vertexOccupiedSize;
        this._currentMeshBaseIndex = (vertexOccupiedSize << 2) / this._vertexByteSize;
        const currentMeshIndexOffset = this._currentMeshIndexOffset;
        const indexOccupiedSize = this._indexBuffer.occupiedSize;
        this._currentMeshIndexOffset = indexOccupiedSize;
        return {
            vertexByteOffset: currentMeshVertexOffset << 2,
            vertexByteLength: vertexOccupiedSize - currentMeshVertexOffset << 2,
            indexByteOffset: currentMeshIndexOffset << 1,
            indexByteLength: indexOccupiedSize - currentMeshIndexOffset << 1,
            // We can't return actual buffer reference since it can change if
            // the buffer gets reallocated.
            bufferIndex: this._vertexBuffers.length - 1
        };
    }
    /**
     * Returns an array of currently owned buffer data. This call's better
     * made when you're done with the writer since if the writer decides to
     * resize any of the buffers some of the references in the returned array
     * may become outdated.
     */
    getBuffers() {
        return Object(__WEBPACK_IMPORTED_MODULE_1__array__["a" /* zip */])(this._vertexBuffers, this._indexBuffers, (vertexBuffer, indexBuffer) => ({
            vertexBuffer: vertexBuffer.asUint32Array(),
            indexBuffer: indexBuffer.asUint16Array()
        }));
    }
    /**
     * Returns an offset in the current vertex buffer to the location where next
     * piece of data will be written.
     */
    getCurrentVertexBufferByteOffset() {
        return this._vertexBuffer.occupiedSize << 2;
    }
    /**
     * Returns index of currently written vertex structure in the current vertex
     * buffer.
     */
    getCurrentVertexIdx() {
        return ((this._vertexBuffer.occupiedSize << 2) / this._vertexByteSize | 0) - this._currentMeshBaseIndex;
    }
    /**
     * Writes a floating point value to the current vertex buffer and advances
     * the offset by 4 bytes.
     *
     * @param value The value to be written.
     */
    _writeFloat32(value) {
        this._ensureEnoughVertexBufferSpace();
        this._vertexBuffer.pushFloat32(value);
    }
    /**
     * Writes an unsigned integer value to the current vertex buffer and advances
     * the offset by 4 bytes.
     *
     * @param value The value to be written.
     */
    _writeWord(value) {
        this._ensureEnoughVertexBufferSpace();
        this._vertexBuffer.pushUint32(value);
    }
    /**
     * Writes an unsigned short value to the current vertex buffer and advances
     * the offset by 2 bytes. Passed values will be truncated to 16 bits.
     *
     * @param value The value to be written.
     */
    _writeHalfWords(v1, v2) {
        this._writeWord(v2 << 16 | v1 & 0xffff);
    }
    /**
     * Writes an unsigned byte value to the current vertex buffer and advances
     * the offset by 1 byte. Passed values will be truncated to 8 bits.
     *
     * @param value The value to be written.
     */
    _writeBytes(v1, v2, v3, v4) {
        this._writeWord(v4 << 24 |
            (v3 & 0xff) << 16 |
            (v2 & 0xff) << 8 |
            v1 & 0xff);
    }
    /**
     * Encodes a world coordinate vector as a pair of 32-bit integers (splitting
     * them in turn into to 16-bit ones).
     *
     * @param c The world coordinate.
     */
    _writeWorldCoordinate(c) {
        // To avoid using GPU singed integer conversions we shift and scale world
        // coordinates so they're in [0, 1] range (instead of [-1, 1]) and then
        // encoded as unsigned 32 bit integers split into to 16 bit ones.
        const xUint32 = Object(__WEBPACK_IMPORTED_MODULE_0__gputypes__["b" /* floatToUint32 */])(0.5 * (c.x + 1));
        const yUint32 = Object(__WEBPACK_IMPORTED_MODULE_0__gputypes__["b" /* floatToUint32 */])(0.5 * (c.y + 1));
        this._writeHalfWords(xUint32 >>> 16, yUint32 >>> 16);
        this._writeHalfWords(xUint32, yUint32);
    }
    /**
     * Computes new bigger size of a vertex buffer based on its current size. By
     * default just double the current size.
     *
     * @param currentByteSize Current size of the index buffer in bytes.
     * @returns The new size.
     */
    _getNextVertexBufferByteSize(currentByteSize) {
        return currentByteSize << 1;
    }
    /**
     * Computes new bigger size of an index buffer based on its current size. By
     * default just double the current size.
     *
     * @param currentUint16Size Current size of the index buffer in shorts.
     * @returns The new size.
     */
    _getNextIndexBufferUint16Size(currentUint16Size) {
        return currentUint16Size << 1;
    }
    /**
     * Ensures that the managed vertex buffer has enough space to fit in a chunk
     * of data of a given size. Either does nothing, resizes the current vertex
     * buffer or creates entirely new pair of vertex and index buffers.
     *
     * @param valueSize Byte size of the data that needs to be accommodated by
     *      the vertex buffer.
     */
    _ensureEnoughVertexBufferSpace() {
        const vertexBuffer = this._vertexBuffer;
        if (!vertexBuffer.isFull) {
            // We have enough space, so nothing to be done.
            return;
        }
        if (vertexBuffer.byteSize < this._maxVertexBufferByteSize) {
            // If we can just resize the current vertex buffer, do that.
            this._vertexBuffer.extend(this._getNextVertexBufferByteSize(vertexBuffer.byteSize));
            return;
        }
        // If there's no enough space in the current vertex buffer and it's
        // already of maximum size, allocate new vertex and index buffers and
        // copy data of the current mesh to them from the current buffers.
        // Then make those buffer the current ones.
        const currentMeshVertexOffset = this._currentMeshVertexOffset;
        const currentMeshVertexByteSize = (vertexBuffer.occupiedSize - currentMeshVertexOffset) * 4;
        const maxVertexBufferByteSize = this._maxVertexBufferByteSize;
        if (currentMeshVertexByteSize == maxVertexBufferByteSize) {
            throw new Error('Mesh is too big to fit in.');
        }
        let newVertexBufferByteSize = this._initVertexBufferByteSize;
        // Initial vertex buffer size may be too small to accommodate the current
        // mesh, so we find next bigger size that is sufficient.
        while (newVertexBufferByteSize <= currentMeshVertexByteSize) {
            newVertexBufferByteSize = this._getNextVertexBufferByteSize(newVertexBufferByteSize);
        }
        const newVertexBuffer = new VertexBuffer(newVertexBufferByteSize);
        VertexBuffer.transferDataTail(vertexBuffer, newVertexBuffer, currentMeshVertexOffset);
        this._vertexBuffer = newVertexBuffer;
        this._vertexBuffers.push(newVertexBuffer);
        this._currentMeshVertexOffset = 0;
        const indexBuffer = this._indexBuffer;
        const currentMeshIndexOffset = this._currentMeshIndexOffset;
        const currentMeshIndexSize = indexBuffer.occupiedSize - currentMeshIndexOffset;
        let newIndexBufferSize = this._initIndexBufferUint16Size;
        // Initial index buffer size may be too small to accommodate the current
        // mesh, so we find next bigger size that is sufficient.
        while (newIndexBufferSize <= currentMeshIndexSize) {
            newIndexBufferSize = this._getNextIndexBufferUint16Size(newIndexBufferSize);
        }
        const newIndexBuffer = new IndexBuffer(newIndexBufferSize);
        // Since the current mesh's copied to the beginning of the new vertex
        // buffer, it's base index now is 0. If the mesh has any written indices,
        // they're already offset by the old base index.
        IndexBuffer.transferDataTail(indexBuffer, newIndexBuffer, this._currentMeshBaseIndex, currentMeshIndexOffset);
        this._currentMeshBaseIndex = 0;
        this._currentMeshIndexOffset = 0;
        this._indexBuffer = newIndexBuffer;
        this._indexBuffers.push(newIndexBuffer);
    }
    /**
     * Ensures that the managed index buffer has enough space to fit in a given
     * number of indices. Either does nothing or resizes the current index
     * buffer.
     *
     * @param indexCount Number of indices client wants to write to the managed
     *      index buffer.
     */
    _ensureEnoughIndexBufferSpace(indexCount) {
        const buffer = this._indexBuffer;
        const requiredSize = buffer.occupiedSize + indexCount;
        if (requiredSize <= buffer.size) {
            // We have enough space so nothing to be done.
            return;
        }
        let newBufferSize = buffer.size;
        // Let's compute new larger size of the index buffer until we can
        // accommodate incoming data.
        while (requiredSize > newBufferSize) {
            newBufferSize = this._getNextIndexBufferUint16Size(newBufferSize);
        }
        this._indexBuffer.extend(newBufferSize);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = BufferWriter;



/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = clamp;
/* harmony export (immutable) */ __webpack_exports__["b"] = cycleRestrict;
/* unused harmony export mix */
/* harmony export (immutable) */ __webpack_exports__["c"] = smoothStep;
/**
 * Clamps a value to a given range.
 *
 * @param x The value.
 * @param min Start of the range.
 * @param max End of the range.
 * @returns Clamped value.
 */
function clamp(x, min, max) {
    return min < x ? x < max ? x : max : min;
}
/**
 * Restricts a value to a given cycled range, i.e. ends of the range are
 * equivalent. E.g. like angles can be restricted to any range of size `2 * PI`.
 *
 * @param x The value.
 * @param min Start of the range.
 * @param max End of the range.
 * @returns Restricted value.
 */
function cycleRestrict(x, min, max) {
    const d = max - min;
    const s = (x - min) / (max - min);
    return min + d * (s - Math.floor(s));
}
/**
 * Linear interpolation.
 *
 * @param min Value that correspond to 0% progress.
 * @param max Value that correspond to 100% progress.
 * @param progress In 0..1.0 range that maps to 0..100% progress. It is allowed to pass a value
 *      outside of this range, that means progress greater then 100% or negative progress.
 */
function mix(min, max, progress) {
    return (1 - progress) * min + progress * max;
}
/**
 * A step function with a smooth transition between given edges. Completely
 * analogous to `smoothstep` in GLSL (GLSL ES 1.0 §8.3).
 *
 * @param edge1 The smaller edge.
 * @param edge2
 * @param x `0` if `x < edge1`, `1` if `x > edge2` and an interpolated value for
 *      `edge1 < x < edge2`.
 */
function smoothStep(edge1, edge2, x) {
    const factor = clamp((x - edge1) / (edge2 - edge1), 0, 1);
    return factor * factor * (3 - 2 * factor);
}


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = floatToUint16;
/* unused harmony export floatToInt16 */
/* harmony export (immutable) */ __webpack_exports__["b"] = floatToUint32;
/* unused harmony export floatToInt32 */
/* unused harmony export int32ToFloat */
/* unused harmony export uint32ToFloat */
/* unused harmony export int16ToFloat */
/* harmony export (immutable) */ __webpack_exports__["c"] = int24ToFloat;
/* harmony export (immutable) */ __webpack_exports__["d"] = uint16ToFloat;
const UINT16_MAX = 0xffff;
const UINT32_MAX = 0xffffffff;
function floatToUint16(x) {
    return x * UINT16_MAX | 0;
}
function floatToInt16(x) {
    return (x * UINT16_MAX - 1) / 2 | 0;
}
function floatToUint32(x) {
    return x * UINT32_MAX | 0;
}
function floatToInt32(x) {
    return (x * UINT32_MAX - 1) / 2 | 0;
}
function int32ToFloat(x) {
    return (2 * x + 1) / UINT32_MAX;
}
function uint32ToFloat(x) {
    return x / UINT32_MAX;
}
function int16ToFloat(x) {
    return (2 * x + 1) / UINT16_MAX;
}
function int24ToFloat(x) {
    return Math.max(-1, x / 0x7fffff);
}
function uint16ToFloat(x) {
    return x / UINT16_MAX;
}


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export findInIterable */
/* harmony export (immutable) */ __webpack_exports__["c"] = mapIterable;
/* harmony export (immutable) */ __webpack_exports__["b"] = filterIterable;
/* unused harmony export reduceIterable */
/* unused harmony export oneOfIterable */
/* harmony export (immutable) */ __webpack_exports__["a"] = allOfIterable;
/* unused harmony export rangeIterable */
/* unused harmony export zipIterables */
/**
 * Searches for the first collection item satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns The first item satisfying the predicate or `undefined` if none found.
 */
function findInIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            return item;
        }
    }
    return;
}
/**
 * Transforms a collection to another one.
 *
 * @param collection The source collection.
 * @param mapper A function producing items for destination collection.
 * @returns Collection of produced items.
 */
function* mapIterable(collection, mapper) {
    for (const item of collection) {
        yield mapper(item);
    }
}
/**
 * Chooses items of a collection satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns Collection of chosen items.
 */
function* filterIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            yield item;
        }
    }
}
/**
 * Traverses a collection from left to right recomputing an accumulator on every
 * iteration.
 *
 * @param collection The collection.
 * @param reducer The function used to compute next value of the accumulator.
 * @param initial
 * @returns Value of the accumulator.
 */
function reduceIterable(collection, reducer, initial) {
    let result = initial;
    for (const item of collection) {
        result = reducer(result, item);
    }
    return result;
}
/**
 * Checks if there's at least one item in a collection satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns `true` if for at least one item in the collection the predicate returns
 *      `true` and `false` otherwise.
 */
function oneOfIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            return true;
        }
    }
    return false;
}
/**
 * Checks if all items of a collection satisfy a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns `false` if for at least one item in the collection the predicate returns
 *      `false` and `true` otherwise.
 */
function allOfIterable(collection, predicate) {
    for (const item of collection) {
        if (!predicate(item)) {
            return false;
        }
    }
    return true;
}
/**
 * Creates an iterator for [startIndex, startIndex+length) range.
 */
function* rangeIterable(length, startIndex = 0) {
    const endIndex = startIndex + length;
    for (let i = startIndex; i < endIndex; i++) {
        yield i;
    }
}
function* zipIterables(ts, us, zipper = (t, u) => [t, u]) {
    const tIterator = ts[Symbol.iterator]();
    const uIterator = us[Symbol.iterator]();
    for (let t = tIterator.next(), u = uIterator.next(); !(t.done || u.done); t = tIterator.next(), u = uIterator.next()) {
        yield zipper(t.value, u.value);
    }
}


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = create;
/* harmony export (immutable) */ __webpack_exports__["b"] = copy;
/* harmony export (immutable) */ __webpack_exports__["a"] = areEqual;
/* unused harmony export decodeAbgr8 */
/* unused harmony export encodeRgba8 */
/* unused harmony export isOpaque */
const OPAQUE_BLACK = create(0, 0, 0, 1);
/* unused harmony export OPAQUE_BLACK */

const TRANSPARENT_BLACK = create(0, 0, 0, 0);
/* unused harmony export TRANSPARENT_BLACK */

/**
 * @param r Red component as a normalized value [0..1]
 * @param g Green component as a normalized value [0..1]
 * @param b Blue component as a normalized value [0..1]
 * @param a Alpha component as a normalized value [0..1]
 *
 * @returns A color with given values assigned to components.
 */
function create(r, g, b, a = 1) {
    return { r, g, b, a };
}
/**
 * Copies a color to another one.
 *
 * @param src The source color.
 * @param dst The color the source color will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0, 0, 0)) {
    dst.r = src.r;
    dst.g = src.g;
    dst.b = src.b;
    dst.a = src.a;
    return dst;
}
function areEqual(c1, c2) {
    return c1.r == c2.r && c1.g == c2.g && c1.b == c2.b && c1.a == c2.a;
}
/**
 * Decodes a color represented as four 8-bit channels encoded into a 32-bit
 * number in ABGR order (from MSB to LSB).
 *
 * @param color Color encoded into unsigned 32-bit integer.
 * @returns Decoded color.
 */
function decodeAbgr8(color) {
    return {
        r: (color >>> 24) / 0xff,
        g: (color >>> 16 & 0xff) / 0xff,
        b: (color >>> 8 & 0xff) / 0xff,
        a: (color & 0xff) / 0xff
    };
}
/**
 * Encodes a color components into four 8 bit numbers packed into 32-bit one.
 *
 * @param c The color to be encoded.
 * @returns The color as 32-bit integer.
 */
function encodeRgba8(c) {
    return (c.r * 0xff |
        (c.g * 0xff << 8) |
        (c.b * 0xff << 16) |
        (c.a * 0xff << 24));
}
/**
 * Checks if a color is completely opaque.
 *
 * @param color The color to be checked.
 * @returns `true` if the color is opaque and `false` otherwise.
 */
function isOpaque(color) {
    return color.a === 1;
}


/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec2 vertexPosition;\nattribute vec2 vertexUv;\n\n#ifndef YV_LEAST_16b_P\n#   ifdef GL_FRAGMENT_PRECISION_HIGH\n#       define YV_LEAST_16b_P highp\n#   else\n#       define YV_LEAST_16b_P mediump\n#   endif\n#endif\n\nvarying YV_LEAST_16b_P vec2 uv;\n\nvoid main(void) {\n    gl_Position = vec4(vertexPosition, 0, 1);\n    uv = vertexUv;\n}\n"

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = areFuzzyEqual;
const DEFAULT_TOLERANCE = 1e-6;
/* harmony export (immutable) */ __webpack_exports__["a"] = DEFAULT_TOLERANCE;

/**
 * Checks if two floating point number are within a tolerance from each other.
 *
 * @param a The first number.
 * @param b The second number.
 * @param tolerance The tolerance.
 * @returns `true` if the number are within the tolerance and `false` otherwise.
 */
function areFuzzyEqual(a, b, tolerance = DEFAULT_TOLERANCE) {
    const d = a - b;
    return -tolerance < d && d < tolerance;
}


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Simple reference counting for shared entities that need explicit destruction.
 */
class ReferenceCounted {
    /**
     * Initializes reference count to 1.
     */
    constructor() {
        this._refCount = 1;
    }
    /**
     * Increments reference count.
     */
    retain() {
        if (this._refCount == 0) {
            throw new Error('Tried to retain a destroyed object.');
        }
        this._refCount++;
    }
    /**
     * Decrements reference count and, if it's reached 0, destroys the object.
     */
    release() {
        if (this._refCount == 0) {
            throw new Error('Tried to release a destroyed object.');
        }
        this._refCount--;
        if (this._refCount === 0) {
            this.destroy();
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ReferenceCounted;



/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__binary_tree__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__linked_set__ = __webpack_require__(59);


/**
 * Alignes an offset so it's a multiple of an alignment.
 *
 * @param offset The offset.
 * @param alignment The alignment.
 * @returns Aligned offset.
 */
function align(offset, alignment) {
    return alignment * Math.ceil(offset / alignment);
}
class ArenaAllocator {
    /**
     * Constructs a new empty arena allocator.
     *
     * @param size Size of managed region.
     * @param alignment alignment of offsets.
     */
    constructor(size, alignment = 1) {
        this._size = size;
        this._alignment = alignment;
        this._freeOffset = 0;
        this._allocatedOffsets = new Set();
    }
    get size() {
        return this._size;
    }
    get maxAllocableSize() {
        return this._size - this._freeOffset;
    }
    get isEmpty() {
        return this._allocatedOffsets.size === 0;
    }
    allocate(size) {
        if (this._size >= this._freeOffset + size) {
            const offset = this._freeOffset;
            this._freeOffset = align(offset + size, this._alignment);
            this._allocatedOffsets.add(offset);
            return offset;
        }
        else {
            return -1;
        }
    }
    deallocate(offset) {
        this._allocatedOffsets.delete(offset);
    }
    isAllocated(offset) {
        return offset < this._freeOffset;
    }
    extend(newSize) {
        if (newSize < this._freeOffset) {
            throw new Error('Could not reduce the size because it conflicts with already allocated region.');
        }
        this._size = newSize;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ArenaAllocator;

/**
 * Allocator optimised for both primary operations: allocation and deallocation. It uses BST for efficient lookup of
 * suitable free region during allocation and two way linked list for fast adjacent free regions merge.
 * Max allocable size is also determined by means of the BST.
 */
class FreeListAllocator {
    constructor(size) {
        this._size = size;
        this._allRegions = new __WEBPACK_IMPORTED_MODULE_1__linked_set__["a" /* default */]();
        this._occupiedRegions = new Map();
        this._freeRegions = new __WEBPACK_IMPORTED_MODULE_0__binary_tree__["a" /* BinarySearchTree */]((rangeA, rangeB) => rangeA.size - rangeB.size);
        const initRegion = { offset: 0, size };
        this._allRegions.insert(initRegion);
        initRegion._freeNode = this._freeRegions.insert(initRegion);
    }
    get size() {
        return this._size;
    }
    get maxAllocableSize() {
        const max = this._freeRegions.max;
        return max ? max.size : 0;
    }
    get isEmpty() {
        return this._occupiedRegions.size == 0;
    }
    allocate(size) {
        const node = this._findMinSuitable(size);
        if (!node) {
            return -1;
        }
        const range = node.value;
        // current region is not available anymore
        // it is removed from the free regions pool
        this._freeRegions.remove(node);
        // new occupied one is created
        const occupiedRange = { offset: range.offset, size };
        this._occupiedRegions.set(range.offset, occupiedRange);
        this._allRegions.insertAfter(range, occupiedRange);
        this._allRegions.remove(range);
        // dont loose remaining if any
        // it should be returned back to the free regions pool
        if (range.size > size) {
            const remainingRange = { offset: range.offset + size, size: range.size - size };
            remainingRange._freeNode = this._freeRegions.insert(remainingRange);
            this._allRegions.insertAfter(occupiedRange, remainingRange);
        }
        return occupiedRange.offset;
    }
    deallocate(offset) {
        let region = this._occupiedRegions.get(offset);
        if (region) {
            // check if the region can be merged with its previous neighbor
            const prev = this._allRegions.getPrev(region);
            if (prev && prev._freeNode) {
                const embracingRange = { offset: prev.offset, size: prev.size + region.size };
                this._allRegions.insertAfter(prev, embracingRange);
                this._allRegions.remove(region);
                this._allRegions.remove(prev);
                this._freeRegions.remove(prev._freeNode);
                region = embracingRange;
            }
            // check if the region can be merged with its next neighbor
            const next = this._allRegions.getNext(region);
            if (next && next._freeNode) {
                const embracingRange = { offset: region.offset, size: region.size + next.size };
                this._allRegions.insertBefore(next, embracingRange);
                this._allRegions.remove(region);
                this._allRegions.remove(next);
                this._freeRegions.remove(next._freeNode);
                region = embracingRange;
            }
            this._occupiedRegions.delete(offset);
            region._freeNode = this._freeRegions.insert(region);
        }
    }
    isAllocated(offset) {
        return this._occupiedRegions.has(offset);
    }
    extend(newSize) {
        if (newSize < this._size) {
            throw new Error('Size reducing is not allowed in free list allocator');
        }
        const diff = newSize - this._size;
        const last = this._allRegions.end;
        if (last && last._freeNode) {
            this._freeRegions.remove(last._freeNode);
            const region = { offset: last.offset, size: last.size + diff, isFree: true };
            this._allRegions.insertAfter(last, region);
            this._allRegions.remove(last);
            this._freeRegions.insert(region);
        }
        else {
            const region = { offset: this._size, size: diff, isFree: true };
            this._allRegions.insert(region);
            this._freeRegions.insert(region);
        }
        this._size = newSize;
    }
    /**
     * Traverses BST to find the smallest region required size can fit.
     */
    _findMinSuitable(size) {
        let node = this._freeRegions.root;
        let best;
        while (node) {
            if (node.value.size === size) {
                best = node;
                break;
            }
            else if (node.value.size < size) {
                node = node.right;
            }
            else {
                best = node;
                node = node.left;
            }
        }
        return best;
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = FreeListAllocator;



/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n\nuniform float dpr;\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst float MAX_CORRECTED_GLYPH_SCALE = 0.5;\nconst float GLYPH_BASE_WEIGHT = 0.7;\nconst float GLYPH_BASE_SMOTHNESS = 0.1;\nconst float GLYPH_WEIGHT_SCALE_IMPACT = 0.1;\nconst float GLYPH_SMOOTHNESS_SCALE_IMPACT = 0.06;\nconst float OUTLINE_WEIGHT_SCALE_IMPACT = 0.125;\n\nvoid main(void) {\n#ifdef COLOR_ID_MODE\n    gl_FragColor = color;\n#else\n    // low scale glyphs (less than 0.5) should be a little bit bolder and smoother\n    float scaleClamped = clamp(scale, 0.0, MAX_CORRECTED_GLYPH_SCALE);\n    // weight is responsible for glyph boldness, the less weight value the bolder the text\n    float weight = GLYPH_BASE_WEIGHT + GLYPH_WEIGHT_SCALE_IMPACT * scaleClamped;\n    // smoothness is how blurred glyphs are, the less smoothness value the less blurring\n    float smoothness = (GLYPH_BASE_SMOTHNESS + GLYPH_SMOOTHNESS_SCALE_IMPACT / scaleClamped) / dpr;\n\n    vec4 resultColor = color;\n    float dist = texture2D(atlas, uv / atlasSize).a;\n    float alpha = smoothstep(weight - smoothness, weight + smoothness, dist);\n\n    if (outlineColor.a != 0.0) {\n        // to render outline the glyph is rendered a little bit bolder with different color at edges\n        weight = weight - OUTLINE_WEIGHT_SCALE_IMPACT / scale;\n        resultColor = mix(outlineColor, color, alpha);\n        alpha = smoothstep(weight - smoothness, weight + smoothness, dist);\n    }\n\n    gl_FragColor = vec4(resultColor.rgb, resultColor.a * alpha);\n#endif\n}\n"

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__primitive_renderer__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__memory_count_vertices__ = __webpack_require__(3);




/**
 * Base renderer that incapsulates all the GL specifics to make labels rendered.
 */
class LabelRenderer extends __WEBPACK_IMPORTED_MODULE_2__primitive_renderer__["a" /* default */] {
    constructor(context, program, colorIdProgram) {
        super(context, new __WEBPACK_IMPORTED_MODULE_0__state__["b" /* default */](__WEBPACK_IMPORTED_MODULE_0__state__["a" /* BLEND_OVER_RENDER_STATE */]), program);
        this._colorIdMode = {
            enabled: false,
            program: colorIdProgram,
            stabilityShift: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["e" /* create */](0, 0)
        };
    }
    render(target, uniforms) {
        this._colorIdMode.enabled = false;
        super.render(target, uniforms);
    }
    renderVisible(target, uniforms, visibility) {
        this._visibility = visibility;
        this._colorIdMode.enabled = false;
        super.render(target, uniforms);
    }
    renderInColorIdMode(target, uniforms, stabilityShift) {
        delete this._visibility;
        this._colorIdMode.enabled = true;
        this._colorIdMode.stabilityShift = stabilityShift;
        super.render(target, uniforms);
    }
    renderInColorIdModeReversePriority(target, uniforms, stabilityShift) {
        delete this._visibility;
        this._colorIdMode.enabled = true;
        this._colorIdMode.stabilityShift = stabilityShift;
        super.render(target, uniforms);
    }
    destroy() {
        super.destroy();
        this._visibility.destroy();
        this._colorIdMode.program.destroy();
    }
    _renderPrimitives(primitives) {
        if (this._visibility) {
            this._context.bindTextureUnit(1);
            this._context.bindTexture(this._visibility);
            this._program.setIntScalarUniform('visibility', 1);
            this._program.setVector2Uniform('visibilitySize', __WEBPACK_IMPORTED_MODULE_1__math_vector2__["e" /* create */](this._visibility.getWidth(), this._visibility.getHeight()));
        }
        for (const memoryBatch of this.batchPrimitives(primitives)) {
            if (!this._colorIdMode.enabled) {
                const atlas = memoryBatch.firstPrimitive.atlas;
                this._program.setIntScalarUniform('atlas', 0);
                this._program.setVector2Uniform('atlasSize', __WEBPACK_IMPORTED_MODULE_1__math_vector2__["e" /* create */](atlas.width, atlas.height));
                this._context.bindTextureUnit(0);
                this._context.bindTexture(atlas.texture);
            }
            else {
                this._program.setVector2Uniform('shift', this._colorIdMode.stabilityShift);
            }
            this._context.bindVao(memoryBatch.page.vao);
            this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(__WEBPACK_IMPORTED_MODULE_3__memory_count_vertices__["a" /* countIndices */])(memoryBatch.indexByteLength, memoryBatch.page.indexType));
        }
    }
    _bindProgram(program, uniforms) {
        super._bindProgram(program, uniforms);
        program.setVector2Uniform('pixelSize', uniforms.pixelSize);
        if (!this._colorIdMode.enabled) {
            program.setScalarUniform('dpr', window.devicePixelRatio);
        }
    }
    _bindRenderState(state) {
        if (!this._colorIdMode.enabled) {
            super._bindRenderState(state);
        }
    }
    _canBatch(a, b) {
        return super._canBatch(a, b) && (a.atlas == b.atlas);
    }
    get _program() {
        return this._colorIdMode.enabled ? this._colorIdMode.program : super._program;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LabelRenderer;



/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_renderer__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_image_vert__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_image_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_image_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shader_image_frag__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shader_image_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__shader_image_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__memory_count_vertices__ = __webpack_require__(3);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_1__state__["b" /* default */](__WEBPACK_IMPORTED_MODULE_1__state__["a" /* BLEND_OVER_RENDER_STATE */]);
/**
 * Renderer of image primitives.
 */
class ImageRenderer extends __WEBPACK_IMPORTED_MODULE_0__primitive_renderer__["a" /* default */] {
    constructor(context, program) {
        super(context, RENDER_STATE, program || context.createProgram(__WEBPACK_IMPORTED_MODULE_2__shader_image_vert___default.a, __WEBPACK_IMPORTED_MODULE_3__shader_image_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexUV: 4 /* UV */
            }
        }));
    }
    _renderPrimitives(primitives) {
        for (const memoryBatch of this.batchPrimitives(primitives)) {
            const atlas = memoryBatch.firstPrimitive.atlas;
            if (atlas.isDirty) {
                atlas.syncTexture();
            }
            this._program.setIntScalarUniform('atlas', 0);
            this._program.setVector2Uniform('atlasSize', Object(__WEBPACK_IMPORTED_MODULE_4__math_vector2__["e" /* create */])(atlas.width, atlas.height));
            this._context.bindTextureUnit(0);
            this._context.bindTexture(atlas.texture);
            this._context.bindVao(memoryBatch.page.vao);
            this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(__WEBPACK_IMPORTED_MODULE_5__memory_count_vertices__["a" /* countIndices */])(memoryBatch.indexByteLength, memoryBatch.page.indexType));
        }
    }
    _canBatch(a, b) {
        return super._canBatch(a, b) && (a.atlas == b.atlas);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageRenderer;



/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PostprocessType; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shaders_quad_vert__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shaders_quad_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shaders_quad_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fill_frag__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fill_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shaders_fill_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__state__ = __webpack_require__(0);



const POSTPROCESSING_STATE = new __WEBPACK_IMPORTED_MODULE_2__state__["b" /* default */]({
    depthMask: false,
    depthTest: false
});
var PostprocessType;
(function (PostprocessType) {
    PostprocessType[PostprocessType["COPY"] = 0] = "COPY";
    PostprocessType[PostprocessType["BACKGROUND"] = 1] = "BACKGROUND";
})(PostprocessType || (PostprocessType = {}));
/**
 * Renderer of postprocessing pass.
 */
class PostprocessRenderer {
    constructor(context, type) {
        this._context = context;
        this._type = type;
        let defines;
        switch (type) {
            case PostprocessType.COPY:
                defines = {
                    YV_TEXTURE_FILL: 1
                };
                break;
            case PostprocessType.BACKGROUND:
                defines = {
                    YV_BACKGROUND: 1
                };
                break;
        }
        this._program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shaders_quad_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shaders_fill_frag___default.a, {
            defines,
            attribMap: {
                vertexPosition: 0 /* POSITION */,
                vertexUv: 4 /* UV */
            }
        });
    }
    destroy() {
        this._program.destroy();
    }
    render(target, sourceColorBuffer) {
        const context = this._context;
        context.bindRenderTarget(target);
        context.bindProgram(this._program);
        context.bindRenderState(POSTPROCESSING_STATE);
        context.bindTextureUnit(0);
        switch (this._type) {
            case PostprocessType.COPY:
                context.bindTexture(sourceColorBuffer);
                this._program.setIntScalarUniform('texture', 0);
                break;
            case PostprocessType.BACKGROUND:
                this._program.setScalarUniform('dpr', window.devicePixelRatio);
                break;
        }
        context.bindQuadVao();
        context.drawQuad();
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = PostprocessRenderer;



/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#ifdef GL_EXT_draw_buffers\n#   extension GL_EXT_draw_buffers : enable\n#endif\n\n#ifndef YV_LEAST_16b_P\n#   ifdef GL_FRAGMENT_PRECISION_HIGH\n#       define YV_LEAST_16b_P highp\n#   else\n#       define YV_LEAST_16b_P mediump\n#   endif\n#endif\n\n#ifdef YV_TEXTURE_FILL\n    varying YV_LEAST_16b_P vec2 uv;\n    uniform lowp sampler2D texture;\n#else\n    varying lowp vec4 color;\n#endif\n\n#ifdef YV_OPACITY\n    uniform mediump float opacity;\n#endif\n\nlowp vec4 yvPremultiplyAlpha(const in lowp vec4 color) {\n    return vec4(color.rgb * color.a, color.a);\n}\n\n#ifdef YV_BACKGROUND\nuniform mediump float dpr;\nlowp vec3 pattern(in mediump vec2 coord) {\n    mediump vec2 uv = mod(coord, 16.) - 8.;\n\n    return mix(vec3(233./255.), vec3(250./255.), smoothstep(0.5, 1.5, length(uv)));\n}\n#endif\n\nvoid main(void) {\n#ifdef YV_BACKGROUND\n    gl_FragColor = vec4(pattern(gl_FragCoord.xy / dpr), 1.0);\n#else\n\n#   ifdef YV_TEXTURE_FILL\n    lowp vec4 color = texture2D(texture, uv);\n#   endif\n\n#   if defined(GL_EXT_draw_buffers) && defined(YV_OIT)\n    gl_FragData[0] = yvPremultiplyAlpha(color);\n    gl_FragData[1].r = color.a;\n#   elif defined(YV_OIT_ALPHA_PASS)\n    gl_FragColor.r = color.a;\n#   else\n    gl_FragColor = yvPremultiplyAlpha(color);\n#   endif\n\n#   ifdef YV_OPACITY\n    gl_FragColor *= opacity;\n#   endif\n#endif\n}\n"

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polyline_vert__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polyline_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_polyline_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_polyline_frag__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_polyline_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_polyline_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__base_polyline_renderer__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__memory_count_vertices__ = __webpack_require__(3);





/**
 * Renderer of polyline primitives. Its default render state is aimed to render opaque polylines.
 */
class PolylineRenderer extends __WEBPACK_IMPORTED_MODULE_3__base_polyline_renderer__["a" /* default */] {
    constructor(context, renderState = new __WEBPACK_IMPORTED_MODULE_0__state__["b" /* default */](PolylineRenderer.DEFAULT_RENDER_STATE_PARAMS)) {
        super(context, renderState, context.createProgram(__WEBPACK_IMPORTED_MODULE_1__shader_polyline_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shader_polyline_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexColor: 7 /* COLOR */,
                vertexZIndex: 9 /* PRIORITY */,
                vertexWidth: 11 /* AUX */
            }
        }));
    }
    _renderPrimitives(primitives) {
        for (const memoryBatch of this.batchPrimitives(primitives)) {
            this._context.bindVao(memoryBatch.page.vao);
            this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(__WEBPACK_IMPORTED_MODULE_4__memory_count_vertices__["a" /* countIndices */])(memoryBatch.indexByteLength, memoryBatch.page.indexType));
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PolylineRenderer;

PolylineRenderer.DEFAULT_RENDER_STATE_PARAMS = {
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
};


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_renderer__ = __webpack_require__(5);

/**
 * Base renderer of polyline primitives.
 */
class BasePolylineRenderer extends __WEBPACK_IMPORTED_MODULE_0__primitive_renderer__["a" /* default */] {
    _bindProgram(program, uniforms) {
        super._bindProgram(program, uniforms);
        program.setScalarUniform('worldToPxFactor', uniforms.worldToPxFactor);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BasePolylineRenderer;



/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polygon_vert__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polygon_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_polygon_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_polygon_frag__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_polygon_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_polygon_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__primitive_renderer__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__memory_count_vertices__ = __webpack_require__(3);





/**
 * Renderer of polygon primitives.
 */
class PolygonRenderer extends __WEBPACK_IMPORTED_MODULE_3__primitive_renderer__["a" /* default */] {
    constructor(context, renderState = new __WEBPACK_IMPORTED_MODULE_0__state__["b" /* default */](PolygonRenderer.DEFAULT_RENDER_STATE_PARAMS)) {
        super(context, renderState, context.createProgram(__WEBPACK_IMPORTED_MODULE_1__shader_polygon_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shader_polygon_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexColor: 7 /* COLOR */,
                vertexZIndex: 10 /* Z_INDEX */
            }
        }));
    }
    _renderPrimitives(primitives) {
        for (const memoryBatch of this.batchPrimitives(primitives)) {
            this._context.bindVao(memoryBatch.page.vao);
            this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(__WEBPACK_IMPORTED_MODULE_4__memory_count_vertices__["a" /* countIndices */])(memoryBatch.indexByteLength, memoryBatch.page.indexType));
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PolygonRenderer;

PolygonRenderer.DEFAULT_RENDER_STATE_PARAMS = {
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
};


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__font__ = __webpack_require__(108);

const UNKNOWN_GLYPH = {
    id: -1,
    width: 0,
    height: 0,
    bearingX: 0,
    bearingY: 0,
    advance: 18
};
/**
 * Font whose glyphs are specified in distance field bitmaps. It's "margin" metric specifies glyph bitmap inner padding,
 * that is required to fit a "blurred" glyph image. This margin should be considered during layouting to draw glyphs of
 * proper sizes.
 */
class DfFont extends __WEBPACK_IMPORTED_MODULE_0__font__["a" /* default */] {
    constructor(id, xheight, margin) {
        super(id, xheight, UNKNOWN_GLYPH);
        this.margin = margin;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DfFont;



/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getTileIdByRawValues */
/* harmony export (immutable) */ __webpack_exports__["a"] = getTileId;
function getTileIdByRawValues(x, y, zoom) {
    return `${x}:${y}:${zoom}`;
}
function getTileId(tile) {
    return getTileIdByRawValues(tile.x, tile.y, tile.zoom);
}


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__count_vertices__ = __webpack_require__(3);

/**
 * Represents a region in a memory chunk. Memory is allocated by big chunks for performance reasons,
 * and we need a mechanism to control those chunk's suballocation to properly free
 * the occupied memory - that is what this class is for.
 */
class MemorySubChunk {
    constructor(chunk, location) {
        this.memoryChunk = chunk;
        this._location = location;
        chunk.retain();
    }
    /**
     * @returns Offset of vertex data of the chunk in bytes.
     */
    get vertexByteOffset() {
        return this.memoryChunk.vertexByteOffset + this._location.vertexByteOffset;
    }
    /**
     * @returns Offset of index data of the chunk in bytes.
     */
    get indexByteOffset() {
        return this.memoryChunk.indexByteOffset + this._location.indexByteOffset;
    }
    /**
     * @returns Number of indexes occupied by this chunk.
     */
    get indexCount() {
        return Object(__WEBPACK_IMPORTED_MODULE_0__count_vertices__["a" /* countIndices */])(this._location.indexByteLength, this.memoryChunk.page.indexType);
    }
    /**
     * @returns Number of bytes occupied by this chunk for vertex data.
     */
    get vertexByteLength() {
        return this._location.vertexByteLength;
    }
    /**
     * @returns Number of bytes occupied by this chunk for index data.
     */
    get indexByteLength() {
        return this._location.indexByteLength;
    }
    destroy() {
        this.memoryChunk.release();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MemorySubChunk;



/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(8);

class RenderablePolyline extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    constructor(memorySubChunk, isOpaque) {
        super(memorySubChunk);
        this.isOpaque = isOpaque;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderablePolyline;



/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__primitive_model_renderable_model__ = __webpack_require__(132);


/**
 * Extruded polygon that can have an association external 3D object. If it has one it hides itself once the object
 * is ready to be displayed.
 * See PolygonObjects from tile.proto.
 */
class ApiModel extends __WEBPACK_IMPORTED_MODULE_0__primitive__["a" /* default */] {
    constructor(styles, memorySubChunk) {
        super(styles);
        this.renderableModel = new __WEBPACK_IMPORTED_MODULE_1__primitive_model_renderable_model__["a" /* default */](memorySubChunk);
    }
    destroy() {
        this.renderableModel.destroy();
        super.destroy();
    }
    /**
     * Updates mesh's visibility.
     */
    onVisibilityChanged(_isVisible) {
        // TODO
    }
    /**
     * Updates mesh's style.
     */
    onStyleChanged(_style) {
        // TODO
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = ApiModel;

/**
 * External 3D object can be shared among multiple polygons (that span different tiles). Moreover, polygons on
 * different zoom generally represent the same 3D object. But the object should be requested, parsed and added to
 * the map only once, and removed when no one need it.
 */
class ApiPolygonMesh extends __WEBPACK_IMPORTED_MODULE_0__primitive__["a" /* default */] {
    constructor(externalMesh, styles) {
        super([]);
        this.externalMesh = externalMesh;
        this.styles = styles;
    }
    onVisibilityChanged(_isVisible) {
        // do nothing, it is stub
    }
    onStyleChanged(_style) {
        // do nothing, it is stub
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ApiPolygonMesh;



/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(10);


/**
 * Base class for 3D models buffer writers. It is not supposed to write indices, instead it writes vertices (possibly
 * duplicated) in order that correspond to triangular facets of the mesh.
 */
class ModelBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(ModelBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Writes a vertex to the vertex buffer.
     */
    _writeVertex(v, colorRgba8) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(v);
        this._writeFloat32(v.z);
        this._writeWord(colorRgba8);
        return vertexIdx;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ModelBufferWriter;

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
ModelBufferWriter.ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        3 /* HEIGHT */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ]
]);


/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(2);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const TEXTURED_POLYGON_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        4 /* UV */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = TEXTURED_POLYGON_ATTRIBUTE_MAPPING;



/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(2);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const POLYGON_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = POLYGON_ATTRIBUTE_MAPPING;



/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(2);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const POLYLINE_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = POLYLINE_ATTRIBUTE_MAPPING;



/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TileProviderMessageType; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__ = __webpack_require__(148);

var TileProviderMessageType;
(function (TileProviderMessageType) {
    TileProviderMessageType[TileProviderMessageType["INIT"] = 0] = "INIT";
    TileProviderMessageType[TileProviderMessageType["TILE_REQUEST"] = 1] = "TILE_REQUEST";
    TileProviderMessageType[TileProviderMessageType["TILE_REQUEST_CANCEL"] = 2] = "TILE_REQUEST_CANCEL";
    TileProviderMessageType[TileProviderMessageType["TILE_RESPONSE"] = 3] = "TILE_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["GEOMETRY_RESPONSE"] = 4] = "GEOMETRY_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["LABELS_RESPONSE"] = 5] = "LABELS_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["MESH_REQUEST"] = 6] = "MESH_REQUEST";
    TileProviderMessageType[TileProviderMessageType["MESH_REQUEST_CANCEL"] = 7] = "MESH_REQUEST_CANCEL";
    TileProviderMessageType[TileProviderMessageType["MESH_RESPONSE"] = 8] = "MESH_RESPONSE";
})(TileProviderMessageType || (TileProviderMessageType = {}));
const geometryTransferableExtractor = function (message, transferables = []) {
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.polygonPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.transparentPolygonPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.texturedPolygonPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.meshPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.polylinePages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.transparentPolylinePages, transferables);
    return transferables;
};
/* unused harmony export geometryTransferableExtractor */

const meshTransferableExtractor = function (message) {
    const transferables = [];
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.pages, transferables);
    return transferables;
};
/* unused harmony export meshTransferableExtractor */

const labelTransferableExtractor = function (message, transferables = []) {
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.pointLabelPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.pointLabelBackgroundPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.curvedLabelPages, transferables);
    return transferables;
};
/* unused harmony export labelTransferableExtractor */

const tileTransferableExtractor = function (message) {
    const transferables = [];
    geometryTransferableExtractor(message, transferables);
    labelTransferableExtractor(message, transferables);
    return transferables;
};
/* unused harmony export tileTransferableExtractor */



/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__camera_camera__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__render_context__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__engine__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_event_emitter__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__adapters_vector_api_adapter__ = __webpack_require__(112);





ymaps.modules.define('vectorEngine.implementation', [
    'vectorEngine.tileWorkerImpl',
    'pane.StaticPane',
    'util.scheduler.manager'
], (provide, tileWorkerUrl, StaticPane, shedulerManager) => {
    /**
     * Initialize vector engine for a map.
     *
     * @param map The map.
     * @param pane A pane for the engine to put its canvas to.
     * @returns Engine instance or `null` if creation failed for some reason.
     */
    provide(function initVectorForMap(map, config) {
        const camera = new __WEBPACK_IMPORTED_MODULE_0__camera_camera__["a" /* default */]({
            wrapModeX: 2 /* REPEAT */,
            wrapModeY: 0 /* NONE */
        });
        const pane = new StaticPane(map, {
            css: {
                width: '100%',
                height: '100%'
            },
            zIndex: 90
        });
        map.panes.append('vector', pane);
        const engine = new __WEBPACK_IMPORTED_MODULE_2__engine__["a" /* default */](__WEBPACK_IMPORTED_MODULE_1__render_context__["a" /* default */].createFromCanvas(createCanvas(pane), CONTEXT_ATTRIBS), camera);
        syncMapStateToCamera(camera, map);
        syncMapSize(engine, map);
        return new Mediator(engine, new __WEBPACK_IMPORTED_MODULE_4__adapters_vector_api_adapter__["a" /* default */](engine, camera, tileWorkerUrl, getVectorApiUrls(config)), pane, shedulerManager);
    });
});
class Mediator {
    constructor(engine, adapter, pane, schedulerManager) {
        this._engine = engine;
        this._adapter = adapter;
        this._pane = pane;
        this._mapEventGroup = pane.getMap().events.group();
        this._schedulerProcess = null;
        this._schedulerManager = schedulerManager;
        this._isVisible = false;
        this.showPaneAndResumeStateSync();
        this.onInternalError = new __WEBPACK_IMPORTED_MODULE_3__util_event_emitter__["b" /* VoidEventEmitter */]();
        engine.onInternalError.addListener(() => this.onInternalError.fire());
        this.onTileRenderChange = new __WEBPACK_IMPORTED_MODULE_3__util_event_emitter__["a" /* EventEmitter */]();
        this._setupTileRenderEvents();
    }
    destroy() {
        this._removeTileRenderEvents();
        this.hidePaneAndStopStateSync();
        this._pane.getMap().panes.remove(this._pane);
        this._pane.destroy();
        this._adapter.destroy();
        this._engine.destroy();
    }
    hidePaneAndStopStateSync() {
        if (!this._isVisible) {
            return;
        }
        this._pane.getElement().style.display = 'none';
        this._mapEventGroup.removeAll();
        this._isVisible = false;
    }
    showPaneAndResumeStateSync() {
        if (this._isVisible) {
            return;
        }
        const pane = this._pane;
        pane.getElement().style.display = 'block';
        const engine = this._engine;
        const camera = engine.getCamera();
        const map = pane.getMap();
        syncMapStateToCamera(camera, map);
        syncMapSize(engine, map);
        engine.renderLoop.update();
        this._mapEventGroup
            .add('actionbegin', () => {
            syncMapStateToCamera(camera, map);
            engine.renderLoop.start();
        })
            .add('actiontick', (e) => this._processTick(e.get('tick')))
            .add('actionend', () => engine.renderLoop.stop())
            .add('sizechange', () => {
            syncMapSize(engine, map);
            engine.renderLoop.update();
        });
        this._isVisible = true;
    }
    _setupTileRenderEvents() {
        this._tileLoadChangeListener = (tileLoadData) => this._onTileLoadChange(tileLoadData);
        this._renderEventListener = () => this._onRenderEvent();
        this._adapter.onTileLoadChange.addListener(this._tileLoadChangeListener);
        this._engine.getRenderer().onRender.addListener(this._renderEventListener);
    }
    _removeTileRenderEvents() {
        this._adapter.onTileLoadChange.removeListener(this._tileLoadChangeListener);
        this._engine.getRenderer().onRender.removeListener(this._renderEventListener);
    }
    _onTileLoadChange(tileLoadData) {
        this._lastTileLoadData = tileLoadData;
    }
    _onRenderEvent() {
        if (this._lastTileLoadData) {
            this.onTileRenderChange.fire({
                totalTileNumber: this._lastTileLoadData.totalTileNumber,
                renderedTileNumber: this._lastTileLoadData.readyTileNumber
            });
            this._lastTileLoadData = null;
        }
    }
    _processTick(tick) {
        const camera = this._engine.getCamera();
        this._stopScheduler();
        if (!tick.duration) {
            syncTickStateToCamera(camera, tick);
        }
        else {
            const map = this._pane.getMap();
            this._schedulerProcess = this._schedulerManager.schedule('processing', function () {
                syncTickStateToCamera(camera, map.action.getCurrentState());
            }, this, {
                duration: tick.duration
            });
        }
    }
    _stopScheduler() {
        if (this._schedulerProcess) {
            this._schedulerProcess.stop();
            this._schedulerProcess = null;
        }
    }
}
const CONTEXT_ATTRIBS = {
    depth: false,
    stencil: false,
    antialias: false,
    failIfMajorPerformanceCaveat: true
};
function convertPixelCenterToCameraCenter(pixelCenter, zoom, cameraCenter) {
    const worldHalfSize = 256 * Math.pow(2, zoom) / 2;
    cameraCenter.x = pixelCenter[0] / worldHalfSize - 1;
    cameraCenter.y = 1 - pixelCenter[1] / worldHalfSize;
}
function syncMapStateToCamera(camera, map) {
    const zoom = camera.zoom = map.getZoom();
    const pixelCenter = map.options.get('projection').toGlobalPixels(map.getCenter(), zoom);
    convertPixelCenterToCameraCenter(pixelCenter, zoom, camera.center);
}
function syncTickStateToCamera(camera, { globalPixelCenter, zoom }) {
    camera.zoom = zoom;
    convertPixelCenterToCameraCenter(globalPixelCenter, zoom, camera.center);
}
function syncMapSize(engine, map) {
    const [width, height] = map.container.getSize();
    const dpr = window.devicePixelRatio;
    const { screenSize } = engine.getCamera();
    screenSize.width = width;
    screenSize.height = height;
    engine.getRenderer().setRenderTargetSize(width * dpr, height * dpr);
}
function createCanvas(pane) {
    const canvas = document.createElement('canvas');
    canvas.style.width = canvas.style.height = '100%';
    pane.getElement().appendChild(canvas);
    const [width, height] = pane.getMap().container.getSize();
    const dpr = window.devicePixelRatio;
    canvas.width = dpr * width;
    canvas.height = dpr * height;
    return canvas;
}
function getVectorApiUrls(config) {
    return {
        imageUrlTemplate: config.vectorImageUrl,
        tileUrlTemplate: config.vectorTileUrl,
        meshUrlTemplate: config.vectorMeshUrl,
        glyphRangeUrlTemplate: config.vectorGlyphsUrl
    };
}


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_scalar__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_rad_deg__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_options__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_matrix4__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_vector3__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util_event_emitter__ = __webpack_require__(4);








// TODO(dmikis) We want to constraint coordinates so visible region doesn't extend
//      out of world boundaries. However, in current implementation it doesn't
//      work properly for aspect ratios >1 on zoom 0 since visible region is
//      larger that the world itself (so there's no way to squeeze it in). For
//      the current case (i.e. cycled in horizontal direction) it is not a problem.
const MAX_TILT = Object(__WEBPACK_IMPORTED_MODULE_1__util_rad_deg__["a" /* deg2rad */])(40);
/**
 * If a camera has zoom less than of equal to `NO_TILT_MAX_ZOOM`, tilt won't be
 * allowed.
 */
const NO_TILT_MAX_ZOOM = 1;
/**
 * If a camera has zoom greater than of equal to `FULL_TILT_MIN_ZOOM`, tilt will
 * be allowed up to `MAX_TILT`.
 */
const FULL_TILT_MIN_ZOOM = NO_TILT_MAX_ZOOM + 1;
const FRUSTUM_DIRECTIONS = [
    // tslint:disable
    __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](-1, 1, -1),
    __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](1, 1, -1),
    __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](1, -1, -1),
    __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](-1, -1, -1)
    // tslint:enable
];
/**
 * How big the world sould be on a screen if zoom is 0, in device independent pixels
 */
const ZOOM_0_WORLD_CSS_PIXEL_SIZE = 256;
const DEFAULT_OPTIONS = {
    wrapModeX: 1 /* CLAMP_TO_EDGE */,
    wrapModeY: 1 /* CLAMP_TO_EDGE */,
    minZoom: 0,
    maxZoom: 24,
    fov: Object(__WEBPACK_IMPORTED_MODULE_1__util_rad_deg__["a" /* deg2rad */])(30)
};
/**
 * Restricts a new value for a center's coordinate according to given wrap mode.
 *
 * @param wrapMode The wrap mode.
 * @param newCoordinate The new value.
 * @param oldCoordinate Current value of the coordinate.
 * @param bboxMin Minimum corresponding coordinate of bounding box of the
 *      visible quadrilateral.
 * @param bboxMax Maximum corresponding coordinate of bounding box of the
 *      visible quadrilateral.
 * @returns Restricted value for the coordinate.
 */
function restrictCoordinate(wrapMode, newCoordinate) {
    switch (wrapMode) {
        case 0 /* NONE */:
            return newCoordinate;
        case 1 /* CLAMP_TO_EDGE */:
            return Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(newCoordinate, -1, 1);
        case 2 /* REPEAT */:
            return Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["b" /* cycleRestrict */])(newCoordinate, -1, 1);
    }
}
/**
 * Camera represents user's point of view in the world space, as a real camera it has restricted field of view,
 * it can move and rotate (with or without animation).
 */
class Camera {
    /**
     * Creates a new camera.
     *
     * @param options Options.
     */
    constructor(options) {
        this.options = Object(__WEBPACK_IMPORTED_MODULE_2__util_options__["a" /* default */])(DEFAULT_OPTIONS, options);
        this.center = new Camera.Center(this);
        this.onUpdate = new __WEBPACK_IMPORTED_MODULE_6__util_event_emitter__["b" /* VoidEventEmitter */]();
        this.screenSize = new Camera.ScreenSize(this);
        this._distanceToCenter = 1;
        this._zoom = this.options.minZoom;
        this._tilt = this._azimuth = 0;
        this._dirtyBits = -1 /* ALL */;
        this._viewProjMatrix = __WEBPACK_IMPORTED_MODULE_3__math_matrix4__["c" /* copy */](__WEBPACK_IMPORTED_MODULE_3__math_matrix4__["a" /* IDENTITY */]);
        this._visibleQuadrilateral = [
            __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0),
            __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0),
            __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0),
            __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0)
        ];
        this._visibleQuadrilateralBBox =
            __WEBPACK_IMPORTED_MODULE_4__math_vector2__["c" /* computeBBoxForPoints */](this._visibleQuadrilateral);
    }
    get aspectRatio() {
        const { width, height } = this.screenSize;
        return width / height;
    }
    get zoom() {
        return this._zoom;
    }
    /**
     * Sets new zoom to the camera with respect to provided limits in the options.
     */
    set zoom(newZoom) {
        newZoom = Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(newZoom, this.options.minZoom, this.options.maxZoom);
        if (newZoom !== this._zoom) {
            this._zoom = newZoom;
            this._computeDistanceToCenter();
            // Constraints on tilt may have changed, we need to recompute it.
            this._tilt = this._constrainTilt(this._tilt);
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    get tilt() {
        return this._tilt;
    }
    set tilt(newTilt) {
        newTilt = this._constrainTilt(newTilt);
        if (this._tilt !== newTilt) {
            this._tilt = newTilt;
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    get azimuth() {
        return this._azimuth;
    }
    set azimuth(newAzimuth) {
        newAzimuth = Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["b" /* cycleRestrict */])(newAzimuth, 0, 2 * Math.PI);
        if (this._azimuth !== newAzimuth) {
            this._azimuth = newAzimuth;
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    /**
     * Invalidate all internally cached values (e.g. view matrix).
     */
    setDirty() {
        this._setDirtyBits(-1 /* ALL */);
    }
    /**
     * Recomputes (if needed) the view projection matrix.
     *
     * @returns The view-projection matrix.
     */
    getViewProjMatrix() {
        const viewProjMatrix = this._viewProjMatrix;
        if (this._dirtyBits & 1 /* VIEW_PROJ_MATRIX */) {
            __WEBPACK_IMPORTED_MODULE_3__math_matrix4__["c" /* copy */](__WEBPACK_IMPORTED_MODULE_3__math_matrix4__["a" /* IDENTITY */], viewProjMatrix);
            __WEBPACK_IMPORTED_MODULE_3__math_matrix4__["e" /* lookAt */](viewProjMatrix, this._computeCenterToCameraVector(), __WEBPACK_IMPORTED_MODULE_5__math_vector3__["a" /* ORIGIN */], __WEBPACK_IMPORTED_MODULE_5__math_vector3__["m" /* rotateZ */](__WEBPACK_IMPORTED_MODULE_5__math_vector3__["b" /* POSITIVE_Y */], this._azimuth), viewProjMatrix);
            const { fov } = this.options;
            const tanFactors = Math.tan(this._tilt) * Math.tan(0.5 * fov);
            __WEBPACK_IMPORTED_MODULE_3__math_matrix4__["f" /* perspective */](viewProjMatrix, fov, this.aspectRatio, Math.min(this._distanceToCenter * 0.01, this._distanceToCenter / (1 + tanFactors)), this._distanceToCenter / (1 - tanFactors), viewProjMatrix);
            this._dirtyBits &= ~1 /* VIEW_PROJ_MATRIX */;
        }
        return viewProjMatrix;
    }
    /**
     * Recomputes (if needed) and returns quadrilateral cut on the world plane
     * by frustum of the camera.
     *
     * @return The quadrilateral enclosing visible part of the world plane.
     */
    getVisibleRegion() {
        this._computeVisibleQuadrilateral();
        return this._visibleQuadrilateral;
    }
    /**
     * Recomputes (if needed) and returns bounding box of the visible region.
     *
     * @return Bounding box of the visible quadrilateral.
     */
    getVisibleRegionBBox() {
        this._computeVisibleQuadrilateral();
        return this._visibleQuadrilateralBBox;
    }
    _constrainTilt(tilt) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(tilt, 0, MAX_TILT * Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["c" /* smoothStep */])(NO_TILT_MAX_ZOOM, FULL_TILT_MIN_ZOOM, this._zoom));
    }
    _setDirtyBits(bits) {
        if (bits ^ (bits & this._dirtyBits)) {
            this._dirtyBits |= bits;
            this.onUpdate.fire();
        }
    }
    _computeDistanceToCenter() {
        this._distanceToCenter =
            this.screenSize.height * Math.pow(2, -this._zoom) /
                (Math.tan(0.5 * this.options.fov) * ZOOM_0_WORLD_CSS_PIXEL_SIZE);
    }
    _computeCenterToCameraVector(dst = __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0)) {
        __WEBPACK_IMPORTED_MODULE_5__math_vector3__["i" /* muln */](__WEBPACK_IMPORTED_MODULE_5__math_vector3__["c" /* POSITIVE_Z */], this._distanceToCenter, dst);
        __WEBPACK_IMPORTED_MODULE_5__math_vector3__["l" /* rotateX */](dst, this._tilt, dst);
        __WEBPACK_IMPORTED_MODULE_5__math_vector3__["m" /* rotateZ */](dst, this._azimuth, dst);
        return dst;
    }
    _computeVisibleQuadrilateral() {
        if (this._dirtyBits & 2 /* VISIBLE_QUADRILATERAL */) {
            const visibleQuadrilateral = this._visibleQuadrilateral;
            const halfFovTan = Math.tan(0.5 * this.options.fov);
            const origin = this._computeCenterToCameraVector();
            __WEBPACK_IMPORTED_MODULE_4__math_vector2__["b" /* add */](origin, this.center, origin);
            const scale = __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](halfFovTan * this.aspectRatio, halfFovTan, 1);
            const direction = __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0);
            const ray = { origin, direction };
            for (let i = 0; i < 4; ++i) {
                __WEBPACK_IMPORTED_MODULE_5__math_vector3__["j" /* mulv */](FRUSTUM_DIRECTIONS[i], scale, direction);
                __WEBPACK_IMPORTED_MODULE_5__math_vector3__["l" /* rotateX */](direction, this._tilt, direction);
                __WEBPACK_IMPORTED_MODULE_5__math_vector3__["m" /* rotateZ */](direction, this._azimuth, direction);
                if (!__WEBPACK_IMPORTED_MODULE_5__math_vector3__["h" /* getPlaneRayIntersection */](__WEBPACK_IMPORTED_MODULE_5__math_vector3__["d" /* XY */], ray, visibleQuadrilateral[i])) {
                    throw new Error('Visible quadrilateral is unbounded, engine can\'t handle that case (yet)');
                }
            }
            __WEBPACK_IMPORTED_MODULE_4__math_vector2__["c" /* computeBBoxForPoints */](visibleQuadrilateral, this._visibleQuadrilateralBBox);
            this._dirtyBits &= ~2 /* VISIBLE_QUADRILATERAL */;
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Camera;

/**
 * Implementation of a center vector of a camera. Takes into account wrapping
 * modes and updates camera's dirty flags.
 */
Camera.Center = class {
    /**
     * Creates new center vector for a camera.
     *
     * @param camera The camera.
     */
    constructor(camera) {
        this._camera = camera;
        this._x = this._y = 0;
    }
    /**
     * @returns Values of abscissa of the center vector.
     */
    get x() {
        return this._x;
    }
    /**
     * Properly clamps or wraps new abscissa value and sets it to the vector.
     *
     * @param newX The new
     */
    set x(newX) {
        const camera = this._camera;
        newX = restrictCoordinate(camera.options.wrapModeX, newX);
        if (this._x !== newX) {
            this._x = newX;
            camera._setDirtyBits(2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    /**
     * @returns Values of ordinate of the center vector.
     */
    get y() {
        return this._y;
    }
    /**
     * Properly clamps or wraps new ordinate value and sets it to the vector.
     */
    set y(newY) {
        const camera = this._camera;
        newY = restrictCoordinate(camera.options.wrapModeY, newY);
        if (this._y !== newY) {
            this._y = newY;
            camera._setDirtyBits(2 /* VISIBLE_QUADRILATERAL */);
        }
    }
};
Camera.ScreenSize = class {
    constructor(camera) {
        this._camera = camera;
        this._width = this._height = 1;
    }
    get width() {
        return this._width;
    }
    set width(newWidth) {
        if (this._width !== newWidth) {
            this._width = newWidth;
            const camera = this._camera;
            camera._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    get height() {
        return this._height;
    }
    set height(newHeight) {
        if (this._height !== newHeight) {
            this._height = newHeight;
            const camera = this._camera;
            camera._computeDistanceToCenter();
            camera._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
};


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = deg2rad;
/* unused harmony export rad2deg */
const DEG_TO_RAD = Math.PI / 180;
function deg2rad(x) {
    return x * DEG_TO_RAD;
}
function rad2deg(x) {
    return x / DEG_TO_RAD;
}


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getFullOptions;
/**
 * Resolves options.
 *
 * @param defaultOptions Object with default values.
 * @param options Object with custom values for options. Later objects "override"
 *      former ones.
 * @returns New object containing resolved options.
 */
function getFullOptions(defaultOptions, ...options) {
    return Object.assign({}, defaultOptions, ...options);
}


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export create */
/* unused harmony export zero */
/* harmony export (immutable) */ __webpack_exports__["a"] = fromRows;
/* unused harmony export columns */
/* unused harmony export fromColumns */
/* unused harmony export determinant */
/* harmony export (immutable) */ __webpack_exports__["b"] = solve;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector3__ = __webpack_require__(7);

const MATRIX_SIZE = 9;
/**
 * Creates and returns a new **uninitialized** matrix.
 */
function create() {
    return new Array(MATRIX_SIZE);
}
/**
 * Zeroes a matrix.
 *
 * @param dst The matrix.
 * @returns `dst`.
 */
function zero(dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = 0;
    }
    return dst;
}
/**
 * Copies three vectors to a matrix as rows.
 *
 * @param r0 The first row.
 * @param r1 The second row.
 * @param r2 The third row.
 * @param dst The matrix the rows will be written to.
 * @returns `dst`.
 */
function fromRows(r0, r1, r2, dst = create()) {
    dst[0] = r0.x;
    dst[1] = r1.x;
    dst[2] = r2.x;
    dst[3] = r0.y;
    dst[4] = r1.y;
    dst[5] = r2.y;
    dst[6] = r0.z;
    dst[7] = r1.z;
    dst[8] = r2.z;
    return dst;
}
/**
 * Returns array of columns of a matrix.
 *
 * @param m The matrix.
 * @param dst The array columns of the matrix will be written to.
 * @returns `dst`.
 */
function columns(m, dst = [
    __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0),
    __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0),
    __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0)
]) {
    for (let i = 0, j = 0; i < 3; ++i, j += 3) {
        dst[i].x = m[j];
        dst[i].y = m[j + 1];
        dst[i].z = m[j + 2];
    }
    return dst;
}
/**
 * Copies three vectors to a matrix as columns.
 *
 * @param c0 The first column.
 * @param c1 The second column.
 * @param c2 The third column.
 * @param dst The matrix the columns will be written to.
 * @returns `dst`.
 */
function fromColumns(c0, c1, c2, dst = create()) {
    dst[0] = c0.x;
    dst[1] = c0.y;
    dst[2] = c0.z;
    dst[3] = c1.x;
    dst[4] = c1.y;
    dst[5] = c1.z;
    dst[6] = c2.x;
    dst[7] = c2.y;
    dst[8] = c2.z;
    return dst;
}
/**
 * Computes determinant of a matrix.
 *
 * @param m The matrix.
 * @returns The determinant.
 */
function determinant(m) {
    return m[0] * (m[4] * m[8] - m[7] * m[5]) +
        m[3] * (m[1] * m[8] - m[7] * m[2]) +
        m[6] * (m[1] * m[5] - m[4] * m[2]);
}
const staticMatrixColumns = [
    // Not using vector3.create here due to circular dependency.
    { x: 0, y: 0, z: 0 },
    { x: 0, y: 0, z: 0 },
    { x: 0, y: 0, z: 0 }
];
const staticMatrix = create();
/**
 * Solves a system of linear equations represented with a matrix and a vector,
 * i.e.:
 *
 * ```
 * m * (x, y ,z)^T = v
 * ```
 *
 * Uses Cramer's rule.
 * @see https://en.wikipedia.org/wiki/Cramer's_rule
 *
 * @param m The matrix of the system.
 * @param v The vector of the system.
 * @param dst The vector solution of the system will be written to.
 * @return `dst`.
 */
function solve(m, v, dst = __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0)) {
    const revDet = 1 / determinant(m);
    const [c0, c1, c2] = columns(m, staticMatrixColumns);
    dst.x = revDet * determinant(fromColumns(v, c1, c2, staticMatrix));
    dst.y = revDet * determinant(fromColumns(c0, v, c2, staticMatrix));
    dst.z = revDet * determinant(fromColumns(c0, c1, v, staticMatrix));
    return dst;
}


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__attrib_mapping__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gl_buffer__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_framebuffer__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gl_program__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gl_renderbuffer__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__capabilities__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gl_texture__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__gl_vao__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_color__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__util_event_emitter__ = __webpack_require__(4);











const QUAD_VERTEX_DATA = new Float32Array([
    // tslint:disable
    // x   y  u  v
    -1, -1, 0, 0,
    1, 1, 1, 1,
    -1, 1, 0, 1,
    -1, -1, 0, 0,
    1, -1, 1, 0,
    1, 1, 1, 1
    // tslint:enable
]);
const QUAD_ATTRIB_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/**
 * Default render target of a WebGL context, which is canvas element of the
 * context.
 */
class DefaultRenderTarget {
    constructor(gl) {
        this._gl = gl;
    }
    bind() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    setSize(width, height) {
        const canvas = this._gl.canvas;
        canvas.width = width;
        canvas.height = height;
    }
    getWidth() {
        return this._gl.drawingBufferWidth;
    }
    getHeight() {
        return this._gl.drawingBufferHeight;
    }
    destroy() {
        // We can't destroy default render target, so do nothing.
        // TODO(dmikis) Throw an exception?
    }
}
/**
 * Computes a string key that uniquely identifies a shader program from `Program`
 * constructor parameters.
 *
 * @param vertexShaderSource Source code of vertex shader of the program.
 * @param fragmentShaderSource Source code of fragment shader of the program.
 * @param options Options.
 * @returns The key.
 */
function getProgramKey(vertexShaderSource, fragmentShaderSource, options) {
    // TODO(dmikis) hash and/or compression?
    let key = vertexShaderSource + fragmentShaderSource;
    if (options) {
        if (options.defines) {
            const defines = options.defines;
            key += Object.keys(defines)
                .sort()
                .map((define) => `${define}${defines[define]}`)
                .join('');
        }
        if (options.attribMap) {
            const attribMap = options.attribMap;
            key += Object.keys(options.attribMap)
                .sort()
                .map((attribute) => `${attribute}${attribMap[attribute]}`)
                .join('');
        }
    }
    return key;
}
/**
 * Wrapper around WebGL context. Serves to localize all GL calls to minimum set
 * of objects.
 */
class RenderContext {
    /**
     * Creates a new wrapper for a given WebGL context.
     *
     * @param gl The context to be wrapped.
     */
    constructor(gl) {
        this._gl = gl;
        this.onLoss = new __WEBPACK_IMPORTED_MODULE_10__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._contextLostListener = (e) => {
            e.preventDefault();
            this.onLoss.fire();
        };
        gl.canvas.addEventListener('webglcontextlost', this._contextLostListener);
        this._capabilities = new __WEBPACK_IMPORTED_MODULE_5__capabilities__["a" /* default */](gl);
        const vaoExt = gl.getExtension('OES_vertex_array_object');
        if (!vaoExt) {
            throw new Error('OES_vertex_array_object is required.');
        }
        this._vaoExt = vaoExt;
        if (!gl.getExtension('OES_standard_derivatives')) {
            throw new Error('OES_standard_derivatives is required.');
        }
        this._programCache = new Map();
        const defaultRenderTarget = this._boundRenderTarget =
            this._defaultRenderTarget =
                new DefaultRenderTarget(gl);
        const boundState = this._boundRenderState = new __WEBPACK_IMPORTED_MODULE_6__state__["b" /* default */]();
        // Default viewport and scissor rectangle sizes are equal to the size of
        // the canvas of the WebGL context. But we have no way of knowing them in
        // RenderState's constructor. So we're fixing them here.
        boundState.scissorWidth = boundState.viewportWidth =
            defaultRenderTarget.getWidth();
        boundState.scissorHeight = boundState.viewportHeight =
            defaultRenderTarget.getHeight();
        const quadBuffer = this._quadVertexBuffer =
            new __WEBPACK_IMPORTED_MODULE_1__gl_buffer__["a" /* default */](gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
        quadBuffer.bind();
        gl.bufferData(gl.ARRAY_BUFFER, QUAD_VERTEX_DATA, gl.STATIC_DRAW);
        this._quadVao = this.createVao(QUAD_ATTRIB_MAPPING, quadBuffer, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this._boundProgram = null;
        this._boundVao = null;
        this._boundTextures = new Array(this._capabilities.getMaxCombinedTextureImageUnits());
        this._boundTextures.fill(null);
        this._boundTextureUnit = 0;
    }
    /**
     * Returns object to request capabilities of the context such as maximum
     * texture size or maximum number of uniform vectors allowed in shaders.
     */
    getCapabilities() {
        return this._capabilities;
    }
    /**
     * Creates a new framebuffer with given attachments.
     *
     * @param descriptor Object containing framebuffer attachments.
     * @returns Created framebuffer object.
     */
    createFramebuffer({ color, depth, stencil, depthStencil }) {
        // TODO Uncomment and put under debug flag (when implemented)
        // if (depthStencil && (depth || stencil)) {
        //     throw new Error(
        //         'Framebuffer can\'t have DEPTH_STENCIL and DEPTH or STENCIL ' +
        //             'attachment simultaneously.'
        //     );
        // }
        const gl = this._gl;
        let width = 0;
        let height = 0;
        if (color) {
            width = color.getWidth();
            height = color.getHeight();
        }
        else if (depth) {
            width = depth.getWidth();
            height = depth.getHeight();
        }
        else if (stencil) {
            width = stencil.getWidth();
            height = stencil.getHeight();
        }
        else if (depthStencil) {
            width = depthStencil.getWidth();
            height = depthStencil.getHeight();
        }
        const framebuffer = new __WEBPACK_IMPORTED_MODULE_2__gl_framebuffer__["a" /* default */](gl, width, height);
        framebuffer.bind();
        this._boundRenderTarget = framebuffer;
        if (color) {
            color.attachToFramebuffer(gl.COLOR_ATTACHMENT0);
        }
        if (depth) {
            depth.attachToFramebuffer(gl.DEPTH_ATTACHMENT);
        }
        if (stencil) {
            stencil.attachToFramebuffer(gl.STENCIL_ATTACHMENT);
        }
        if (depthStencil) {
            depthStencil.attachToFramebuffer(gl.DEPTH_STENCIL_ATTACHMENT);
        }
        // TODO Uncomment and put under debug flag (when implemented)
        // switch (gl.checkFramebufferStatus(gl.FRAMEBUFFER)) {
        //     case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        //         throw new Error('Framebuffer attachments are not renderable');
        //     case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        //         throw new Error('Framebuffer attachments are not same size');
        //     case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        //         throw new Error('Framebuffer has no attachments');
        //     case gl.FRAMEBUFFER_UNSUPPORTED:
        //         throw new Error('Framebuffer has unsupported attachment');
        // }
        return framebuffer;
    }
    /**
     * Allocates a new renderbuffer with given size and format.
     *
     * @param width Width of the renderbuffer.
     * @param height Height of the renderbuffer.
     * @param format Format of the renderbuffer.
     * @return The allocated renderbuffer.
     *
     */
    createRenderbuffer(width, height, format) {
        const gl = this._gl;
        const renderbuffer = new __WEBPACK_IMPORTED_MODULE_4__gl_renderbuffer__["a" /* default */](gl, width, height);
        renderbuffer.bind();
        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);
        return renderbuffer;
    }
    /**
     * Allocates a new texture with given size, format, type and parameters and
     * fills it with zeroes.
     *
     * @param width Width of the texture.
     * @param height Height of the texture.
     * @param format Pixel format of the texture.
     * @param type Pixel type of the texture.
     * @param params Parameters of the texture.
     * @returns Newly allocated texture.
     */
    createEmpty2DTexture(width, height, format, type, params = __WEBPACK_IMPORTED_MODULE_7__gl_texture__["a" /* DEFAULT_TEXTURE_PARAMS */]) {
        const texture = new __WEBPACK_IMPORTED_MODULE_7__gl_texture__["b" /* default */](this._gl, width, height, format, type, params);
        this.bindTexture(texture);
        texture.setData(null);
        return texture;
    }
    /**
     * Creates a new shader program. Uses cache, i.e. if a program with same
     * source string and options is already created, returns it.
     *
     * @param vertexShaderSource Source code of vertex shader of the program.
     * @param fragmentShaderSource Source code of fragment shader of the program.
     * @param options Options.
     * @returns Newly created program or one from the cache.
     */
    createProgram(vertexShaderSource, fragmentShaderSource, options) {
        const key = getProgramKey(vertexShaderSource, fragmentShaderSource, options);
        let program = this._programCache.get(key);
        if (!program) {
            program = new __WEBPACK_IMPORTED_MODULE_3__gl_program__["a" /* default */](this._gl, vertexShaderSource, fragmentShaderSource, options);
            this._programCache.set(key, program);
        }
        return program;
    }
    createVertexBuffer(size, usage = 35044 /* STATIC_DRAW */) {
        return this._createBuffer(this._gl.ARRAY_BUFFER, size, usage);
    }
    createIndexBuffer(size, usage = 35044 /* STATIC_DRAW */) {
        return this._createBuffer(this._gl.ELEMENT_ARRAY_BUFFER, size, usage);
    }
    // TODO: check https://github.com/Microsoft/TypeScript/issues/24195 to update narrowed data type according
    uploadDataToBuffer(buffer, data, offset = 0) {
        buffer.bind();
        this._gl.bufferSubData(buffer.getTarget(), offset, data);
    }
    /**
     * Creates a new vertex array object in the context.
     *
     * @param attributeMapping Mapping of vertex attrbiutes for the VAO.
     * @param vertexBuffer Vertex buffer to be bound to the VAO.
     * @param indexBuffer Index buffer to be bound to the VAO.
     * @returns The new VAO.
     */
    createVao(attributeMapping, vertexBuffer, indexBuffer) {
        const gl = this._gl;
        const vao = new __WEBPACK_IMPORTED_MODULE_8__gl_vao__["a" /* default */](gl, this._vaoExt, attributeMapping);
        vao.bind();
        if (indexBuffer) {
            indexBuffer.bind();
        }
        else {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
        vertexBuffer.bind();
        const vertexByteSize = attributeMapping.vertexByteSize;
        for (const [idx, pointer] of attributeMapping) {
            gl.enableVertexAttribArray(idx);
            gl.vertexAttribPointer(idx, pointer.size, pointer.type, pointer.normalized, vertexByteSize, pointer.offset);
        }
        this._vaoExt.bindVertexArrayOES(null);
        return vao;
    }
    /**
     * Returns default render target associated with canvas on which the WebGL
     * context operates.
     */
    getDefaultRenderTarget() {
        return this._defaultRenderTarget;
    }
    /**
     * Clears currently bound render target according to a mask.
     *
     * @param mask Bitwise OR of marks, i.e.
     *      `ClearMask.COLOR_BUFFER_BIT | ClearMask.DEPTH_BUFFER_BIT`.
     */
    clearCurrentTarget(mask) {
        if (mask) {
            this._gl.clear(mask);
        }
    }
    /**
     * Binds a render target to the WebGL context if it's not already bound.
     *
     * @param target The render target to be bound.
     */
    bindRenderTarget(target) {
        if (this._boundRenderTarget != target) {
            target.bind();
            this._boundRenderTarget = target;
            this._setViewportState(new __WEBPACK_IMPORTED_MODULE_6__state__["b" /* default */]({
                viewportWidth: target.getWidth(),
                viewportHeight: target.getHeight()
            }));
        }
    }
    /**
     * Binds a render state to the WebGL context with minimum amount of actual
     * state switching.
     *
     * @param state The state to be bound.
     */
    bindRenderState(state) {
        this._setColorBufferState(state);
        this._setBlendState(state);
        this._setCullFaceState(state);
        this._setFrontFaceState(state);
        this._setDepthTestState(state);
        this._setDitherState(state);
        this._setDrawBuffersState(state);
        this._setPolygonOffsetState(state);
        this._setAlphaToCoverageState(state);
        this._setSampleCoverageState(state);
        this._setStencilTestState(state);
        this._setScissorTestState(state);
        this._setViewportState(state);
    }
    /**
     * Binds a program to the WebGL context if it's not already bound.
     *
     * @param program The program to be bound.
     */
    bindProgram(program) {
        if (this._boundProgram != program) {
            program.bind();
            this._boundProgram = program;
        }
    }
    /**
     * Binds a vertex array object to the context if it's not already bound.
     *
     * @param vao The vertex array object to bind. Passing `null` will unbind
     *      any currently bound VAO.
     */
    bindVao(vao) {
        if (this._boundVao != vao) {
            if (vao) {
                vao.bind();
            }
            else {
                this._vaoExt.bindVertexArrayOES(null);
            }
            this._boundVao = vao;
        }
    }
    bindQuadVao() {
        this.bindVao(this._quadVao);
    }
    bindTextureUnit(unit) {
        const gl = this._gl;
        if (this._boundTextureUnit !== unit) {
            gl.activeTexture(gl.TEXTURE0 + unit);
            this._boundTextureUnit = unit;
        }
    }
    bindTexture(texture) {
        const boundUnit = this._boundTextureUnit;
        if (this._boundTextures[boundUnit] !== texture) {
            texture.bind();
            this._boundTextures[boundUnit] = texture;
        }
    }
    /**
     * Draws a quad to currently bound render target with currently bound render
     * state, program and uniform state.
     */
    drawQuad() {
        const gl = this._gl;
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
    /**
     * Draws a mesh from currently bound to ARRAY_BUFFER buffer.
     *
     * @param offset Index of the vertex to start drawing from.
     * @param count Number of vertices to process.
     * @param primitiveType
     */
    drawMesh(offset, count, primitiveType = 4 /* TRIANGLES */) {
        this._gl.drawArrays(primitiveType, offset, count);
    }
    /**
     * Draws a mesh to currently bound render target with currently bound render
     * state, program and uniform state.
     *
     * @param offset Offset of indices of the mesh in currently bound memory page.
     * @param indexCount Number of indices in the mesh.
     */
    drawIndexedMesh(offset, indexCount, primitiveType = 4 /* TRIANGLES */) {
        const gl = this._gl;
        gl.drawElements(primitiveType, indexCount, gl.UNSIGNED_SHORT, offset);
    }
    /**
     * Destroys the context and resources owned by it. Note that resources that
     * were created with `create*` method of the context aren't exactly belong
     * to the context, entities that created them have to destroy them.
     */
    destroy() {
        this._vaoExt.deleteVertexArrayOES(this._quadVao);
        this._gl.deleteBuffer(this._quadVertexBuffer);
        this._gl.canvas.removeEventListener('webglcontextlost', this._contextLostListener);
    }
    /**
     * Creates a new context from a canvas.
     *
     * @throws An error if fails to create `webgl` context for the canvas.
     * @param canvas The canvas.
     * @param attribs Attributes of the context.
     */
    static createFromCanvas(canvas, attribs) {
        const gl = canvas.getContext('webgl', attribs);
        if (!gl) {
            throw new Error('Failed to create GL context from canvas.');
        }
        return new RenderContext(gl);
    }
    /**
     * Enables or disables a WebGL capability.
     * @see https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glEnable.xml
     *
     * @param capability The capability to be enabled of disabled.
     * @param enabled New state of the capability;
     */
    _setCapabilityEnabled(capability, enabled) {
        if (enabled) {
            this._gl.enable(capability);
        }
        else {
            this._gl.disable(capability);
        }
    }
    /**
     * Sets new clear color and color mask from a state if they're different from
     * currently set ones.
     *
     * @param state The state that contains new clear color and color masks.
     */
    _setColorBufferState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        const newClearColor = state.clearColor;
        if (!__WEBPACK_IMPORTED_MODULE_9__util_color__["a" /* areEqual */](boundState.clearColor, newClearColor)) {
            gl.clearColor(newClearColor.r, newClearColor.g, newClearColor.b, newClearColor.a);
            __WEBPACK_IMPORTED_MODULE_9__util_color__["b" /* copy */](newClearColor, boundState.clearColor);
        }
        if (boundState.colorMaskR != state.colorMaskR ||
            boundState.colorMaskG != state.colorMaskG ||
            boundState.colorMaskB != state.colorMaskB ||
            boundState.colorMaskAlpha != state.colorMaskAlpha) {
            this._gl.colorMask(state.colorMaskR, state.colorMaskG, state.colorMaskB, state.colorMaskAlpha);
            boundState.colorMaskR = state.colorMaskR;
            boundState.colorMaskG = state.colorMaskG;
            boundState.colorMaskB = state.colorMaskB;
            boundState.colorMaskAlpha = state.colorMaskAlpha;
        }
    }
    /**
     * Sets blend state and params.
     *
     * @param state The state that contains new blend params.
     */
    _setBlendState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.blend != state.blend) {
            this._setCapabilityEnabled(gl.BLEND, state.blend);
            boundState.blend = state.blend;
        }
        if (state.blend) {
            if (boundState.blendEquationRgb != state.blendEquationRgb ||
                boundState.blendEquationAlpha != state.blendEquationAlpha) {
                gl.blendEquationSeparate(state.blendEquationRgb, state.blendEquationAlpha);
                boundState.blendEquationRgb = state.blendEquationRgb;
                boundState.blendEquationAlpha = state.blendEquationAlpha;
            }
            if (boundState.blendFuncDstRgb != state.blendFuncDstRgb ||
                boundState.blendFuncSrcRgb != state.blendFuncSrcRgb ||
                boundState.blendFuncDstAlpha != state.blendFuncDstAlpha ||
                boundState.blendFuncSrcAlpha != state.blendFuncSrcAlpha) {
                gl.blendFuncSeparate(state.blendFuncSrcRgb, state.blendFuncDstRgb, state.blendFuncSrcAlpha, state.blendFuncDstAlpha);
                boundState.blendFuncSrcRgb = state.blendFuncSrcRgb;
                boundState.blendFuncDstRgb = state.blendFuncDstRgb;
                boundState.blendFuncSrcAlpha = state.blendFuncSrcAlpha;
                boundState.blendFuncDstAlpha = state.blendFuncDstAlpha;
            }
        }
    }
    /**
     * Sets cull face state and params.
     *
     * @param state The state that contains new cull face state and mode.
     */
    _setCullFaceState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.cullFace != state.cullFace) {
            this._setCapabilityEnabled(gl.CULL_FACE, state.cullFace);
            boundState.cullFace = state.cullFace;
        }
        if (state.cullFace &&
            boundState.cullFaceMode != state.cullFaceMode) {
            gl.cullFace(state.cullFaceMode);
            boundState.cullFaceMode = state.cullFaceMode;
        }
    }
    /**
     * Sets front face mode.
     *
     * @param state The state that contains new front face mode.
     */
    _setFrontFaceState(state) {
        const boundState = this._boundRenderState;
        if (boundState.frontFaceMode != state.frontFaceMode) {
            this._gl.frontFace(state.frontFaceMode);
            boundState.frontFaceMode = state.frontFaceMode;
        }
    }
    /**
     * Sets depth test state and params.
     *
     * @param state The state that contains new depth test state and params.
     */
    _setDepthTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.depthTest != state.depthTest) {
            this._setCapabilityEnabled(gl.DEPTH_TEST, state.depthTest);
            boundState.depthTest = state.depthTest;
        }
        if (state.depthTest) {
            if (boundState.clearDepth != state.clearDepth) {
                gl.clearDepth(state.clearDepth);
                boundState.clearDepth = state.clearDepth;
            }
            if (boundState.depthMask != state.depthMask) {
                gl.depthMask(state.depthMask);
                boundState.depthMask = state.depthMask;
            }
            if (boundState.depthFunc != state.depthFunc) {
                gl.depthFunc(state.depthFunc);
                boundState.depthFunc = state.depthFunc;
            }
            if (boundState.depthRangeNear != state.depthRangeNear ||
                boundState.depthRangeFar != state.depthRangeFar) {
                gl.depthRange(state.depthRangeNear, state.depthRangeFar);
                boundState.depthRangeNear = state.depthRangeNear;
                boundState.depthRangeFar = state.depthRangeFar;
            }
        }
    }
    /**
     * Sets dither state.
     *
     * @param state The state that contains new dither state.
     */
    _setDitherState(state) {
        const boundState = this._boundRenderState;
        if (boundState.dither != state.dither) {
            this._setCapabilityEnabled(this._gl.DITHER, state.dither);
            boundState.dither = state.dither;
        }
    }
    /**
     * Sets draw buffers.
     *
     * @param state The state that contains array of draw buffers.
     */
    _setDrawBuffersState(state) {
        const boundDrawBuffers = this._boundRenderState.drawBuffers;
        if (boundDrawBuffers.length != state.drawBuffers.length ||
            boundDrawBuffers
                .some((attachment, i) => attachment != state.drawBuffers[i])) {
            this._boundRenderState.drawBuffers = state.drawBuffers.slice();
        }
    }
    /**
     * Sets polygon offset state and params.
     *
     * @param state The state that contains new polygon offset state and params.
     */
    _setPolygonOffsetState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.polygonOffset != state.polygonOffset) {
            this._setCapabilityEnabled(gl.POLYGON_OFFSET_FILL, state.polygonOffset);
            boundState.polygonOffset = state.polygonOffset;
        }
        if (state.polygonOffset &&
            (boundState.polygonOffsetFactor != state.polygonOffsetFactor ||
                boundState.polygonOffsetUnits != state.polygonOffsetUnits)) {
            gl.polygonOffset(state.polygonOffsetFactor, state.polygonOffsetUnits);
            boundState.polygonOffsetFactor = state.polygonOffsetFactor;
            boundState.polygonOffsetUnits = state.polygonOffsetUnits;
        }
    }
    /**
     * Sets alpha-to-coverage state.
     *
     * @param state The state that contains new alpha-to-coverage state.
     */
    _setAlphaToCoverageState(state) {
        const boundState = this._boundRenderState;
        if (boundState.sampleAlphaToCoverage != state.sampleAlphaToCoverage) {
            this._setCapabilityEnabled(this._gl.SAMPLE_ALPHA_TO_COVERAGE, state.sampleAlphaToCoverage);
            boundState.sampleAlphaToCoverage = state.sampleAlphaToCoverage;
        }
    }
    /**
     * Sets sample coverage state.
     *
     * @param state The state that contains new sample coverage state and params.
     */
    _setSampleCoverageState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.sampleCoverage != state.sampleCoverage) {
            this._setCapabilityEnabled(gl.SAMPLE_COVERAGE, state.sampleCoverage);
            boundState.sampleCoverage = state.sampleCoverage;
        }
        if (state.sampleCoverage &&
            (boundState.sampleCoverageValue != state.sampleCoverageValue ||
                boundState.sampleCoverageInvert != state.sampleCoverageInvert)) {
            gl.sampleCoverage(state.sampleCoverageValue, state.sampleCoverageInvert);
            boundState.sampleCoverageValue = state.sampleCoverageValue;
            boundState.sampleCoverageInvert = state.sampleCoverageInvert;
        }
    }
    /**
     * Sets stencil test state and params.
     *
     * @param state The state that contains new stencil test state and params.
     */
    _setStencilTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.stencilTest != state.stencilTest) {
            this._setCapabilityEnabled(gl.STENCIL_TEST, state.stencilTest);
            boundState.stencilTest = state.stencilTest;
        }
        if (state.stencilTest) {
            if (boundState.clearStencil != state.clearStencil) {
                gl.clearStencil(state.clearStencil);
                boundState.clearStencil = state.clearStencil;
            }
            if (boundState.stencilWriteMask != state.stencilWriteMask) {
                gl.stencilMask(state.stencilWriteMask);
                boundState.stencilWriteMask = state.stencilWriteMask;
            }
            const refOrMaskIsDifferent = (boundState.stencilMask != state.stencilMask ||
                boundState.stencilReference != state.stencilReference);
            if (refOrMaskIsDifferent) {
                boundState.stencilMask = state.stencilMask;
                boundState.stencilReference = state.stencilReference;
            }
            if (boundState.stencilFrontFunc != state.stencilFrontFunc ||
                refOrMaskIsDifferent) {
                gl.stencilFuncSeparate(gl.FRONT, state.stencilFrontFunc, state.stencilReference, state.stencilMask);
                boundState.stencilFrontFunc = state.stencilFrontFunc;
            }
            if (boundState.stencilBackFunc != state.stencilBackFunc ||
                refOrMaskIsDifferent) {
                gl.stencilFuncSeparate(gl.BACK, state.stencilBackFunc, state.stencilReference, state.stencilMask);
                boundState.stencilBackFunc = state.stencilBackFunc;
            }
            if (boundState.stencilFrontFailOp != state.stencilFrontFailOp ||
                boundState.stencilFrontDepthFailOp != state.stencilFrontDepthFailOp ||
                boundState.stencilFrontDepthPassOp != state.stencilFrontDepthPassOp) {
                gl.stencilOpSeparate(gl.FRONT, state.stencilFrontFailOp, state.stencilFrontDepthFailOp, state.stencilFrontDepthPassOp);
                boundState.stencilFrontFailOp = state.stencilFrontFailOp;
                boundState.stencilFrontDepthFailOp = state.stencilFrontDepthFailOp;
                boundState.stencilFrontDepthPassOp = state.stencilFrontDepthPassOp;
            }
            if (boundState.stencilBackFailOp != state.stencilBackFailOp ||
                boundState.stencilBackDepthFailOp != state.stencilBackDepthFailOp ||
                boundState.stencilBackDepthPassOp != state.stencilBackDepthPassOp) {
                gl.stencilOpSeparate(gl.BACK, state.stencilBackFailOp, state.stencilBackDepthFailOp, state.stencilBackDepthPassOp);
                boundState.stencilBackFailOp = state.stencilBackFailOp;
                boundState.stencilBackDepthFailOp = state.stencilBackDepthFailOp;
                boundState.stencilBackDepthPassOp = state.stencilBackDepthPassOp;
            }
        }
    }
    /**
     * Sets scissor test state and scissor rectangle.
     *
     * @param state The state that contains new scissor test state and scissor
     *      rectangle.
     */
    _setScissorTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.scissorTest != state.scissorTest) {
            this._setCapabilityEnabled(gl.SCISSOR_TEST, state.scissorTest);
            boundState.scissorTest = state.scissorTest;
        }
        if (state.scissorTest &&
            state.scissorWidth >= 0 &&
            state.scissorHeight >= 0 &&
            (boundState.scissorX != state.scissorX ||
                boundState.scissorY != state.scissorY ||
                boundState.scissorWidth != state.scissorWidth ||
                boundState.scissorHeight != state.scissorHeight)) {
            gl.scissor(state.scissorX, state.scissorY, state.scissorWidth, state.scissorHeight);
            boundState.scissorX = state.scissorX;
            boundState.scissorY = state.scissorY;
            boundState.scissorWidth = state.scissorWidth;
            boundState.scissorHeight = state.scissorHeight;
        }
    }
    /**
     * Sets viewport.
     *
     * @param state The state that contains new viewport.
     */
    _setViewportState(state) {
        const boundState = this._boundRenderState;
        if (state.viewportWidth >= 0 &&
            state.viewportHeight >= 0 &&
            (boundState.viewportX != state.viewportX ||
                boundState.viewportY != state.viewportY ||
                boundState.viewportWidth != state.viewportWidth ||
                boundState.viewportHeight != state.viewportHeight)) {
            this._gl.viewport(state.viewportX, state.viewportY, state.viewportWidth, state.viewportHeight);
            boundState.viewportX = state.viewportX;
            boundState.viewportY = state.viewportY;
            boundState.viewportWidth = state.viewportWidth;
            boundState.viewportHeight = state.viewportHeight;
        }
    }
    /**
     * Creates a new zeroed buffer with a given size and a target.
     *
     * @param target The target of the new buffer, `ARRAY_BUFFER` or
     *      `ELEMENT_ARRAY_BUFFER`.
     * @param size The size of the buffer.
     * @param usage Usage of the buffer.
     * @returns The buffer.
     */
    _createBuffer(target, size, usage = this._gl.STATIC_DRAW) {
        const gl = this._gl;
        const buffer = new __WEBPACK_IMPORTED_MODULE_1__gl_buffer__["a" /* default */](gl, target, size);
        // TODO(dmikis) a cleverer way not to break currently bound VAO;
        this.bindVao(null);
        buffer.bind();
        gl.bufferData(target, size, usage);
        return buffer;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderContext;



/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export isPowOf2 */
/* harmony export (immutable) */ __webpack_exports__["a"] = align;
/**
 * Checks if a number is a power of 2.
 *
 * @param x The number to check.
 * @returns `true` if the number is an integer power of 2 and `false` otherwise.
 */
function isPowOf2(x) {
    return x > 0 && !(x & (x - 1));
}
/**
 * Aligns an offset by an alignment given by a mask.
 *
 * @param offset The offset.
 * @param alignmentMask The alignment mask — a bit field that has `log2(alignment)`
 *      of least significant bits unset and other set, e.g. if `alignment` is 4
 *      then the `alignmentMask` will be `0xffffffc`
 * @returns Aligned offset.
 */
function align(offset, alignmentMask) {
    return (offset - 1 & alignmentMask) - alignmentMask;
}


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Wrapper around WebGLBuffer object. */
class Buffer {
    /**
     * Creates a new empty buffer in a WebGL context.
     *
     * @param gl The context the buffer will be created in.
     * @param target Binding target of the buffer. Since in WebGL once you've
     *      bound a buffer to a given target you can't bind it any other one,
     *      we "tie" the buffer and it's binding point together.
     * @param size Size of the buffer. We don't do actual allocation in the
     *      wrapper, it's context's responsibility. But it's convenient to be
     *      able to get the size from the wrapper object.
     */
    constructor(gl, target, size) {
        this._gl = gl;
        this._target = target;
        this._handle = gl.createBuffer();
        this._size = size;
    }
    /** Binds the buffer to the context to its binding target. */
    bind() {
        this._gl.bindBuffer(this._target, this._handle);
    }
    /**
     * Returns `true` if the buffer is currently bound to the context to its
     * binding target and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        const handle = this._handle;
        switch (this._target) {
            case gl.ARRAY_BUFFER:
                return gl.getParameter(gl.ARRAY_BUFFER_BINDING) == handle;
            case gl.ELEMENT_ARRAY_BUFFER:
                return gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING) == handle;
        }
        return false;
    }
    /** Returns binding target of the buffer. */
    getTarget() {
        return this._target;
    }
    /** Returns size of the buffer. */
    getSize() {
        return this._size;
    }
    /**
     * Destroys the buffer.
     */
    destroy() {
        this._gl.deleteBuffer(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Buffer;



/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Wrapper around WebGLFramebuffer object. */
class Framebuffer {
    /**
     * Creates a new framebuffer in a WebGL context.
     *
     * @param gl The context the framebuffer will be created in.
     * @param width Width of the framebuffer.
     * @param height Height of the framebuffer.
     */
    constructor(gl, width, height) {
        this._gl = gl;
        this._handle = gl.createFramebuffer();
        this._width = width;
        this._height = height;
    }
    /**
     * Binds the framebuffer to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._handle);
    }
    /**
     * Checks if the framebuffer is bound to the WebGL context.
     *
     * @returns `true` if the framebuffer is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.FRAMEBUFFER_BINDING) == this._handle;
    }
    /**
     * Returns width of the framebuffer.
     */
    getWidth() {
        return this._width;
    }
    /**
     * Returns height of the framebuffer.
     */
    getHeight() {
        return this._height;
    }
    /**
     * Destroys the framebuffer.
     */
    destroy() {
        this._gl.deleteFramebuffer(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Framebuffer;



/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Inserts given parameters as preprocessor define directives into shader source.
 *
 * @param source Shader source.
 * @param defines Dictionary with parameters to define with preprocessor directives.
 * @returns Shader source with preprocessor directives inserted.
 */
function insertDefines(source, defines) {
    const definesString = Object.keys(defines)
        .map((defineName) => '#define ' + defineName + ' ' +
        defines[defineName])
        .join('\n');
    const versionIdx = source.indexOf('#version');
    if (versionIdx == -1) {
        return definesString + source;
    }
    const nextLineIdx = source.indexOf('\n', versionIdx) + 1;
    return source.slice(0, nextLineIdx) + definesString +
        source.slice(nextLineIdx);
}
/**
 * Creates a new shader of a given type out of a given source string.
 *
 * @param gl WebGL context the shader will be created in.
 * @param type The type of the shader, VERTEX_SHADER or FRAGMENT_SHADER.
 * @param source The source string.
 * @throws An error if compilation of the shader fails.
 * @returns The shader WebGL handle.
 */
function compileShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    // TODO Uncomment and put under debug flag (when implemented)
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error('Failed to compile shader:\n' + gl.getShaderInfoLog(shader));
    }
    return shader;
}
/** Wrapper around WebGLProgram objects. */
class Program {
    /**
     * Constructs a new program.
     *
     * @param gl WebGL context the program will be created in.
     * @param vertexShaderSource Source code of vertex shader of the program.
     * @param fragmentShaderSource Source code of fragment shader of the program.
     * @param options Options.
     * @throws An error if shader compilation or program linking fails.
     */
    constructor(gl, vertexShaderSource, fragmentShaderSource, options) {
        this._gl = gl;
        const handle = this._handle = gl.createProgram();
        if (options && options.defines) {
            vertexShaderSource = insertDefines(vertexShaderSource, options.defines);
            fragmentShaderSource = insertDefines(fragmentShaderSource, options.defines);
        }
        const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        gl.attachShader(handle, vertexShader);
        gl.attachShader(handle, fragmentShader);
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        if (options && options.attribMap) {
            Object.keys(options.attribMap)
                .forEach((attributeName) => gl.bindAttribLocation(handle, options.attribMap[attributeName], attributeName));
        }
        gl.linkProgram(handle);
        // TODO Uncomment and put under debug flag (when implemented)
        if (!gl.getProgramParameter(handle, gl.LINK_STATUS)) {
            throw new Error(`Failed to link program:\n${gl.getProgramInfoLog(handle)}`);
        }
        this._uniformCache = new Map();
    }
    /**
     * Binds the program to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        const handle = this._handle;
        // TODO Uncomment and put under debug flag (when implemented)
        // gl.validateProgram(handle);
        // if (!gl.getProgramParameter(handle, gl.VALIDATE_STATUS)) {
        //     throw new Error(
        //         'Failed to validate program:\n' + gl.getProgramInfoLog(handle)
        //     );
        // }
        gl.useProgram(handle);
    }
    /**
     * Checks if the program is bound to the WebGL context.
     *
     * @returns `true` if the program if currently bound to the WebGL context and
     *      `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.CURRENT_PROGRAM) == this._handle;
    }
    /**
     * Sets an integer scalar value to a uniform. If there's no uniform with
     * given name in the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The scalar value.
     */
    setIntScalarUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform1i(location, value);
        }
    }
    /**
     * Sets a scalar value to a uniform. If there's no uniform with
     * given name in the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The scalar value.
     */
    setScalarUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform1f(location, value);
        }
    }
    /**
     * Sets a 2D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector2Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform2f(location, value.x, value.y);
        }
    }
    /**
     * Sets a 3D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector3Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform3f(location, value.x, value.y, value.z);
        }
    }
    /**
     * Sets a 4D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector4Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform4f(location, value.x, value.y, value.z, value.w);
        }
    }
    /**
     * Sets a color to a uniform. If there's no uniform with given name in the
     * program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The color.
     */
    setColorUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform4f(location, value.r, value.g, value.b, value.a);
        }
    }
    /**
     * Sets a 3x3 matrix to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The matrix.
     */
    setMatrix3Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniformMatrix3fv(location, false, value);
        }
    }
    /**
     * Sets a 4x4 matrix to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The matrix.
     */
    setMatrix4Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniformMatrix4fv(location, false, value);
        }
    }
    /**
     * Destroys the program.
     */
    destroy() {
        this._gl.deleteProgram(this._handle);
    }
    _getUniformLocation(name) {
        const cache = this._uniformCache;
        let location = cache.get(name);
        if (!location) {
            location = this._gl.getUniformLocation(this._handle, name);
            if (!location) {
                // TODO Uncomment and put under debug flag (when implemented)
                // console.warn(`Uniform ${name} doesn't exist in program.`);
                return null;
            }
            cache.set(name, location);
        }
        return location;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Program;



/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Wrapper around WebGLRenderbuffer objects. */
class Renderbuffer {
    /**
     * Creates a new renderbuffer in a WebGL context.
     *
     * @param gl The context the renderbuffer will be created in.
     */
    constructor(gl, width, height) {
        this._gl = gl;
        this._handle = gl.createRenderbuffer();
        this._width = width;
        this._height = height;
    }
    /**
     * Binds the renderbuffer to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._handle);
    }
    /**
     * Checks if the renderbuffer is bound to the WebGL context.
     *
     * @returns `true` if the renderbuffer is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.RENDERBUFFER_BINDING) == this._handle;
    }
    /**
     * Attaches the renderbuffer to a currently bound to the WebGL context
     * framebuffer.
     *
     * @param attachmentPoint Attachment point the renderbuffer will be attached
     *      to.
     */
    attachToFramebuffer(attachmentPoint) {
        const gl = this._gl;
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentPoint, gl.RENDERBUFFER, this._handle);
    }
    getWidth() {
        return this._width;
    }
    getHeight() {
        return this._height;
    }
    /**
     * Destroys the renderbuffer.
     */
    destroy() {
        this._gl.deleteRenderbuffer(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Renderbuffer;



/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// tslint:disable
/*
    This is automatically generated by /tools/gl_gen/gen_capabilities.js script.
    Instead of modifying it edit the script and regenerate this file.
*/
class RenderContextCapabilitiesManager {
    constructor(gl) {
        this._gl = gl;
        this._paramValues = new Map();
    }
    getAliasedLineWidthRange() { return this._getParam(33902 /* ALIASED_LINE_WIDTH_RANGE */); }
    getAliasedPointSizeRange() { return this._getParam(33901 /* ALIASED_POINT_SIZE_RANGE */); }
    getMaxCombinedTextureImageUnits() { return this._getParam(35661 /* MAX_COMBINED_TEXTURE_IMAGE_UNITS */); }
    getMaxCubeMapTextureSize() { return this._getParam(34076 /* MAX_CUBE_MAP_TEXTURE_SIZE */); }
    getMaxFragmentUniformVectors() { return this._getParam(36349 /* MAX_FRAGMENT_UNIFORM_VECTORS */); }
    getMaxRenderbufferSize() { return this._getParam(34024 /* MAX_RENDERBUFFER_SIZE */); }
    getMaxTextureImageUnits() { return this._getParam(34930 /* MAX_TEXTURE_IMAGE_UNITS */); }
    getMaxTextureSize() { return this._getParam(3379 /* MAX_TEXTURE_SIZE */); }
    getMaxVaryingVectors() { return this._getParam(36348 /* MAX_VARYING_VECTORS */); }
    getMaxVertexAttribs() { return this._getParam(34921 /* MAX_VERTEX_ATTRIBS */); }
    getMaxVertexTextureImageUnits() { return this._getParam(35660 /* MAX_VERTEX_TEXTURE_IMAGE_UNITS */); }
    getMaxVertexUniformVectors() { return this._getParam(36347 /* MAX_VERTEX_UNIFORM_VECTORS */); }
    getMaxViewportDims() { return this._getParam(3386 /* MAX_VIEWPORT_DIMS */); }
    getRenderer() { return this._getParam(7937 /* RENDERER */); }
    getSubpixelBits() { return this._getParam(3408 /* SUBPIXEL_BITS */); }
    getVendor() { return this._getParam(7936 /* VENDOR */); }
    getVersion() { return this._getParam(7938 /* VERSION */); }
    /** Calling this method w/o `WEBGL_debug_renderer_info` enabled will return `null`! */
    getUnmaskedVendor() { return this._getParam(37445 /* UNMASKED_VENDOR */); }
    /** Calling this method w/o `WEBGL_debug_renderer_info` enabled will return `null`! */
    getUnmaskedRenderer() { return this._getParam(37446 /* UNMASKED_RENDERER */); }
    _getParam(param) {
        const paramValues = this._paramValues;
        let paramValue = paramValues.get(param);
        if (!paramValue) {
            paramValue = this._gl.getParameter(param);
            paramValues.set(param, paramValue);
        }
        return paramValue;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderContextCapabilitiesManager;



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Our defaults for textures are different from ones in WebGL for two reasons:
 * 1. default minification filter in WebGL is NEAREST_MIPMAP_LINEAR which requires
 *    texture to have all mip levels specified;
 * 2. default wrap modes are REPEAT which isn't supported for NPOT textures.
 */
const DEFAULT_TEXTURE_PARAMS = {
    wrapS: 33071 /* CLAMP_TO_EDGE */,
    wrapT: 33071 /* CLAMP_TO_EDGE */,
    magnificationFilter: 9728 /* NEAREST */,
    minificationFilter: 9728 /* NEAREST */
};
/* harmony export (immutable) */ __webpack_exports__["a"] = DEFAULT_TEXTURE_PARAMS;

/** Wrapper around WebGLTexture objects. For now only works with 2D textures. */
class Texture {
    /**
     * Creates a new texture in a WebGL context.
     *
     * @param gl The context the texture will be created in.
     */
    constructor(gl, width, height, format, type, params = DEFAULT_TEXTURE_PARAMS) {
        this._gl = gl;
        this._format = format;
        this._type = type;
        this._params = params;
        this._width = width;
        this._height = height;
        this._handle = gl.createTexture();
        this.bind();
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, params.wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, params.wrapT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, params.magnificationFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, params.minificationFilter);
    }
    /**
     * Binds the texture to the WebGL context as a 2D texture.
     */
    bind() {
        const gl = this._gl;
        gl.bindTexture(gl.TEXTURE_2D, this._handle);
    }
    /**
     * Sets new content of texture, provided data must be of length equal to "width * height" and its type
     * must correspond to texture's type {@see PixelType}.
     */
    setData(data) {
        const gl = this._gl;
        gl.texImage2D(gl.TEXTURE_2D, 0, this._format, this._width, this._height, 0, this._format, this._type, data);
        this._onDataUpdated();
    }
    /**
     * Sets new texture content from canvas element.
     */
    setDataFromDomElement(element) {
        const gl = this._gl;
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this._format, this._type, element);
        this._onDataUpdated();
    }
    /**
     * Checks if the texture is bound to the WebGL context.
     *
     * @returns `true` if the texture is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.TEXTURE_BINDING_2D) == this._handle;
    }
    /**
     * Attaches the texture to a currently bound to the WebGL context framebuffer.
     *
     * @param attachmentPoint Attachment point the texture will be attached to.
     */
    attachToFramebuffer(attachmentPoint) {
        const gl = this._gl;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._handle, 0);
    }
    /** Returns width of the texture. */
    getWidth() {
        return this._width;
    }
    /** Returns height of the texture. */
    getHeight() {
        return this._height;
    }
    /**
     * Destroys the texture.
     */
    destroy() {
        this._gl.deleteTexture(this._handle);
    }
    _onDataUpdated() {
        const gl = this._gl;
        if (this._params.minificationFilter >= 9984 /* NEAREST_MIPMAP_NEAREST */) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = Texture;



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Wrapper around vertex array (VAO) object from `OES_vertex_array_object`
 * extension.
 */
class VertexArrayObject {
    /**
     * Creates new VAO in a given WebGL context.
     *
     * @param gl The context.
     * @param vaoExt Instance of `OES_vertex_array_object` extension.
     * @param attributeMapping Mapping of attributes.
     */
    constructor(gl, vaoExt, attributeMapping) {
        this._gl = gl;
        this._vaoExt = vaoExt;
        this._handle = vaoExt.createVertexArrayOES();
        this.attributeMapping = attributeMapping;
    }
    /**
     * Binds the VAO to the context.
     */
    bind() {
        this._vaoExt.bindVertexArrayOES(this._handle);
    }
    /**
     * Checks if the VAO is currently bound to the context.
     *
     * @returns `true` if the VAO is currently bound to the WebGL context and
     *      `false` otherwise.
     */
    isBound() {
        return this._gl.getParameter(this._vaoExt.VERTEX_ARRAY_BINDING_OES) ==
            this._handle;
    }
    /**
     * Destroys the VAO.
     */
    destroy() {
        this._vaoExt.deleteVertexArrayOES(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = VertexArrayObject;



/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_main_renderer__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__scene__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__engine_render_loop__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_event_emitter__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__render_font_renderable_df_glyph_atlas__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__font_df_font_registry__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__render_billboard_renderable_image_atlas__ = __webpack_require__(109);







class Engine {
    constructor(context, camera) {
        this._context = context;
        this._camera = camera;
        this._renderer = new __WEBPACK_IMPORTED_MODULE_0__render_main_renderer__["a" /* default */](context);
        this._scene = new __WEBPACK_IMPORTED_MODULE_1__scene__["a" /* default */]();
        this._atlases = new Set();
        this._contentUpdateListener = () => this._onUpdate(1 /* CONTENT */);
        this._cameraUpdateListener = () => this._onUpdate(0 /* CAMERA */);
        this.renderLoop = new __WEBPACK_IMPORTED_MODULE_2__engine_render_loop__["a" /* default */](this._renderer, this._scene, camera);
        this.glyphAtlas = new __WEBPACK_IMPORTED_MODULE_4__render_font_renderable_df_glyph_atlas__["a" /* default */](context);
        this.fontRegistry = new __WEBPACK_IMPORTED_MODULE_5__font_df_font_registry__["a" /* default */]();
        this.onInternalError = new __WEBPACK_IMPORTED_MODULE_3__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._camera.onUpdate.addListener(this._cameraUpdateListener);
        this._contextLostListener = () => this.onInternalError.fire();
        this._context.onLoss.addListener(this._contextLostListener);
    }
    createImageAtlas() {
        const atlas = new __WEBPACK_IMPORTED_MODULE_6__render_billboard_renderable_image_atlas__["a" /* default */](this._context);
        atlas.onContentUpdate.addListener(this._contentUpdateListener);
        this._atlases.add(atlas);
        return atlas;
    }
    removeImageAtlas(atlas) {
        atlas.destroy();
        atlas.onContentUpdate.removeListener(this._contentUpdateListener);
        this._atlases.delete(atlas);
    }
    getRenderer() {
        return this._renderer;
    }
    getScene() {
        return this._scene;
    }
    getCamera() {
        return this._camera;
    }
    destroy() {
        this._camera.onUpdate.removeListener(this._cameraUpdateListener);
        for (const atlas of this._atlases) {
            atlas.onContentUpdate.removeListener(this._contentUpdateListener);
            atlas.destroy();
        }
        this.glyphAtlas.destroy();
        this._context.onLoss.removeListener(this._contextLostListener);
    }
    _onUpdate(type) {
        this.renderLoop.update(type);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Engine;



/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__memory_manager__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__primitive_renderer_label_point_label_renderer__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__primitive_renderer_label_curved_label_renderer__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__primitive_renderer_colliding_primitive_colliding_primitives_renderer__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__primitive_renderer_icon_icon_renderer__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__primitive_renderer_model_model_renderer__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__primitive_renderer_image_image_renderer__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__fxaa_renderer__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ssaa_renderer__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__postprocess_renderer__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__primitive_renderer_polyline_polyline_renderer__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__primitive_renderer_polyline_textured_polyline_renderer__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__primitive_renderer_polygon_textured_polygon_renderer__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__primitive_renderer_polygon_polygon_renderer__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__primitive_renderer_polygon_transparent_polygon_renderer__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__global_frame_uniforms__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__math_matrix4__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__util_cartesian_grid__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__util_gputypes__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__primitive_renderer_polyline_transparent_polyline_renderer__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__util_event_emitter__ = __webpack_require__(4);























/**
 * Maps world coordinates to corresponding points on the cartesian grid.
 */
function convertToGridCoords(point) {
    return __WEBPACK_IMPORTED_MODULE_19__math_vector2__["e" /* create */]((point.x + 1) / 2, (point.y + 1) / 2);
}
const tmpCameraPosition = __WEBPACK_IMPORTED_MODULE_19__math_vector2__["e" /* create */](0, 0);
/**
 * If there are multiple worlds visible (large monitors/low zoom) primitives are rendered in multiple passes from
 * different positions (if the wrap mode of corresponding direction is REPEAT) to get correct final picture.
 * This method calculates camera positions and prepare them to be passed to the render() method.
 */
function calculateCameraPositions(camera) {
    const positions = [];
    const visibleRegion = camera.getVisibleRegion().map(convertToGridCoords);
    for (const worldPosition of Object(__WEBPACK_IMPORTED_MODULE_18__util_cartesian_grid__["a" /* computeSquaresCoveredByConvexPolygon */])(visibleRegion)) {
        if ((camera.options.wrapModeX === 2 /* REPEAT */ || worldPosition.x === 0) &&
            (camera.options.wrapModeY === 2 /* REPEAT */ || worldPosition.y === 0)) {
            tmpCameraPosition.x = -worldPosition.x * 2.0;
            tmpCameraPosition.y = -worldPosition.y * 2.0;
            __WEBPACK_IMPORTED_MODULE_19__math_vector2__["b" /* add */](camera.center, tmpCameraPosition, tmpCameraPosition);
            const centerX = 0.5 * (tmpCameraPosition.x + 1) * 0xffffffff;
            const centerY = 0.5 * (tmpCameraPosition.y + 1) * 0xffffffff;
            const lookAtHigh = __WEBPACK_IMPORTED_MODULE_19__math_vector2__["e" /* create */](Object(__WEBPACK_IMPORTED_MODULE_20__util_gputypes__["d" /* uint16ToFloat */])(Math.trunc(centerX / 0x10000)), Object(__WEBPACK_IMPORTED_MODULE_20__util_gputypes__["d" /* uint16ToFloat */])(Math.trunc(centerY / 0x10000)));
            const lookAtLow = __WEBPACK_IMPORTED_MODULE_19__math_vector2__["e" /* create */](Object(__WEBPACK_IMPORTED_MODULE_20__util_gputypes__["d" /* uint16ToFloat */])(centerX & 0xffff), Object(__WEBPACK_IMPORTED_MODULE_20__util_gputypes__["d" /* uint16ToFloat */])(centerY & 0xffff));
            positions.push({ lookAtHigh, lookAtLow });
        }
    }
    return positions;
}
const FINAL_RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_1__state__["b" /* default */]({
    clearDepth: 0,
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Renderer that bridges high level objects such as polygons, models and styles and
 * low level graphics context.
 */
class MainRenderer {
    /**
     * Create a new renderer.
     *
     * @param context The context the renderer will operate within.
     */
    constructor(context) {
        this.onRender = new __WEBPACK_IMPORTED_MODULE_22__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._context = context;
        this._memoryManager = new __WEBPACK_IMPORTED_MODULE_0__memory_manager__["a" /* default */](context);
        this._globalUniforms = new __WEBPACK_IMPORTED_MODULE_16__global_frame_uniforms__["a" /* default */]();
        this._opaquePolygonRenderer = new __WEBPACK_IMPORTED_MODULE_14__primitive_renderer_polygon_polygon_renderer__["a" /* default */](context);
        this._transparentPolygonRenderer = new __WEBPACK_IMPORTED_MODULE_15__primitive_renderer_polygon_transparent_polygon_renderer__["a" /* default */](context);
        this._texturedPolygonRenderer = new __WEBPACK_IMPORTED_MODULE_13__primitive_renderer_polygon_textured_polygon_renderer__["a" /* default */](context);
        this._modelRenderer = new __WEBPACK_IMPORTED_MODULE_6__primitive_renderer_model_model_renderer__["a" /* default */](context);
        this._iconRenderer = new __WEBPACK_IMPORTED_MODULE_5__primitive_renderer_icon_icon_renderer__["a" /* default */](context);
        this._rasterLayerRenderer = new __WEBPACK_IMPORTED_MODULE_7__primitive_renderer_image_image_renderer__["a" /* default */](context);
        this._pointLabelRenderer = new __WEBPACK_IMPORTED_MODULE_2__primitive_renderer_label_point_label_renderer__["a" /* default */](context);
        this._curvedLabelRenderer = new __WEBPACK_IMPORTED_MODULE_3__primitive_renderer_label_curved_label_renderer__["a" /* default */](context);
        this._opaquePolylineRenderer = new __WEBPACK_IMPORTED_MODULE_11__primitive_renderer_polyline_polyline_renderer__["a" /* default */](context);
        this._transparentPolylineRenderer = new __WEBPACK_IMPORTED_MODULE_21__primitive_renderer_polyline_transparent_polyline_renderer__["a" /* default */](context);
        this._texturedPolylineRenderer = new __WEBPACK_IMPORTED_MODULE_12__primitive_renderer_polyline_textured_polyline_renderer__["a" /* default */](context);
        this._collidingPrimitivesRenderer = new __WEBPACK_IMPORTED_MODULE_4__primitive_renderer_colliding_primitive_colliding_primitives_renderer__["a" /* default */](context, [
            this._pointLabelRenderer,
            this._curvedLabelRenderer
        ]);
        this._fxaaRenderer = new __WEBPACK_IMPORTED_MODULE_8__fxaa_renderer__["a" /* default */](context);
        this._ssaaRenderer = new __WEBPACK_IMPORTED_MODULE_9__ssaa_renderer__["a" /* default */](context);
        this._backgroundRenderer = new __WEBPACK_IMPORTED_MODULE_10__postprocess_renderer__["b" /* default */](context, __WEBPACK_IMPORTED_MODULE_10__postprocess_renderer__["a" /* PostprocessType */].BACKGROUND);
        this._initInternalRenderTargets();
    }
    setRenderTargetSize(width, height) {
        const renderTarget = this._context.getDefaultRenderTarget();
        if (renderTarget.getWidth() === width &&
            renderTarget.getHeight() === height) {
            return;
        }
        this._context.getDefaultRenderTarget().setSize(width, height);
        this._destroyInternalRenderTargets();
        this._initInternalRenderTargets();
    }
    getMemoryManager() {
        return this._memoryManager;
    }
    render(scene, camera, initiator) {
        this._updateGlobalUniforms(camera);
        const renderTarget = this._context.getDefaultRenderTarget();
        switch (initiator) {
            case 2 /* USER */:
                this._render(scene, renderTarget, this._globalUniforms, true);
                this._ssaaRenderer.reset();
                break;
            case 1 /* CONTENT */:
                this._ssaaRenderer.render((renderTarget, globalUniforms) => {
                    this._render(scene, renderTarget, globalUniforms, true);
                }, renderTarget, this._globalUniforms, 0 /* ONE_FRAME */);
                break;
            case 3 /* RENDERER */:
                this._ssaaRenderer.render((renderTarget, globalUniforms) => {
                    this._render(scene, renderTarget, globalUniforms, true);
                }, renderTarget, this._globalUniforms, 1 /* MULTIPLE_FRAMES */);
                break;
        }
        this._rasterLayerRenderer.primitives = scene.getVisibleRasterLayer();
        this._rasterLayerRenderer.render(renderTarget, this._globalUniforms);
        this._iconRenderer.primitives = scene.getVisibleIcons(camera);
        this._iconRenderer.render(renderTarget, this._globalUniforms);
        this._pointLabelRenderer.primitives = scene.getVisiblePointLabels(camera);
        this._curvedLabelRenderer.primitives = scene.getVisibleCurvedLabels(camera);
        this._collidingPrimitivesRenderer.render(renderTarget, camera, this._globalUniforms);
        this._context.bindVao(null);
        this.onRender.fire();
    }
    destroy() {
        this._memoryManager.destroy();
        this._opaquePolygonRenderer.destroy();
        this._transparentPolygonRenderer.destroy();
        this._texturedPolygonRenderer.destroy();
        this._opaquePolylineRenderer.destroy();
        this._transparentPolylineRenderer.destroy();
        this._texturedPolylineRenderer.destroy();
        this._modelRenderer.destroy();
        this._rasterLayerRenderer.destroy();
        this._iconRenderer.destroy();
        this._pointLabelRenderer.destroy();
        this._curvedLabelRenderer.destroy();
        this._collidingPrimitivesRenderer.destroy();
        this._fxaaRenderer.destroy();
        this._ssaaRenderer.destroy();
    }
    /**
     * Set FXAA quality parameters.
     *
     * 'subpix' sets up the amount of sub-pixel aliasing removal.
     *
     * 'edgeThreshold' is the minimum amount of local contrast required to apply algorithm.
     *
     * 'edgeThresholdMin' trims the algorithm from processing darks.
     * @param {object = {subpix=0.75, edgeThreshold=0.063, edgeThresholdMin=0.0625}}
     * @returns void
     */
    setFxaaParams(params) {
        this._fxaaRenderer.setParams(params);
    }
    _updateGlobalUniforms(camera) {
        __WEBPACK_IMPORTED_MODULE_17__math_matrix4__["c" /* copy */](camera.getViewProjMatrix(), this._globalUniforms.viewProjMatrix);
        this._globalUniforms.pixelSize.x = 2.0 / camera.screenSize.width;
        this._globalUniforms.pixelSize.y = 2.0 / camera.screenSize.height;
        this._globalUniforms.worldToPxFactor = 2.0 / (256 * Math.pow(2, camera.zoom));
        this._globalUniforms.cameraPositions = calculateCameraPositions(camera);
    }
    get isComplete() {
        return this._ssaaRenderer.isComplete;
    }
    _render(scene, renderTarget, globalUniforms, useFxaa) {
        const context = this._context;
        const vectorRenderTarget = useFxaa ?
            this._intermediateRendereBuffer :
            renderTarget;
        if (useFxaa) {
            context.bindRenderTarget(vectorRenderTarget);
            context.bindRenderState(FINAL_RENDER_STATE);
            context.clearCurrentTarget(17664 /* ALL */);
        }
        else {
            this._backgroundRenderer.render(vectorRenderTarget);
            context.bindRenderState(FINAL_RENDER_STATE);
            context.clearCurrentTarget(256 /* DEPTH_BUFFER_BIT */);
        }
        context.bindTextureUnit(0);
        this._opaquePolygonRenderer.primitives = scene.getVisibleOpaquePolygons();
        this._opaquePolygonRenderer.render(vectorRenderTarget, globalUniforms);
        this._transparentPolygonRenderer.primitives = scene.getVisibleTransparentPolygons();
        this._transparentPolygonRenderer.render(vectorRenderTarget, globalUniforms);
        this._texturedPolygonRenderer.primitives = scene.getVisibleTexturedPolygons();
        this._texturedPolygonRenderer.render(vectorRenderTarget, globalUniforms);
        this._opaquePolylineRenderer.primitives = scene.getVisibleOpaquePolylines();
        this._opaquePolylineRenderer.render(vectorRenderTarget, globalUniforms);
        this._transparentPolylineRenderer.primitives = scene.getVisibleTransparentPolylines();
        this._transparentPolylineRenderer.render(vectorRenderTarget, globalUniforms);
        this._texturedPolylineRenderer.primitives = scene.getVisibleTexturedPolylines();
        this._texturedPolylineRenderer.render(vectorRenderTarget, globalUniforms);
        this._modelRenderer.primitives = scene.getVisibleModels();
        this._modelRenderer.render(vectorRenderTarget, globalUniforms);
        if (useFxaa) {
            this._fxaaRenderer.render(renderTarget, this._intermediateColorBuffer);
        }
    }
    _initInternalRenderTargets() {
        const context = this._context;
        const renderTarget = context.getDefaultRenderTarget();
        const targetWidth = renderTarget.getWidth();
        const targetHeight = renderTarget.getHeight();
        const intermediateColorBuffer = this._intermediateColorBuffer =
            context.createEmpty2DTexture(targetWidth, targetHeight, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        const intermediateDepthStencilBuffer = this._intermediateDepthStencilBuffer =
            context.createRenderbuffer(targetWidth, targetHeight, 34041 /* DEPTH_STENCIL */);
        this._intermediateRendereBuffer = context.createFramebuffer({
            color: intermediateColorBuffer,
            depthStencil: intermediateDepthStencilBuffer
        });
    }
    _destroyInternalRenderTargets() {
        this._intermediateRendereBuffer.destroy();
        this._intermediateColorBuffer.destroy();
        this._intermediateDepthStencilBuffer.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MainRenderer;



/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__page__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__count_vertices__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_allocator__ = __webpack_require__(18);



const MAX_VERTEX_COUNT = 0x10000;
// FIXME(dmikis) Let's use oversized index buffer til we sort out indices allocation
// both in writers and the manager.
const PAGE_INDEX_BUFFER_BYTE_SIZE = 0x100000;
/**
 * Manager that controls GL memory allocations and pagination.[]
 */
class MemoryManager {
    /**
     * Creates a new memory manager that will allocate memory in a given context.
     *
     * @param context The context.
     */
    constructor(context) {
        this._context = context;
        this._pages = new Map();
        this._emptyPagesClearTimeout = 0;
    }
    /**
     * Allocates memory for a given data in the manager and uploads given data.
     *
     * @param vertexData Buffer with vertices that needs to be allocated.
     * @param indexData Buffer with indices that needs to be allocated.
     * @param attributeMapping Mapping of vertex attributes.
     * @returns Descriptor of the allocated memory region.
     */
    allocate(vertexData, indexData, attributeMapping) {
        const context = this._context;
        let pageSet = this._pages.get(attributeMapping);
        // If there's no pages for the given attribute mapping, create a new set.
        if (!pageSet) {
            pageSet = new Set();
            this._pages.set(attributeMapping, pageSet);
        }
        // Try to allocate data in the existing pages.
        for (const page of pageSet) {
            const memoryChunk = page.allocate(vertexData.byteLength, indexData.byteLength);
            if (memoryChunk) {
                // Success! Now we just upload the data.
                this._updatePage(page, memoryChunk, vertexData, indexData);
                return memoryChunk;
            }
        }
        // We've failed to allocate the data in any of existing pages. No worries
        // though, we just create a new one:)
        const vertexBuffer = context.createVertexBuffer(
        // some buffer writers don't use indices and MAX_VERTEX_COUNT restriction is not applied in such cases
        Math.max(MAX_VERTEX_COUNT * attributeMapping.vertexByteSize, vertexData.byteLength));
        const indexBuffer = context.createIndexBuffer(PAGE_INDEX_BUFFER_BYTE_SIZE);
        const vao = context.createVao(attributeMapping, vertexBuffer, indexBuffer);
        const page = new SinglePassMemoryPage(vertexBuffer, indexBuffer, vao, 5123 /* UNSIGNED_SHORT */);
        page.setDelegate(this);
        pageSet.add(page);
        // Here we assume we always can allocate data in an empty page.
        const memoryChunk = page.allocate(vertexData.byteLength, indexData.byteLength);
        this._updatePage(page, memoryChunk, vertexData, indexData);
        return memoryChunk;
    }
    onPageEmpty() {
        if (!this._emptyPagesClearTimeout) {
            this._emptyPagesClearTimeout = setTimeout(() => {
                this._clearEmptyPages();
                this._emptyPagesClearTimeout = 0;
            });
        }
    }
    /**
     * Destroys the manager and all its memory pages. All memory chunks that were
     * allocated in the manager become invalid.
     */
    destroy() {
        if (this._emptyPagesClearTimeout) {
            clearTimeout(this._emptyPagesClearTimeout);
        }
        for (const [, pageSet] of this._pages) {
            for (const page of pageSet) {
                page.destroy();
            }
        }
    }
    _updatePage(page, memoryChunk, vertexData, indexData) {
        const context = this._context;
        // Let's ensure that we won't break any bound VAOs.
        context.bindVao(null);
        context.uploadDataToBuffer(page.vertexBuffer, vertexData, memoryChunk.vertexByteOffset);
        // Shift indices.
        const baseIndex = Object(__WEBPACK_IMPORTED_MODULE_1__count_vertices__["b" /* countVertices */])(memoryChunk.vertexByteOffset, page.vao.attributeMapping);
        for (let i = 0; i < indexData.length; ++i) {
            indexData[i] += baseIndex;
        }
        context.uploadDataToBuffer(page.indexBuffer, indexData, memoryChunk.indexByteOffset);
    }
    _clearEmptyPages() {
        for (const pageSet of this._pages.values()) {
            for (const page of pageSet) {
                if (page.isEmpty()) {
                    pageSet.delete(page);
                    page.setDelegate(null);
                    page.destroy();
                }
            }
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MemoryManager;

/**
 * Memory page with the following peculiarity: once allocation is failed it gets closed for any subsequent
 * allocations. It allow to keep related primitives closer in memory.
 */
class SinglePassMemoryPage extends __WEBPACK_IMPORTED_MODULE_0__page__["a" /* default */] {
    constructor(vertexBuffer, indexBuffer, vao, indexType) {
        super(vertexBuffer, indexBuffer, vao, indexType, new __WEBPACK_IMPORTED_MODULE_2__util_allocator__["a" /* ArenaAllocator */](vertexBuffer.getSize()), new __WEBPACK_IMPORTED_MODULE_2__util_allocator__["a" /* ArenaAllocator */](indexBuffer.getSize()));
        this._failedAllocation = false;
    }
    allocate(vertexByteLength, indexByteLength) {
        if (this._failedAllocation) {
            return null;
        }
        const chunk = super.allocate(vertexByteLength, indexByteLength);
        this._failedAllocation = (chunk === null);
        return chunk;
    }
}


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__chunk__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_delegator__ = __webpack_require__(57);


/**
 * A "page" of GPU memory. Comprises vertex and index buffers of a fixed size.
 */
class MemoryPage extends __WEBPACK_IMPORTED_MODULE_1__util_delegator__["a" /* DelegatorBase */] {
    /**
     * Creates a new page to manage given vertex and index buffers.
     *
     * @param vertexBuffer The vertex buffer the page will manage.
     * @param indexBuffer The index buffer the page will manager.
     * @param vao The VAO of the page.
     * @param indexType Type of elements of indexBuffer.
     * @param vertexAllocator Allocator of vertex data, logic of allocation directly impacts the lifecycle of the page.
     * @param indexAllocator Allocator of index data, logic of allocation directly impacts the lifecycle of the page.
     */
    constructor(vertexBuffer, indexBuffer, vao, indexType, vertexAllocator, indexAllocator) {
        super();
        this.vertexBuffer = vertexBuffer;
        this.indexBuffer = indexBuffer;
        this.vao = vao;
        this.indexType = indexType;
        this._vertexAllocator = vertexAllocator;
        this._indexAllocator = indexAllocator;
    }
    /**
     * Allocates and writes vertex and index data to the page. Offsets indices
     * in an index array to appropriately take into account offset of the vertex
     * data.
     *
     * @param vertexByteLength required number of bytes in vertex buffer
     * @param indexByteLength required number of bytes in index buffer
     * @returns memory chunk allocated or `null` if allocation's failed
     */
    allocate(vertexByteLength, indexByteLength) {
        if (this._vertexAllocator.maxAllocableSize >= vertexByteLength &&
            this._indexAllocator.maxAllocableSize >= indexByteLength) {
            return new __WEBPACK_IMPORTED_MODULE_0__chunk__["a" /* default */](this, {
                vertexByteOffset: this._vertexAllocator.allocate(vertexByteLength),
                vertexByteLength: vertexByteLength,
                indexByteOffset: this._indexAllocator.allocate(indexByteLength),
                indexByteLength: indexByteLength
            });
        }
        else {
            return null;
        }
    }
    /**
     * Frees a previously allocated memory chunk.
     *
     * @param chunk The chunk to be freed.
     */
    free(chunk) {
        this._vertexAllocator.deallocate(chunk.vertexByteOffset);
        this._indexAllocator.deallocate(chunk.indexByteOffset);
        if (this.isEmpty() && this._delegate) {
            this._delegate.onPageEmpty(this);
        }
    }
    /**
     * Returns `true` if the page does not contain any previously allocated data
     * and `false` otherwise.
     */
    isEmpty() {
        return this._vertexAllocator.isEmpty && this._indexAllocator.isEmpty;
    }
    /**
     * Destroys the page and all its resources.
     */
    destroy() {
        this.vertexBuffer.destroy();
        this.indexBuffer.destroy();
        this.vao.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MemoryPage;



/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__ = __webpack_require__(17);

/** Handler to a allocated memory chunk. */
class MemoryChunk extends __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__["a" /* default */] {
    /**
     * Creates a new handler to a memory chunk with given offsets allocated in
     * a given memory page.
     *
     * @param page The page the chunk was allocated in.
     * @param vertexOffset The offset of chunk's vertex data.
     * @param indexOffset The offset of chunk's index data.
     */
    constructor(page, location) {
        super();
        this.page = page;
        this._location = location;
    }
    /**
     * Returns offset of vertex data of the chunk in bytes.
     */
    get vertexByteOffset() {
        return this._location.vertexByteOffset;
    }
    /**
     * Returns offset of index data of the chunk in bytes.
     */
    get indexByteOffset() {
        return this._location.indexByteOffset;
    }
    destroy() {
        this.page.free(this);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MemoryChunk;



/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class DelegatorBase {
    constructor() {
        this._delegate = null;
    }
    setDelegate(delegate) {
        this._delegate = delegate;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DelegatorBase;



/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Simple implementation of Binary Search Tree.
 */
class BinarySearchTree {
    /**
     * @param comparator To specify the order of items, that can be any complex objects.
     */
    constructor(comparator) {
        this._comparator = comparator;
        this._size = 0;
    }
    /**
     * @returns The root element or `undefined` if the tree is empty.
     */
    get root() {
        return this._root;
    }
    /**
     * @returns The number of items in the tree.
     */
    get size() {
        return this._size;
    }
    /**
     * @returns The smallest element in the tree or `undefined` the the tree is empty.
     */
    get min() {
        if (this._root) {
            return this._min(this._root).value;
        }
        return undefined;
    }
    /**
     * @returns The biggest element in the tree or `undefined` the the tree is empty.
     */
    get max() {
        if (this._root) {
            return this._max(this._root).value;
        }
        return undefined;
    }
    insert(item) {
        this._size++;
        if (!this._root) {
            this._root = { value: item };
            return this._root;
        }
        let node = this._root;
        while (node) {
            if (this._comparator(item, node.value) < 0) {
                if (!node.left) {
                    return node.left = { parent: node, value: item };
                }
                node = node.left;
            }
            else {
                if (!node.right) {
                    return node.right = { parent: node, value: item };
                }
                node = node.right;
            }
        }
        // impossible to get there, throwing is to make TS analizator happy
        throw new Error();
    }
    remove(node) {
        this._size--;
        if (node.left && node.right) {
            const successor = this._min(node.right);
            this._replaceSubtree(node, successor);
            // update links to children of the removed node
            if (node.left) {
                successor.left = node.left;
                node.left.parent = successor;
            }
            if (node.right) {
                successor.right = node.right;
                node.right.parent = successor;
            }
        }
        else if (node.left) {
            this._replaceSubtree(node, node.left);
        }
        else if (node.right) {
            this._replaceSubtree(node, node.right);
        }
        else {
            this._replaceSubtree(node, undefined);
        }
    }
    /**
     * Iterates elements in ascending order.
     */
    *values(node) {
        if (node) {
            yield* this.values(node.left);
            yield node.value;
            yield* this.values(node.right);
        }
    }
    /**
     * Iterates elements in ascending order.
     */
    [Symbol.iterator]() {
        return this.values(this._root);
    }
    _min(from) {
        let node = from;
        while (node.left) {
            node = node.left;
        }
        return node;
    }
    _max(from) {
        let node = from;
        while (node.right) {
            node = node.right;
        }
        return node;
    }
    /**
     * Reorganizes the tree structure so that the replacement node takes replaceable's position, the latter is removed.
     */
    _replaceSubtree(replaceable, replacement) {
        if (replaceable.parent) {
            if (replaceable.parent.left === replaceable) {
                replaceable.parent.left = replacement;
            }
            else if (replaceable.parent.right === replaceable) {
                replaceable.parent.right = replacement;
            }
        }
        else {
            this._root = replacement;
        }
        if (replacement) {
            // remove replacement from its current location
            if (replacement.parent) {
                if (replacement.parent.left === replacement) {
                    replacement.parent.left = undefined;
                }
                else if (replacement.parent.right === replacement) {
                    replacement.parent.right = undefined;
                }
            }
            replacement.parent = replaceable.parent;
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BinarySearchTree;



/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Set with predictable iteration order. Stores items as a two way linked list thus allowing to insert items in between.
 */
class LinkedSet {
    constructor() {
        this._nodes = new Map();
    }
    get begin() {
        return this._begin && this._begin.value;
    }
    get end() {
        return this._end && this._end.value;
    }
    /**
     * Inserts a new item at the end of the set.
     */
    insert(item) {
        if (!this._nodes.has(item)) {
            const node = { value: item };
            if (this._end) {
                this.insertAfter(this._end.value, item);
            }
            else {
                this._begin = this._end = node;
                this._nodes.set(item, node);
            }
        }
    }
    /**
     * Inserts a new item before the specified one. If the before item is not in the set or
     * the item is already inserted nothing happens.
     */
    insertBefore(before, item) {
        const beforeNode = this._nodes.get(before);
        if (beforeNode && !this._nodes.has(item)) {
            const node = { value: item };
            if (beforeNode.prev) {
                beforeNode.prev.next = node;
                node.prev = beforeNode.prev;
            }
            node.next = beforeNode;
            beforeNode.prev = node;
            this._nodes.set(item, node);
            if (beforeNode === this._begin) {
                this._begin = node;
            }
        }
    }
    /**
     * Inserts a new item after the specified one. If the after item is not in the set or
     * the item is already inserted nothing happens.
     */
    insertAfter(after, item) {
        const afterNode = this._nodes.get(after);
        if (afterNode && !this._nodes.has(item)) {
            const node = { value: item };
            if (afterNode.next) {
                afterNode.next.prev = node;
                node.next = afterNode.next;
            }
            node.prev = afterNode;
            afterNode.next = node;
            this._nodes.set(item, node);
            if (afterNode === this._end) {
                this._end = node;
            }
        }
    }
    /**
     * Removes item from the set.
     */
    remove(item) {
        const node = this._nodes.get(item);
        if (node) {
            if (node === this._begin) {
                this._begin = node.next;
            }
            if (node === this._end) {
                this._end = node.prev;
            }
            if (node.next) {
                node.next.prev = node.prev;
            }
            if (node.prev) {
                node.prev.next = node.next;
            }
            this._nodes.delete(item);
        }
    }
    /**
     * @returns `undefined` if the item is not in the set or it is the first elements.
     */
    getPrev(item) {
        const node = this._nodes.get(item);
        if (node && node.prev) {
            return node.prev.value;
        }
        return undefined;
    }
    /**
     * @returns `undefined` if the item is not in the set or it is the last elements.
     */
    getNext(item) {
        const node = this._nodes.get(item);
        if (node && node.next) {
            return node.next.value;
        }
        return undefined;
    }
    /**
     * Iterates over the set from the fist element to the last (in the order of insertion
     * if the insert method was used only).
     */
    *values() {
        let node = this._begin;
        while (node) {
            yield node.value;
            node = node.next;
        }
    }
    /**
     * Iterates over the set from the fist element to the last (in the order of insertion
     * if the insert method was used only).
     */
    [Symbol.iterator]() {
        return this.values();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LinkedSet;



/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_color_id_frag__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_color_id_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_color_id_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__label_renderer__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__billboard_rectangle_renderer__ = __webpack_require__(63);





const PROGRAM_OPTIONS = {
    attribMap: {
        vertexId: 2 /* ID */,
        vertexPosHigh: 0 /* POSITION_HIGH */,
        vertexPosLow: 1 /* POSITION_LOW */,
        vertexDisplacement: 6 /* DISPLACEMENT */,
        vertexUV: 4 /* UV */,
        vertexPriority: 9 /* PRIORITY */,
        vertexColor: 7 /* COLOR */,
        vertexOutlineColor: 8 /* OUTLINE_COLOR */,
        vertexScale: 11 /* AUX */
    }
};
/**
 * Point labels renderer. It uses appropriate program to layout glyphs on GPU.
 */
class PointLabelRenderer extends __WEBPACK_IMPORTED_MODULE_3__label_renderer__["a" /* default */] {
    constructor(context) {
        super(context, context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag___default.a, Object.assign({}, PROGRAM_OPTIONS)), context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shader_color_id_frag___default.a, Object.assign({ defines: { COLOR_ID_MODE: 1 } }, PROGRAM_OPTIONS)));
        this._backgroundRenderer = new __WEBPACK_IMPORTED_MODULE_4__billboard_rectangle_renderer__["a" /* default */](context);
    }
    renderVisible(target, uniforms, visibility) {
        this._backgroundRenderer.primitives = this.primitives
            .filter((label) => label.background !== undefined)
            .map((label) => label.background);
        this._backgroundRenderer.render(target, uniforms, visibility);
        super.renderVisible(target, uniforms, visibility);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PointLabelRenderer;



/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to label's center, in px\nattribute vec2 vertexDisplacement;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute float vertexScale;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 visibilitySize;\nuniform vec2 shift;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying mediump float scale;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvec2 VISIBILITY_HALF_PX = 0.5 / visibilitySize;\n\nvoid main(void) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n    position.xyz /= position.w;\n    position.w = 1.0;\n\n    gl_Position = position + vec4(vertexDisplacement * pixelSize, 0.0, 0.0);\n\n#ifdef COLOR_ID_MODE\n    gl_Position.xy += shift;\n    gl_Position.z = vertexPriority;\n    color = vec4(vertexId, 0, 1);\n#else\n    vec4 visibilityValue = texture2D(visibility, vertexId.xy + VISIBILITY_HALF_PX);\n    if (visibilityValue.x == 1.0) {\n        gl_Position.z = -2.0; // make it invisible\n        return;\n    }\n    uv = vertexUV;\n    color = vertexColor;\n    outlineColor = vertexOutlineColor;\n    scale = vertexScale;\n#endif\n}\n"

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export appendToBatch */
/* harmony export (immutable) */ __webpack_exports__["a"] = batchAllocatedObjects;
/**
 * Appends portion of memory to batch if they are adjacent.
 *
 * @returns `true` if both params are adjacent and the batch was successfully updated, `false` otherwise.
 */
function appendToBatch(memoryLocation, batch) {
    if (batch.vertexByteOffset + batch.vertexByteLength === memoryLocation.vertexByteOffset &&
        batch.indexByteOffset + batch.indexByteLength === memoryLocation.indexByteOffset) {
        batch.vertexByteLength += memoryLocation.vertexByteLength;
        batch.indexByteLength += memoryLocation.indexByteLength;
        return true;
    }
    return false;
}
/**
 * Combines objects allocated in memory into batches. No sorting is done in this method, the objects are supposed
 * to be sorted by index/vertex offsets to make batching effective. The batch is created by factory since it can
 * contains problem specific information.
 *
 * @param objects List of allocated objects.
 * @param getMemoryLocation Returns memory location of specific object.
 * @param createBatch Initiates batch by the first object.
 * @param canBatch Checks if two objects can be allocated.
 * @returns Iterable list of batches.
 */
function* batchAllocatedObjects(objects, getMemoryLocation, createBatch, canBatch = () => true) {
    const iterator = objects[Symbol.iterator]();
    let primitive = iterator.next().value;
    if (!primitive) {
        return;
    }
    let prev = primitive;
    let batch = createBatch(prev);
    while (primitive = iterator.next().value) {
        const primitiveMemoryLocation = getMemoryLocation(primitive);
        if (!canBatch(prev, primitive, batch) || !appendToBatch(primitiveMemoryLocation, batch)) {
            yield batch;
            batch = createBatch(primitive);
        }
        prev = primitive;
    }
    yield batch;
}


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_renderer__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_billboard_rectangle_vert__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_billboard_rectangle_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_billboard_rectangle_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_billboard_rectangle_frag__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_billboard_rectangle_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_billboard_rectangle_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__memory_count_vertices__ = __webpack_require__(3);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_3__state__["b" /* default */](__WEBPACK_IMPORTED_MODULE_3__state__["a" /* BLEND_OVER_RENDER_STATE */]);
/**
 * Renderer of billboard rectangles.
 */
class BillboardRectangleRenderer extends __WEBPACK_IMPORTED_MODULE_0__primitive_renderer__["a" /* default */] {
    constructor(context) {
        super(context, RENDER_STATE, context.createProgram(__WEBPACK_IMPORTED_MODULE_1__shader_billboard_rectangle_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shader_billboard_rectangle_frag___default.a, {
            attribMap: {
                vertexId: 2 /* ID */,
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */,
                vertexColor: 7 /* COLOR */,
                vertexBorderRadii: 11 /* AUX */
            }
        }));
        this._visibilitySizeUniform = __WEBPACK_IMPORTED_MODULE_4__math_vector2__["e" /* create */](0, 0);
    }
    render(target, uniforms, visibility) {
        this._visibility = visibility;
        super.render(target, uniforms);
    }
    _renderPrimitives(primitives) {
        for (const memoryBatch of this.batchPrimitives(primitives)) {
            this._context.bindVao(memoryBatch.page.vao);
            this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(__WEBPACK_IMPORTED_MODULE_5__memory_count_vertices__["a" /* countIndices */])(memoryBatch.indexByteLength, memoryBatch.page.indexType));
        }
    }
    _bindProgram(program, uniforms) {
        super._bindProgram(program, uniforms);
        program.setVector2Uniform('pixelSize', uniforms.pixelSize);
        if (this._visibility) {
            this._visibilitySizeUniform.x = this._visibility.getWidth();
            this._visibilitySizeUniform.y = this._visibility.getHeight();
            program.setIntScalarUniform('visibility', 0);
            program.setVector2Uniform('visibilitySize', this._visibilitySizeUniform);
            this._context.bindTextureUnit(0);
            this._context.bindTexture(this._visibility);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BillboardRectangleRenderer;



/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec2 vertexId;\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\nattribute vec4 vertexColor;\nattribute vec2 vertexBorderRadii;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 visibilitySize;\n\nvarying vec2 uv;\nvarying vec4 color;\nvarying vec2 borderRadii;\n\nconst vec4 INVISIBLE_GL_POSITION = vec4(2, 2, 2, 1);\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\nvec2 VISIBILITY_HALF_PX = 0.5 / visibilitySize;\n\nvoid main(void) {\n    vec4 visibilityValue = texture2D(visibility, vertexId.xy + VISIBILITY_HALF_PX);\n    if (visibilityValue.x == 1.0) {\n        gl_Position = INVISIBLE_GL_POSITION;\n        return;\n    }\n\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n    position.xyz /= position.w;\n    position.w = 1.0;\n\n    gl_Position = position + vec4(vertexDisplacement * pixelSize, 0.0, 0.0);\n\n    uv = vertexUV;\n    color = vertexColor;\n    borderRadii = vertexBorderRadii;\n}\n"

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n\nvarying vec2 uv;\nvarying vec4 color;\nvarying vec2 borderRadii;\n\nfloat roundedRectangle(const in vec2 uv, const in vec2 radii) {\n    vec2 absUv = abs(uv);\n    vec2 q = absUv + radii - 1.0;\n    return min(q.x, q.y) > 0.0 ? length(q / radii) : max(absUv.x, absUv.y);\n}\n\nvoid main(void) {\n    gl_FragColor = step(roundedRectangle(uv, borderRadii), 1.0) * color;\n}\n"

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_color_id_frag__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_color_id_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_color_id_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__label_renderer__ = __webpack_require__(21);




const PROGRAM_OPTIONS = {
    attribMap: {
        vertexId: 2 /* ID */,
        vertexPosHigh: 0 /* POSITION_HIGH */,
        vertexPosLow: 1 /* POSITION_LOW */,
        vertexDisplacements: 6 /* DISPLACEMENT */,
        vertexUV: 4 /* UV */,
        vertexColor: 7 /* COLOR */,
        vertexOutlineColor: 8 /* OUTLINE_COLOR */,
        vertexScale: 11 /* AUX */,
        vertexPriority: 9 /* PRIORITY */,
        leftPolylinePoint1: 12 /* AUX1 */,
        leftPolylinePoint2: 13 /* AUX2 */,
        rightPolylinePoint1: 14 /* AUX3 */,
        rightPolylinePoint2: 15 /* AUX4 */
    }
};
/**
 * Curved labels renderer. It uses appropriate program to layout glyphs on GPU.
 */
class CurvedLabelRenderer extends __WEBPACK_IMPORTED_MODULE_3__label_renderer__["a" /* default */] {
    constructor(context) {
        super(context, context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag___default.a, Object.assign({}, PROGRAM_OPTIONS)), context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shader_color_id_frag___default.a, Object.assign({ defines: { COLOR_ID_MODE: 1 } }, PROGRAM_OPTIONS)));
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CurvedLabelRenderer;



/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to glyph's center (two values),\n// and distance of the glyph center to label's center (third value), in px\nattribute vec3 vertexDisplacements;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute float vertexScale;\n\n// deltas relative to the world point encoded in vertexPosHigh/vertexPosLow\nattribute vec2 leftPolylinePoint1;\nattribute vec2 leftPolylinePoint2;\nattribute vec2 rightPolylinePoint1;\nattribute vec2 rightPolylinePoint2;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 visibilitySize;\nuniform vec2 shift;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst float INFINITY = 1000000.0; // large enough for a segment length to consider it infinity\nconst int MAX_POLYLINE_POINTS = 2;\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvec2 VISIBILITY_HALF_PX = 0.5 / visibilitySize;\n\n/**\n * Returns world coordinate (plus delta) projected on screen, in pixels.\n */\nvec2 project(vec2 pointHigh, vec2 pointLow, vec2 delta) {\n    vec4 position = viewProjMatrix * vec4(\n            YV_H * (pointHigh - lookAtHigh) + YV_L * (pointLow - lookAtLow) + delta,\n            0,\n            1\n        );\n    vec2 projected = position.xy / position.w;\n    return projected / pixelSize;\n}\n\nvoid setPolylineUpDirection(inout vec2 polylineDeltas[MAX_POLYLINE_POINTS], bool isRightPart) {\n    if (isRightPart) {\n        polylineDeltas[0] = rightPolylinePoint1;\n        polylineDeltas[1] = rightPolylinePoint2;\n    } else {\n        polylineDeltas[0] = leftPolylinePoint1;\n        polylineDeltas[1] = leftPolylinePoint2;\n    }\n}\n\n/**\n * Curved labels are layouted here: the label is centered in the vertexPosHigh/vertexPosLow and polyline points\n * are used to guide concrete gryph vertex. Number of polyline points is hardcoded to pass them in attributes.\n */\nvoid main(void) {\n    vec2 vertexDisplacement = vertexDisplacements.xy;\n    float vertexLineDisplacement = vertexDisplacements.z;\n    vec2 polylineDeltas[MAX_POLYLINE_POINTS];\n    vec2 position = project(vertexPosHigh, vertexPosLow, vec2(0, 0));\n    float remainingLength = abs(vertexLineDisplacement);\n    for (int i = 0; i < MAX_POLYLINE_POINTS; i++) {\n        vec2 projectedPoint;\n\n        // figure out the direction (left/right) at the first step\n        if (i == 0) {\n            projectedPoint = project(vertexPosHigh, vertexPosLow, rightPolylinePoint1);\n            bool isRightPart = vertexLineDisplacement > 0.0;\n            bool isInverted = projectedPoint.x < position.x;\n            // the map could be rotated and curved label should change its direction if they got upside down\n            // using center segment to identify this case is an approximation (ideally we should check all segments)\n            setPolylineUpDirection(polylineDeltas, isRightPart ^^ isInverted); // invert isRightPart if isInverted\n\n            // the first right point of the segment already calculated,\n            // recalculate the point if this part of the label goes other direction\n            if (!(isRightPart && !isInverted) && !(!isRightPart && isInverted)) {\n                projectedPoint = project(vertexPosHigh, vertexPosLow, polylineDeltas[i]);\n            }\n        } else {\n            projectedPoint = project(vertexPosHigh, vertexPosLow, polylineDeltas[i]);\n        }\n\n        vec2 segment = projectedPoint - position;\n        bool isLast = i == (MAX_POLYLINE_POINTS - 1);\n        float segmentLength = (isLast || (polylineDeltas[i + 1] == vec2(0, 0))) ? INFINITY : length(segment);\n\n        if (segmentLength > remainingLength) {\n            float signFactor = vertexLineDisplacement > 0.0 ? 1.0 : -1.0;\n            vec2 direction = normalize(segment);\n            vec2 normal = vec2(-direction.y, direction.x);\n\n            position += direction * remainingLength;\n            position += signFactor * direction * vertexDisplacement.x;\n            position += signFactor * normal * vertexDisplacement.y;\n\n            break;\n        } else {\n            remainingLength -= segmentLength;\n            position += segment;\n        }\n    }\n\n    gl_Position = vec4(position * pixelSize, 0.0, 1.0);\n\n#ifdef COLOR_ID_MODE\n    gl_Position.xy += shift;\n    gl_Position.z = vertexPriority;\n    color = vec4(vertexId, 0, 1);\n#else\n    vec4 visibilityValue = texture2D(visibility, vertexId.xy + VISIBILITY_HALF_PX);\n    if (visibilityValue.x == 1.0) {\n        gl_Position.z = -2.0; // make it invisible\n        return;\n    }\n    uv = vertexUV;\n    color = vertexColor;\n    outlineColor = vertexOutlineColor;\n    scale = vertexScale;\n#endif\n}\n"

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_color__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_collision_sampler_vert__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_collision_sampler_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_collision_sampler_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_collision_sampler_frag__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_collision_sampler_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_collision_sampler_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shader_full_overlap_sampler_vert__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shader_full_overlap_sampler_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__shader_full_overlap_sampler_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_vector3__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_matrix4__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__collision_sampler_buffer_writer__ = __webpack_require__(72);









const EMPTY = __WEBPACK_IMPORTED_MODULE_0__util_color__["c" /* create */](0, 0, 0, 1);
const INVISIBLE = __WEBPACK_IMPORTED_MODULE_0__util_color__["c" /* create */](1, 1, 1, 1);
const VISIBILITY_RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_4__state__["b" /* default */]({
    clearColor: INVISIBLE,
    dither: false
});
const RENDER_STATE_PRIORITY = new __WEBPACK_IMPORTED_MODULE_4__state__["b" /* default */]({
    clearColor: EMPTY,
    depthTest: true,
    clearDepth: 0,
    depthFunc: 516 /* GREATER */,
    dither: false
});
const RENDER_STATE_REVERSE_PRIORITY = new __WEBPACK_IMPORTED_MODULE_4__state__["b" /* default */]({
    clearColor: EMPTY,
    depthTest: true,
    clearDepth: 1,
    depthFunc: 515 /* LESS_OR_EQUAL */,
    dither: false
});
// size of minimal recognizable square side in css pixels.
const GRID_PRECISION_PX = 6;
/**
 * The id of a primitive should meet the following criteria:
 *   it should be encoded as single pixel RGBA texture (from 0 to 2^32 - 1) after overlap sampling phase
 *   and it should be used as coordinates of a primitive's visibility flag in visibility texture
 * 256 (one byte) seems the most handy value as it fits the color component size and makes
 * the visibility texture's size acceptable (256x256).
 */
const ID_COMPONENT_SIZE = 256;
const OUTPUT_HALF_PX_SIZE = __WEBPACK_IMPORTED_MODULE_5__math_vector2__["e" /* create */](0.5 / ID_COMPONENT_SIZE, 0.5 / ID_COMPONENT_SIZE);
const PRIORITY_TEXTURE_INDEX = 0;
const REVERSE_PRIORITY_TEXTURE_INDEX = 1;
const PREV_VISIBILITY_TEXTURE_INDEX = 2;
/**
 * There can be many primitive renderers that should hide colliding primitives, this class takes over
 * the building of the visibility texture and supplies it to them. The renderers should not be called
 * to render independently, this one will manage it.
 */
class CollidingPrimitivesRenderer {
    constructor(context, renderers) {
        this._context = context;
        this._renderers = renderers;
        this._stabiltyShift = __WEBPACK_IMPORTED_MODULE_6__math_vector3__["e" /* create */](0, 0, 0);
        this._prevTargetSize = { width: -1, height: -1 };
        this._priorityPxSizeUniform = __WEBPACK_IMPORTED_MODULE_5__math_vector2__["e" /* create */](0, 0);
        this._currentVisibilityTexture = context.createEmpty2DTexture(ID_COMPONENT_SIZE, ID_COMPONENT_SIZE, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._currentVisibilityBuffer = context.createFramebuffer({
            color: this._currentVisibilityTexture
        });
        this._prevVisibilityTexture = context.createEmpty2DTexture(ID_COMPONENT_SIZE, ID_COMPONENT_SIZE, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._prevVisibilityBuffer = context.createFramebuffer({
            color: this._prevVisibilityTexture
        });
        this._visibilityProgram = context.createProgram(__WEBPACK_IMPORTED_MODULE_1__shader_collision_sampler_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shader_collision_sampler_frag___default.a, {
            attribMap: {
                uv: 0 /* POSITION */
            }
        });
        this._fullOverlapVisibilityProgram = context.createProgram(__WEBPACK_IMPORTED_MODULE_3__shader_full_overlap_sampler_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shader_collision_sampler_frag___default.a, {
            attribMap: {
                uv: 0 /* POSITION */
            }
        });
        // this texture is attached uninitialized at the first draw call and FF is complaining about slow zeroing
        // texture data, whilst this manual clearing doesn't change anything it removes annoying console warning
        this._context.bindRenderState(VISIBILITY_RENDER_STATE);
        this._context.bindRenderTarget(this._prevVisibilityBuffer);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */);
    }
    render(target, camera, uniforms) {
        if (target.getWidth() !== this._prevTargetSize.width ||
            target.getHeight() !== this._prevTargetSize.height) {
            this._onTargetSizeChanged(target.getWidth(), target.getHeight());
        }
        // Rasterization may be not stable in the sense of the shape of pixels occupied by particular object when this
        // object gets shifted (e.g. the user drags the center of the map) and since collisions are detected by
        // overlapped pixels this fact can lead to blinking (found overlapping in one frame/not found in the next/etc).
        // For those objects (and their positions) that are not distorted by perspective it can be fixed by
        // introducing a shift that takes into account the amount of drag and forces vertices to be displaced in the
        // same position in grid's cell.
        this._stabiltyShift.x = camera.center.x;
        this._stabiltyShift.y = camera.center.y;
        this._stabiltyShift.z = 0;
        __WEBPACK_IMPORTED_MODULE_7__math_matrix4__["b" /* apply */](camera.getViewProjMatrix(), this._stabiltyShift, this._stabiltyShift);
        // NDC (-1 : 1) are 2 times larger than texture coordinates (0 : 1)
        this._stabiltyShift.x %= 2 * this._priorityPxSizeUniform.x;
        this._stabiltyShift.y %= 2 * this._priorityPxSizeUniform.y;
        // render all primitives in straight order
        this._context.bindRenderTarget(this._priorityColorBuffer);
        this._context.bindRenderState(RENDER_STATE_PRIORITY);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */ | 256 /* DEPTH_BUFFER_BIT */);
        for (const renderer of this._renderers) {
            renderer.renderInColorIdMode(this._priorityColorBuffer, uniforms, this._stabiltyShift);
        }
        // render all primitives in straight order
        this._context.bindRenderTarget(this._reversePriorityColorBuffer);
        this._context.bindRenderState(RENDER_STATE_REVERSE_PRIORITY);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */ | 256 /* DEPTH_BUFFER_BIT */);
        for (const renderer of this._renderers) {
            renderer.renderInColorIdModeReversePriority(this._reversePriorityColorBuffer, uniforms, this._stabiltyShift);
        }
        // sample previously rendered outputs to find out collisions
        this._context.bindRenderState(VISIBILITY_RENDER_STATE);
        this._context.bindRenderTarget(this._currentVisibilityBuffer);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */);
        const fullOverlapVisibilityProgram = this._fullOverlapVisibilityProgram;
        this._context.bindProgram(fullOverlapVisibilityProgram);
        fullOverlapVisibilityProgram.setIntScalarUniform('priority', PRIORITY_TEXTURE_INDEX);
        fullOverlapVisibilityProgram.setVector2Uniform('priorityPxSize', this._priorityPxSizeUniform);
        fullOverlapVisibilityProgram.setVector2Uniform('outputHalfPxSize', OUTPUT_HALF_PX_SIZE);
        this._context.bindTextureUnit(PRIORITY_TEXTURE_INDEX);
        this._context.bindTexture(this._priorityColorTexture);
        this._context.bindVao(this._visibilityVao);
        this._context.drawMesh(0, this._numberOfCollisionSamplers, 0 /* POINTS */);
        const visibilityProgram = this._visibilityProgram;
        this._context.bindProgram(visibilityProgram);
        visibilityProgram.setIntScalarUniform('priority', PRIORITY_TEXTURE_INDEX);
        visibilityProgram.setIntScalarUniform('reversePriority', REVERSE_PRIORITY_TEXTURE_INDEX);
        visibilityProgram.setIntScalarUniform('prevVisibility', PREV_VISIBILITY_TEXTURE_INDEX);
        visibilityProgram.setVector2Uniform('priorityPxSize', this._priorityPxSizeUniform);
        visibilityProgram.setVector2Uniform('outputHalfPxSize', OUTPUT_HALF_PX_SIZE);
        this._context.bindTextureUnit(PRIORITY_TEXTURE_INDEX);
        this._context.bindTexture(this._priorityColorTexture);
        this._context.bindTextureUnit(REVERSE_PRIORITY_TEXTURE_INDEX);
        this._context.bindTexture(this._reversePriorityColorTexture);
        this._context.bindTextureUnit(PREV_VISIBILITY_TEXTURE_INDEX);
        this._context.bindTexture(this._prevVisibilityTexture);
        this._context.bindVao(this._visibilityVao);
        this._context.drawMesh(0, this._numberOfCollisionSamplers, 0 /* POINTS */);
        // render final picture
        for (const renderer of this._renderers) {
            renderer.renderVisible(target, uniforms, this._currentVisibilityTexture);
        }
        // swap visibility buffers
        const buffer = this._currentVisibilityBuffer;
        this._currentVisibilityBuffer = this._prevVisibilityBuffer;
        this._prevVisibilityBuffer = buffer;
        const texture = this._currentVisibilityTexture;
        this._currentVisibilityTexture = this._prevVisibilityTexture;
        this._prevVisibilityTexture = texture;
    }
    destroy() {
        this._destroyGridResources();
        this._currentVisibilityTexture.destroy();
        this._currentVisibilityBuffer.destroy();
        this._prevVisibilityTexture.destroy();
        this._prevVisibilityBuffer.destroy();
        this._visibilityProgram.destroy();
        this._fullOverlapVisibilityProgram.destroy();
    }
    _destroyGridResources() {
        this._depthBuffer.destroy();
        this._priorityColorTexture.destroy();
        this._reversePriorityColorTexture.destroy();
        this._priorityColorBuffer.destroy();
        this._reversePriorityColorBuffer.destroy();
        this._vertexBuffer.destroy();
        this._visibilityVao.destroy();
    }
    _onTargetSizeChanged(width, height) {
        if (this._depthBuffer) {
            this._destroyGridResources();
        }
        const gridPrecisionTargetPx = GRID_PRECISION_PX * window.devicePixelRatio;
        const gridWidth = Math.ceil(width / gridPrecisionTargetPx);
        const gridHeight = Math.ceil(height / gridPrecisionTargetPx);
        this._depthBuffer = this._context.createRenderbuffer(gridWidth, gridHeight, 34041 /* DEPTH_STENCIL */);
        this._priorityColorTexture = this._context.createEmpty2DTexture(gridWidth, gridHeight, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._reversePriorityColorTexture = this._context.createEmpty2DTexture(gridWidth, gridHeight, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._priorityColorBuffer = this._context.createFramebuffer({
            color: this._priorityColorTexture,
            depthStencil: this._depthBuffer
        });
        this._reversePriorityColorBuffer = this._context.createFramebuffer({
            color: this._reversePriorityColorTexture,
            depthStencil: this._depthBuffer
        });
        const writer = new __WEBPACK_IMPORTED_MODULE_8__collision_sampler_buffer_writer__["b" /* default */](gridWidth, gridHeight);
        this._vertexBuffer = this._context.createVertexBuffer(writer.data.byteLength);
        this._visibilityVao = this._context.createVao(__WEBPACK_IMPORTED_MODULE_8__collision_sampler_buffer_writer__["a" /* ATTRIBUTE_MAPPING */], this._vertexBuffer, null);
        this._numberOfCollisionSamplers = writer.numberOfSamplers;
        this._context.uploadDataToBuffer(this._vertexBuffer, writer.data);
        this._prevTargetSize.width = width;
        this._prevTargetSize.height = height;
        this._priorityPxSizeUniform.x = 1.0 / gridWidth;
        this._priorityPxSizeUniform.y = 1.0 / gridHeight;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CollidingPrimitivesRenderer;



/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec2 uv;\n\nuniform sampler2D priority;\nuniform sampler2D reversePriority;\nuniform sampler2D prevVisibility;\nuniform vec2 priorityPxSize;\nuniform vec2 outputHalfPxSize;\n\nvarying vec4 color;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\nconst vec4 EMPTY_CELL = vec4(0, 0, 0, 1);\nconst vec4 VISIBLE = vec4(0, 0, 0, 1);\nconst vec4 INVISIBLE = vec4(1, 1, 1, 1);\nconst vec4 INVISIBLE_BY_COLLISION = vec4(1, 0, 1, 1);\n\nvec4 calculateOutputPosition(vec2 objectId) {\n    return vec4((objectId + outputHalfPxSize) * 2.0 - 1.0, 0, 1);\n}\n\nvoid main() {\n    vec4 priorityValue = texture2D(priority, uv);\n\n    // discard sample by default, it will be rewriten to something meaningfull if collision is found\n    gl_Position = DISCARD_POSITION;\n\n    if (priorityValue == EMPTY_CELL) {\n        return;\n    }\n\n    vec2 neighbours[8];\n    neighbours[0] = vec2( 0,  1); // top\n    neighbours[1] = vec2( 0, -1); // bottom\n    neighbours[2] = vec2(-1,  0); // left\n    neighbours[3] = vec2( 1,  0); // right\n    neighbours[4] = vec2(-1, -1); // bottom-left\n    neighbours[5] = vec2(-1,  1); // top-left\n    neighbours[6] = vec2( 1, -1); // bottom-left\n    neighbours[7] = vec2( 1,  1); // top-right\n\n    gl_PointSize = 1.0;\n\n    int messFactor = 0;\n    vec4 prevVisibilityCache;\n    bool prevVisibilityCached = false;\n    for (int i = 0; i < 8; i++) {\n        vec2 neighbourOffset = neighbours[i];\n        vec2 neighbourCoords = uv + neighbourOffset * priorityPxSize;\n        vec4 neighbourPriorityValue = texture2D(priority, neighbourCoords);\n\n        if (neighbourPriorityValue == EMPTY_CELL) {\n            continue;\n        }\n\n        if (priorityValue != neighbourPriorityValue) {\n            vec4 prevVisibilityValue = prevVisibilityCache;\n            if (!prevVisibilityCached) {\n                prevVisibilityCache = texture2D(prevVisibility, priorityValue.rg + outputHalfPxSize);\n                prevVisibilityValue = prevVisibilityCache;\n                prevVisibilityCached = true;\n            }\n\n            // hide the object if it is close to another one and it was hidden previously\n            if (prevVisibilityValue == INVISIBLE_BY_COLLISION) {\n                gl_Position = calculateOutputPosition(priorityValue.rg);\n                color = INVISIBLE_BY_COLLISION;\n                return;\n            }\n\n            // check if it is overlapped by a neighbour\n            vec4 reverseNeighbourPriorityValue = texture2D(reversePriority, neighbourCoords);\n            if (reverseNeighbourPriorityValue == priorityValue) {\n                gl_Position = calculateOutputPosition(priorityValue.rg);\n                color = INVISIBLE_BY_COLLISION;\n                return;\n            }\n\n            // count overlapped neighbours to assess the degree of \"mess\" around\n            if (reverseNeighbourPriorityValue != neighbourPriorityValue) {\n                messFactor++;\n            }\n        }\n    }\n\n    // hide the object if there is \"mess\" around it (when there are too many colliding objects overlap each other)\n    if(messFactor > 4 || (messFactor > 0 && prevVisibilityCache.x == 1.0)) {\n        gl_Position = calculateOutputPosition(priorityValue.rg);\n        color = INVISIBLE_BY_COLLISION;\n        return;\n    }\n\n}\n"

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n\nvarying vec4 color;\n\nvoid main() {\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec2 uv;\n\nuniform sampler2D priority;\nuniform vec2 priorityPxSize;\nuniform vec2 outputHalfPxSize;\n\nvarying vec4 color;\n\nconst vec4 EMPTY_CELL = vec4(0, 0, 0, 1);\nconst vec4 VISIBLE = vec4(0, 0, 0, 1);\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nvoid main() {\n    vec2 coords = uv + priorityPxSize / 2.0;\n    vec4 priorityValue = texture2D(priority, coords);\n\n    if (priorityValue != EMPTY_CELL) {\n        gl_Position = vec4((priorityValue.rg + outputHalfPxSize) * 2.0 - 1.0, 0, 1);\n        gl_PointSize = 1.0;\n        color = VISIBLE;\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__attrib_mapping__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_gputypes__ = __webpack_require__(12);



const ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = ATTRIBUTE_MAPPING;

/**
 * Writes overlap samplers data to vertex buffer, the number of vertices (samplers) is equal to "width x height".
 */
class CollisionSamplerBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor(width, height) {
        const cols = width * 2;
        const rows = height;
        const numberOfSamplers = cols * rows;
        super(ATTRIBUTE_MAPPING.vertexByteSize, numberOfSamplers, undefined, 0);
        // staggered grid is created: every odd col (number of cols is doubled) is shifted half cell up,
        // thus we can guarantee that everything larger then a cell in both dimensions will be sampled.
        const colStep = Object(__WEBPACK_IMPORTED_MODULE_2__util_gputypes__["a" /* floatToUint16 */])(1.0 / cols);
        const rowStep = Object(__WEBPACK_IMPORTED_MODULE_2__util_gputypes__["a" /* floatToUint16 */])(1.0 / rows);
        const rowHalfStep = rowStep / 2;
        for (let i = 0; i < cols; i++) {
            const col = i * colStep;
            let row = (i % 2 === 0) ? 0.0 : rowHalfStep;
            for (let j = 0; j < rows; j++, row += rowStep) {
                this.writeVertex(col, row);
            }
        }
        this.data = this.getBuffers()[0].vertexBuffer;
        this.numberOfSamplers = numberOfSamplers;
    }
    /**
     * @param u horizontal texture coordinate as uint16 number.
     * @param v vertical texture coordinate as uint16 number.
     */
    writeVertex(u, v) {
        this._writeHalfWords(u, v);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = CollisionSamplerBufferWriter;



/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export swap */
/* unused harmony export reverse */
/* unused harmony export rotate */
/* unused harmony export copy */
/* unused harmony export shuffle */
/* harmony export (immutable) */ __webpack_exports__["a"] = zip;
/* unused harmony export compare */
/**
 * Swaps two values in an array.
 *
 * @param array The array.
 * @param i Index of a value to be swapped.
 * @param j Index of a value to be swapped.
 */
function swap(array, i, j) {
    const t = array[i];
    array[i] = array[j];
    array[j] = t;
}
/**
 * Reverses order of elements in a range in an array.
 *
 * @param array The array.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function reverse(array, start = 0, end = array.length) {
    for (let i = start, j = end - 1; i < j; ++i, --j) {
        swap(array, i, j);
    }
}
/**
 * Rotates a range of elements in an array by given amount.
 *
 * @param array The array.
 * @param amount The amount.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function rotate(array, amount = 1, start = 0, end = array.length) {
    reverse(array, start, end);
    reverse(array, start, start + amount);
    reverse(array, start + amount, end);
}
/**
 * Copies a range of elements from a source array to a range in a destination
 * array.
 *
 * @param src The source array.
 * @param dst The destination array.
 * @param srcStart The start of the source range.
 * @param srcStart The start of the source range.
 * @param dstStart The start of the destination range.
 */
function copy(src, dst, srcStart = 0, srcEnd = src.length, dstStart = 0) {
    for (let i = srcStart, j = dstStart; i < srcEnd; ++i, ++j) {
        dst[j] = src[i];
    }
}
/**
 * Shuffles randomly a range of elements in an array.
 *
 * @param array The array.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function shuffle(array, start = 0, end = array.length) {
    for (let i = start, j = i + 1; i < end; ++i, ++j) {
        swap(array, i, j + (Math.random() * (end - j) | 0));
    }
}
function zip(ts, us, zipper = (t, u) => [t, u]) {
    const l = Math.min(ts.length, us.length);
    const vs = new Array(l);
    for (let i = 0; i < l; ++i) {
        vs[i] = zipper(ts[i], us[i]);
    }
    return vs;
}
/**
 * Compares two arrays lexicographically. The order is specified be the comparator parameter.
 *
 * @param comparator Elements comparator with standard signature.
 * @param a The first array to compare.
 * @param b The second array to compare.
 * @returns 0 if all elements and lengths are equal,
 *      negative number if the first element is less then the second (lexicographically),
 *      positive number if the first element is greater then the second,
 *      if all the elements are equal the lengths are being compared.
 */
function compare(comparator, a, b) {
    const length = Math.min(a.length, b.length);
    for (let i = 0; i < length; i++) {
        const result = comparator(a[i], b[i]);
        if (result) {
            return result;
        }
    }
    return a.length - b.length;
}


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_icon_vert__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_icon_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_icon_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_icon_frag__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_icon_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_icon_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__image_image_renderer__ = __webpack_require__(22);



/**
 * Renderer of icon primitives.
 */
class IconRenderer extends __WEBPACK_IMPORTED_MODULE_2__image_image_renderer__["a" /* default */] {
    constructor(context) {
        super(context, context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_icon_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_icon_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */
            }
        }));
    }
    _bindProgram(program, uniforms) {
        super._bindProgram(program, uniforms);
        program.setVector2Uniform('pixelSize', uniforms.pixelSize);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IconRenderer;



/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\n\nvarying vec2 uv;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main() {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n    position.xyz /= position.w;\n    position.w = 1.0;\n\n    gl_Position = position + vec4(vertexDisplacement * pixelSize, 0.0, 0.0);\n\n    uv = vertexUV;\n}\n"

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(atlas, uv / atlasSize);\n}\n"

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexUV;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec2 uv;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main() {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n\n    gl_Position = position;\n\n    uv = vertexUV;\n}\n"

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(atlas, uv / atlasSize);\n\n    if (gl_FragColor.a == 0.0) {\n        discard;\n    }\n\n}\n"

/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_renderer__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_model_vert__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_model_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_model_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shader_model_frag__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shader_model_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__shader_model_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__overlay_overlay_renderer__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__memory_count_vertices__ = __webpack_require__(3);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_1__state__["b" /* default */]({
    depthTest: true
});
/**
 * Renderer of models. It renders models into a texture with depth test and then this texture into the render target.
 * It allows to show only the top facets of semi-transparent objects without exposing their inner structure.
 */
class ModelRenderer extends __WEBPACK_IMPORTED_MODULE_0__primitive_renderer__["a" /* default */] {
    constructor(context) {
        super(context, RENDER_STATE, context.createProgram(__WEBPACK_IMPORTED_MODULE_2__shader_model_vert___default.a, __WEBPACK_IMPORTED_MODULE_3__shader_model_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexHeight: 3 /* HEIGHT */,
                vertexColor: 7 /* COLOR */
            }
        }));
        this._outputSize = { width: -1, height: -1 };
        this._overlayRenderer = new __WEBPACK_IMPORTED_MODULE_4__overlay_overlay_renderer__["a" /* default */](context);
    }
    render(target, uniforms) {
        this._syncOutputBuffer(target);
        super.render(target, uniforms);
        // copy into the final target
        this._overlayRenderer.render(target, this._outputTexture);
    }
    destroy() {
        super.destroy();
        this._overlayRenderer.destroy();
        this._outputTexture.destroy();
        this._outputDepthBuffer.destroy();
        this._outputBuffer.destroy();
    }
    _renderPrimitives(primitives) {
        for (const memoryBatch of this.batchPrimitives(primitives)) {
            this._context.bindVao(memoryBatch.page.vao);
            this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(__WEBPACK_IMPORTED_MODULE_5__memory_count_vertices__["a" /* countIndices */])(memoryBatch.indexByteLength, memoryBatch.page.indexType));
        }
    }
    _syncOutputBuffer(target) {
        // make sure the intermediate texture fits the output target
        if (this._outputSize.width !== target.getWidth() || this._outputSize.height !== target.getHeight()) {
            if (this._outputTexture || this._outputDepthBuffer || this._outputBuffer) {
                this._outputTexture.destroy();
                this._outputDepthBuffer.destroy();
                this._outputBuffer.destroy();
            }
            this._outputSize = { width: target.getWidth(), height: target.getHeight() };
            this._outputTexture = this._context.createEmpty2DTexture(this._outputSize.width, this._outputSize.height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
            this._outputDepthBuffer = this._context.createRenderbuffer(this._outputSize.width, this._outputSize.height, 34041 /* DEPTH_STENCIL */);
            this._outputBuffer = this._context.createFramebuffer({
                color: this._outputTexture,
                depthStencil: this._outputDepthBuffer
            });
        }
    }
    /**
     * Overridden _bindRenderTarget() to bind intermediate render target to render models into and
     * later put its content into the final target.
     */
    _bindRenderTarget(_target) {
        this._context.bindRenderTarget(this._outputBuffer);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */ | 256 /* DEPTH_BUFFER_BIT */);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ModelRenderer;



/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec3 vertexPosHigh;\nattribute vec3 vertexPosLow;\nattribute float vertexHeight;\nattribute vec4 vertexColor;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec4 globalPos;\nvarying vec4 diffuseColor;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    globalPos = vec4(\n        YV_H * (vertexPosHigh.xy - lookAtHigh) + YV_L * (vertexPosLow.xy - lookAtLow),\n        vertexHeight,\n        1\n    );\n\n    gl_Position = viewProjMatrix * globalPos;\n    diffuseColor = vertexColor;\n}\n"

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#extension GL_OES_standard_derivatives : require\n\nprecision mediump float;\n\nvarying vec4 diffuseColor;\nvarying vec4 globalPos;\n\nconst vec3 LIGHT_DIRECTION = normalize(vec3(0.5, 0.5, 1.0));\nconst float LIGHT_INTENSITY = 0.4;\nconst float AMBIENT_LIGHT_INTENSITY = 1.0 - LIGHT_INTENSITY;\n\nvoid main(void) {\n    vec3 pos = globalPos.xyz;\n\n    vec3 dxpos = normalize(dFdx(pos));\n    vec3 dypos = normalize(dFdy(pos));\n    vec3 normal = normalize(cross(dxpos, dypos));\n\n    float diffuseIntensity = AMBIENT_LIGHT_INTENSITY + LIGHT_INTENSITY * (dot(normal, LIGHT_DIRECTION) + 1.) / 2.;\n    vec3 color = diffuseColor.rgb * diffuseIntensity;\n    gl_FragColor = vec4(color, diffuseColor.a);\n}\n"

/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_overlay_vert__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_overlay_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_overlay_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_overlay_frag__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_overlay_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_overlay_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__state__ = __webpack_require__(0);



const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_2__state__["b" /* default */](__WEBPACK_IMPORTED_MODULE_2__state__["a" /* BLEND_OVER_RENDER_STATE */]);
/**
 * Renders a texture into a render target with OVER compositing. The texture will completely overlay the target, i.e.
 * it is stretched/shrinked to fit the target width/height, so ideally they should have the same dimensions.
 */
class OverlayRenderer {
    constructor(context) {
        this._context = context;
        this._program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_overlay_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_overlay_frag___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */,
                vertexUV: 4 /* UV */
            }
        });
    }
    render(target, texture) {
        this._context.bindRenderTarget(target);
        this._context.bindRenderState(RENDER_STATE);
        this._context.bindProgram(this._program);
        this._context.bindTexture(texture);
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
    destroy() {
        this._program.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = OverlayRenderer;



/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n\nattribute vec2 vertexPosition;\nattribute vec2 vertexUV;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_Position = vec4(vertexPosition, 0, 1);\n    uv = vertexUV;\n}\n"

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n\nuniform sampler2D texture;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(texture, uv);\n}\n"

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector3__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_fxaa_frag__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_fxaa_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__shaders_fxaa_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__shaders_quad_vert__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__shaders_quad_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__shaders_quad_vert__);





const FXAA_POSTPROCESSING_STATE = new __WEBPACK_IMPORTED_MODULE_2__state__["b" /* default */]({
    depthMask: false,
    depthTest: false
});
/**
 * Renderer of FXAA postprocessing pass.
 */
class FxaaRenderer {
    constructor(context) {
        this._context = context;
        this._program = context.createProgram(__WEBPACK_IMPORTED_MODULE_4__shaders_quad_vert___default.a, __WEBPACK_IMPORTED_MODULE_3__shaders_fxaa_frag___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */
            }
        });
        this._pixelSize = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* create */](0, 0);
        this._fxaaQuality = __WEBPACK_IMPORTED_MODULE_1__math_vector3__["e" /* create */](0, 0, 0);
        this.setParams({});
    }
    destroy() {
        this._program.destroy();
    }
    render(target, sourceColorBuffer) {
        this._updateFrameUniformState(target);
        const context = this._context;
        context.bindRenderTarget(target);
        context.bindProgram(this._program);
        context.bindRenderState(FXAA_POSTPROCESSING_STATE);
        context.bindTextureUnit(0);
        context.bindTexture(sourceColorBuffer);
        this._program.setIntScalarUniform('texture', 0);
        this._program.setVector2Uniform('pixelSize', this._pixelSize);
        this._program.setVector3Uniform('fxaaQuality', this._fxaaQuality);
        this._program.setScalarUniform('dpr', window.devicePixelRatio);
        context.bindQuadVao();
        context.drawQuad();
    }
    /**
     * Set FXAA quality parameters.
     */
    setParams({ subpix = 0.75, edgeThreshold = 0.063, edgeThresholdMin = 0.0625 }) {
        this._fxaaQuality.x = subpix;
        this._fxaaQuality.y = edgeThreshold;
        this._fxaaQuality.z = edgeThresholdMin;
    }
    _updateFrameUniformState(target) {
        this._pixelSize.x = 1 / target.getWidth();
        this._pixelSize.y = 1 / target.getHeight();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FxaaRenderer;



/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n\nuniform vec2 pixelSize;\nuniform vec3 fxaaQuality;\nuniform sampler2D texture;\nuniform float dpr;\n\nconst float EPSILON = 0.0001;\n\nfloat luma(vec4 rgba) {\n    return dot(rgba.xyz, vec3(0.299, 0.587, 0.114));\n}\n\nvec4 fxaa(\n    vec2 pos,\n    sampler2D tex,\n    vec2 fxaaQualityRcpFrame,\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    float fxaaQualitySubpix,\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    float fxaaQualityEdgeThreshold,\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    float fxaaQualityEdgeThresholdMin\n) {\n    vec2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    vec4 rgbyM = texture2D(tex, posM);\n    float lumaM = luma(rgbyM);\n\n    float lumaS = luma(texture2D(tex, posM + vec2( 0, 1) * fxaaQualityRcpFrame.xy));\n    float lumaE = luma(texture2D(tex, posM + vec2( 1, 0) * fxaaQualityRcpFrame.xy));\n    float lumaN = luma(texture2D(tex, posM + vec2( 0,-1) * fxaaQualityRcpFrame.xy));\n    float lumaW = luma(texture2D(tex, posM + vec2(-1, 0) * fxaaQualityRcpFrame.xy));\n\n    float maxSM = max(lumaS, lumaM);\n    float minSM = min(lumaS, lumaM);\n    float maxESM = max(lumaE, maxSM);\n    float minESM = min(lumaE, minSM);\n    float maxWN = max(lumaN, lumaW);\n    float minWN = min(lumaN, lumaW);\n    float rangeMax = max(maxWN, maxESM);\n    float rangeMin = min(minWN, minESM);\n    float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    float range = rangeMax - rangeMin;\n    float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    bool earlyExit = range < rangeMaxClamped;\n\n    if (earlyExit)\n        return rgbyM;\n\n    float lumaNW = luma(texture2D(tex, posM + vec2(-1,-1) * fxaaQualityRcpFrame.xy));\n    float lumaSE = luma(texture2D(tex, posM + vec2( 1, 1) * fxaaQualityRcpFrame.xy));\n    float lumaNE = luma(texture2D(tex, posM + vec2( 1,-1) * fxaaQualityRcpFrame.xy));\n    float lumaSW = luma(texture2D(tex, posM + vec2(-1, 1) * fxaaQualityRcpFrame.xy));\n\n    float lumaNS = lumaN + lumaS;\n    float lumaWE = lumaW + lumaE;\n    float subpixRcpRange = 1.0/range;\n    float subpixNSWE = lumaNS + lumaWE;\n    float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    float edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\n    float lumaNESE = lumaNE + lumaSE;\n    float lumaNWNE = lumaNW + lumaNE;\n    float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\n    float lumaNWSW = lumaNW + lumaSW;\n    float lumaSWSE = lumaSW + lumaSE;\n    float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    float edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    float edgeVert = abs(edgeVert3) + edgeVert4;\n\n    float subpixNWSWNESE = lumaNWSW + lumaNESE;\n    float lengthSign = fxaaQualityRcpFrame.x;\n    bool horzSpan = edgeHorz >= edgeVert;\n    float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\n    if (horzSpan) {\n        lengthSign = fxaaQualityRcpFrame.y;\n    } else {\n        lumaN = lumaW;\n        lumaS = lumaE;\n    }\n    float subpixB = (subpixA * (1.0/12.0)) - lumaM;\n\n    float gradientN = lumaN - lumaM;\n    float gradientS = lumaS - lumaM;\n    float lumaNN = lumaN + lumaM;\n    float lumaSS = lumaS + lumaM;\n    bool pairN = abs(gradientN) >= abs(gradientS);\n    float gradient = max(abs(gradientN), abs(gradientS));\n    if (pairN) {\n        lengthSign = -lengthSign;\n    } else {\n        lumaNN = lumaSS;\n    }\n    float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\n\n    vec2 posB = posM;\n    vec2 offNP;\n\n    vec2 offHM;\n    if (horzSpan) {\n        offNP = vec2(fxaaQualityRcpFrame.x, 0.0);\n        offHM = vec2(0.0, lengthSign);\n    } else {\n        offNP = vec2(0.0, fxaaQualityRcpFrame.y);\n        offHM = vec2(lengthSign, 0.0);\n    }\n\n    vec2 posN = posB - offNP * 2.;\n    vec2 posP = posB + offNP * 2.;\n\n    float subpixD = ((-2.0)*subpixC) + 3.0;\n    float lumaEndN = luma(\n        mix(\n            texture2D(tex, posN),\n            texture2D(tex, posN + offHM),\n            0.5\n        )\n    );\n    float subpixE = subpixC * subpixC;\n    float lumaEndP = luma(\n        mix(\n            texture2D(tex, posP),\n            texture2D(tex, posP + offHM),\n            0.5\n        )\n    );\n\n    float gradientScaled = gradient * 0.25;\n    float lumaMM = lumaM - lumaNN * 0.5;\n    float subpixF = subpixD * subpixE;\n    bool lumaMLTZero = lumaMM < 0.0;\n\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    bool doneN = abs(lumaEndN) >= gradientScaled;\n    bool doneP = abs(lumaEndP) >= gradientScaled;\n    if (!doneN) {\n        posN -= offNP * 3.0;\n    }\n    bool doneNP = (!doneN) || (!doneP);\n    if (!doneP) {\n        posP += offNP * 3.0;\n    }\n\n    if (doneNP) {\n        if (!doneN) {\n            lumaEndN = luma(\n                mix(\n                    texture2D(tex, posN),\n                    texture2D(tex, posN + offHM),\n                    0.5\n                )\n            );\n            lumaEndN = lumaEndN - lumaNN * 0.5;\n        }\n        if (!doneP) {\n            lumaEndP = luma(\n                mix(\n                    texture2D(tex, posP.xy),\n                    texture2D(tex, posP.xy + offHM),\n                    0.5\n                )\n            );\n            lumaEndP = lumaEndP - lumaNN * 0.5;\n        }\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if (!doneN) {\n            posN -= offNP * 12.0;\n        }\n        if (!doneP) {\n            posP += offNP * 12.0;\n        }\n    }\n    float dstN = posM.x - posN.x;\n    float dstP = posP.x - posM.x;\n    if (!horzSpan) {\n        dstN = posM.y - posN.y;\n        dstP = posP.y - posM.y;\n    }\n    bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    float spanLength = (dstP + dstN);\n    bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    float spanLengthRcp = 1.0/spanLength;\n    bool directionN = dstN < dstP;\n    float dst = min(dstN, dstP);\n    bool goodSpan = directionN ? goodSpanN : goodSpanP;\n    float subpixG = subpixF * subpixF;\n    float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    float subpixH = subpixG * fxaaQualitySubpix;\n    float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    vec4 color;\n    float factor = pixelOffsetSubpix;\n    if (horzSpan) {\n        color = mix(\n            texture2D(tex, posM),\n            texture2D(tex, posM + vec2(0.0, lengthSign)),\n            factor\n        );\n    } else {\n        color = mix(\n            texture2D(tex, posM),\n            texture2D(tex, posM + vec2(lengthSign, 0.0)),\n            factor\n        );\n    }\n\n    return color;\n}\n\n// It is a default background pattern.\n// Colors vec3(233./255.) and vec3(250./255.) are taken with color picker tools.\nlowp vec3 pattern(in vec2 coord) {\n    vec2 uv = mod(coord, 16.) - 8.;\n\n    return mix(vec3(233./255.), vec3(250./255.), smoothstep(0.5, 1.5, length(uv)));\n}\n\nvoid main() {\n    vec2 pos = gl_FragCoord.xy * pixelSize;\n    vec4 color = fxaa(\n        pos,\n        texture,\n        pixelSize,\n        fxaaQuality[0],\n        fxaaQuality[1],\n        fxaaQuality[2]\n    );\n\n    vec3 backgroundColor = pattern(gl_FragCoord.xy / dpr);\n    // If color.a is less than one, then the color has been blended with a black background before.\n    // An original color of transparent objects is vec4(color.xyz / color.a, color.a).\n    // We have to blend an original color with background pattern.\n    // color.a can be too close to zero. Check it.\n    if (color.a > EPSILON) {\n        color.xyz /= color.a;\n    }\n    gl_FragColor = vec4(mix(backgroundColor, color.xyz, color.a), 1.0);\n}\n"

/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_scalar__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_matrix4__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector3__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__postprocess_renderer__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__shaders_quad_vert__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__shaders_quad_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__shaders_quad_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__shaders_fill_frag__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__shaders_fill_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__shaders_fill_frag__);







const SSAA_ACCUMULATE_RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_4__state__["b" /* default */]({
    blend: true,
    blendFuncSrcRgb: 1 /* ONE */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
});
// Pattern is taken from https://msdn.microsoft.com/en-us/library/ff476218(v=vs.85).aspx
const SSAA_JITTER_VECTORS = [
    [
        [0, 0]
    ],
    [
        [4, 4], [-4, -4]
    ],
    [
        [-2, -6], [6, -2], [-6, 2], [2, 6]
    ],
    [
        [1, -3], [-1, 3], [5, 1], [-3, -5], [-5, -5], [-7, -1], [3, 7], [7, -7]
    ],
    [
        [1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5],
        [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]
    ]
];
/**
 * Renderer of SSAA.
 */
class SsaaRenderer {
    constructor(context) {
        this._context = context;
        this._accumulateProgram = context.createProgram(__WEBPACK_IMPORTED_MODULE_5__shaders_quad_vert___default.a, __WEBPACK_IMPORTED_MODULE_6__shaders_fill_frag___default.a, {
            defines: {
                YV_OPACITY: 1,
                YV_TEXTURE_FILL: 1
            },
            attribMap: {
                vertexPosition: 0 /* POSITION */,
                vertexUv: 4 /* UV */
            }
        });
        this._copyRenderer = new __WEBPACK_IMPORTED_MODULE_3__postprocess_renderer__["b" /* default */](context, __WEBPACK_IMPORTED_MODULE_3__postprocess_renderer__["a" /* PostprocessType */].COPY);
        this._width = NaN;
        this._height = NaN;
        this.qualityLevel = 2;
        this.reset();
    }
    destroy() {
        this._destroyInternalRenderTargets();
        this._accumulateProgram.destroy();
        this._copyRenderer.destroy();
    }
    reset() {
        this._step = 0;
    }
    render(contentRenderer, renderTarget, globalUniforms, type) {
        const width = renderTarget.getWidth();
        const height = renderTarget.getHeight();
        if (this._width !== width || this._height !== height) {
            if (this._areRenderTargetsInitialized()) {
                this._destroyInternalRenderTargets();
            }
            this._initInternalRenderTargets(renderTarget);
        }
        if (type == 0 /* ONE_FRAME */) {
            this.reset();
            while (!this.isComplete) {
                this._renderStep(contentRenderer, globalUniforms);
            }
        }
        else {
            this._renderStep(contentRenderer, globalUniforms);
        }
        this._copyRenderer.render(renderTarget, this._accumColorBuffer);
    }
    get isComplete() {
        return this._step >= this._steps_count;
    }
    /**
     * It is a number in range of 0 to 4, which defines quality of SSAA
     */
    set qualityLevel(level) {
        this._level = Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(level, 0, 4);
        this._steps_count = Math.pow(2, this._level);
        this.reset();
    }
    _renderStep(contentRenderer, globalUniforms) {
        // jitter viewProjMatrix of the globalUniforms
        const viewProjMatrix = globalUniforms.viewProjMatrix;
        const copyViewProjMatrix = __WEBPACK_IMPORTED_MODULE_1__math_matrix4__["c" /* copy */](viewProjMatrix);
        this._jitterMatrix(viewProjMatrix, this._width, this._height, viewProjMatrix);
        if (this._step === 0) {
            contentRenderer(this._accumRenderTarget, globalUniforms);
        }
        else if (this._step < this._steps_count) {
            contentRenderer(this._sampleRenderTarget, globalUniforms);
            this._accumulate();
        }
        // restore viewProjMatrix of the globalUniforms
        __WEBPACK_IMPORTED_MODULE_1__math_matrix4__["c" /* copy */](copyViewProjMatrix, viewProjMatrix);
        ++this._step;
    }
    _jitterMatrix(source, width, height, dest) {
        const jitterId = this._step % this._steps_count;
        const offset = __WEBPACK_IMPORTED_MODULE_2__math_vector3__["e" /* create */](SSAA_JITTER_VECTORS[this._level][jitterId][0] / width, SSAA_JITTER_VECTORS[this._level][jitterId][1] / height, 0);
        // offset is in [-1 / width, 1 / width] x [-1 / height, 1 / height] x {0}
        __WEBPACK_IMPORTED_MODULE_2__math_vector3__["i" /* muln */](offset, 1 / 8, offset);
        __WEBPACK_IMPORTED_MODULE_1__math_matrix4__["g" /* translate */](source, offset, dest);
        return dest;
    }
    _accumulate() {
        const context = this._context;
        const opacity = 1 / Math.min(this._step + 1, this._steps_count);
        context.bindRenderTarget(this._accumRenderTarget);
        context.bindRenderState(SSAA_ACCUMULATE_RENDER_STATE);
        context.bindProgram(this._accumulateProgram);
        context.bindTextureUnit(0);
        context.bindTexture(this._sampleColorBuffer);
        this._accumulateProgram.setIntScalarUniform('texture', 0);
        this._accumulateProgram.setScalarUniform('opacity', opacity);
        context.bindQuadVao();
        context.drawQuad();
    }
    _areRenderTargetsInitialized() {
        return !!this._accumColorBuffer;
    }
    _initInternalRenderTargets(renderTarget) {
        const context = this._context;
        const targetWidth = this._width = renderTarget.getWidth();
        const targetHeight = this._height = renderTarget.getHeight();
        const sampleColorBuffer = this._sampleColorBuffer =
            context.createEmpty2DTexture(targetWidth, targetHeight, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        const accumColorBuffer = this._accumColorBuffer =
            context.createEmpty2DTexture(targetWidth, targetHeight, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._sampleRenderTarget = context.createFramebuffer({
            color: sampleColorBuffer
        });
        this._accumRenderTarget = context.createFramebuffer({
            color: accumColorBuffer
        });
    }
    _destroyInternalRenderTargets() {
        this._accumRenderTarget.destroy();
        this._sampleRenderTarget.destroy();
        this._accumColorBuffer.destroy();
        this._sampleColorBuffer.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = SsaaRenderer;



/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec4 vertexColor;\nattribute float vertexWidth;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform float worldToPxFactor;\n\nvarying lowp vec4 color;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow) +\n                worldToPxFactor * vertexWidth * vertexDisplacement,\n        0,\n        1\n    );\n\n    position.xy /= position.w;\n    position.z = vertexZIndex;\n    position.w = 1.0;\n\n    gl_Position = position;\n\n    color = vertexColor;\n}\n"

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_textured_polyline_vert__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_textured_polyline_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_textured_polyline_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_textured_polyline_frag__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_textured_polyline_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_textured_polyline_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__base_polyline_renderer__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__memory_count_vertices__ = __webpack_require__(3);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_0__state__["b" /* default */](__WEBPACK_IMPORTED_MODULE_0__state__["a" /* BLEND_OVER_RENDER_STATE */], {
    depthTest: true,
    depthMask: false,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Renderer of polyline primitives.
 */
class TexturedPolylineRenderer extends __WEBPACK_IMPORTED_MODULE_4__base_polyline_renderer__["a" /* default */] {
    constructor(context) {
        super(context, RENDER_STATE, context.createProgram(__WEBPACK_IMPORTED_MODULE_1__shader_textured_polyline_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shader_textured_polyline_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */,
                vertexZIndex: 9 /* PRIORITY */,
                vertexWidth: 11 /* AUX */,
                vertexPattern: 12 /* AUX1 */
            }
        }));
    }
    _renderPrimitives(primitives) {
        for (const memoryBatch of this.batchPrimitives(primitives)) {
            const atlas = memoryBatch.firstPrimitive.atlas;
            if (atlas.isDirty) {
                atlas.syncTexture();
            }
            this._program.setIntScalarUniform('atlas', 0);
            this._program.setVector2Uniform('atlasSize', Object(__WEBPACK_IMPORTED_MODULE_3__math_vector2__["e" /* create */])(atlas.width, atlas.height));
            this._context.bindTextureUnit(0);
            this._context.bindTexture(atlas.texture);
            this._context.bindVao(memoryBatch.page.vao);
            this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(__WEBPACK_IMPORTED_MODULE_5__memory_count_vertices__["a" /* countIndices */])(memoryBatch.indexByteLength, memoryBatch.page.indexType));
        }
    }
    _canBatch(a, b) {
        return super._canBatch(a, b) && (a.atlas == b.atlas);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolylineRenderer;



/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\nattribute float vertexWidth;\nattribute vec2 vertexPattern;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform float worldToPxFactor;\n\nvarying vec2 uv;\nvarying float patternLength;\nvarying float length;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow) +\n                worldToPxFactor * vertexWidth * vertexDisplacement,\n        0,\n        1\n    );\n\n    position.xy /= position.w;\n    position.z = vertexZIndex;\n    position.w = 1.0;\n\n    gl_Position = position;\n\n    uv = vertexUV;\n    patternLength = vertexPattern[0];\n    length = vertexPattern[1];\n}\n"

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\nvarying float patternLength;\nvarying float length;\n\nvoid main(void) {\n    vec2 uvAdjusted = vec2(uv.x + mod(length, patternLength), uv.y);\n    gl_FragColor = texture2D(atlas, uvAdjusted / atlasSize);\n}\n"

/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_textured_polygon_vert__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_textured_polygon_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_textured_polygon_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_textured_polygon_frag__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_textured_polygon_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_textured_polygon_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__primitive_renderer__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__memory_count_vertices__ = __webpack_require__(3);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_0__state__["b" /* default */](__WEBPACK_IMPORTED_MODULE_0__state__["a" /* BLEND_OVER_RENDER_STATE */], {
    depthTest: true,
    depthMask: false,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Renderer of polyline primitives.
 */
class TexturedPolygonRenderer extends __WEBPACK_IMPORTED_MODULE_4__primitive_renderer__["a" /* default */] {
    constructor(context) {
        super(context, RENDER_STATE, context.createProgram(__WEBPACK_IMPORTED_MODULE_1__shader_textured_polygon_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shader_textured_polygon_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexUV: 4 /* UV */,
                vertexImageScale: 11 /* AUX */,
                vertexZIndex: 10 /* Z_INDEX */
            }
        }));
    }
    _renderPrimitives(primitives) {
        for (const memoryBatch of this.batchPrimitives(primitives)) {
            const atlas = memoryBatch.firstPrimitive.atlas;
            if (atlas.isDirty) {
                atlas.syncTexture();
            }
            this._program.setIntScalarUniform('atlas', 0);
            this._program.setVector2Uniform('atlasSize', Object(__WEBPACK_IMPORTED_MODULE_3__math_vector2__["e" /* create */])(atlas.width, atlas.height));
            this._context.bindTextureUnit(0);
            this._context.bindTexture(atlas.texture);
            this._context.bindVao(memoryBatch.page.vao);
            this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(__WEBPACK_IMPORTED_MODULE_5__memory_count_vertices__["a" /* countIndices */])(memoryBatch.indexByteLength, memoryBatch.page.indexType));
        }
    }
    _canBatch(a, b) {
        return super._canBatch(a, b) && (a.atlas == b.atlas);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolygonRenderer;



/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec4 vertexUV;\nattribute float vertexImageScale;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec2 uvPosition;\nvarying vec2 textureSize;\nvarying vec2 uvDisplacement;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    uvPosition = vertexUV.xy;\n    textureSize = vertexUV.zw;\n\n    // The same pattern image should match across multiple (usually adjacent) polygons and it should have\n    // stable position realtive to the polygon. Also pattern is repeated at both directions.\n    // To meet these requirements the world is covered (virtually) by a texture of appropriate size (repeated image)\n    // and vertex coordinates are mapped to these texture coordinates (uvDisplacement).\n    // But due to limited precision we've got to work with \"narrow\" floats (as it is done in world position calculation):\n    //   1. calculate how big texture pattern in world coordinates (scaledTextureSize)\n    //   2. find the closest to eye coordinates texture base point (the bottom left point of the pattern)\n    //   3. use vertex position and textureBasePoint vectors to find coordinates in virtual texture\n    //   4. find uv coordinates in real texture using mod operation\n    //\n    // Both textureBasePoint and position are relativelly small vectors so that precision requirements are met,\n    // and correct interpolation of repeated image is possible by using single base point in all vertices.\n\n    vec2 scaledTextureSize = textureSize * vertexImageScale; // texture size in world coordinates\n    vec2 textureBasePoint = mod(YV_H * lookAtHigh, scaledTextureSize) + mod(YV_L * lookAtLow, scaledTextureSize);\n    vec2 position = YV_H * (vertexPosHigh - lookAtHigh) + YV_L * (vertexPosLow - lookAtLow);\n\n    gl_Position = viewProjMatrix * vec4(position, 0, 1);\n    gl_Position.xy /= gl_Position.w;\n    gl_Position.z = vertexZIndex;\n    gl_Position.w = 1.0;\n\n    // convert world coordinates back to teture pixels\n    uvDisplacement = (position + textureBasePoint) / vertexImageScale;\n}\n"

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uvPosition;\nvarying vec2 textureSize;\nvarying vec2 uvDisplacement;\n\nvoid main(void) {\n    vec2 uvAdjusted = vec2(\n        uvPosition.x + mod(uvDisplacement.x, textureSize.x),\n        uvPosition.y + mod(uvDisplacement.y, textureSize.y)\n    );\n\n    gl_FragColor = texture2D(atlas, uvAdjusted / atlasSize);\n}\n"

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec4 vertexColor;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec4 color;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n\n    position.xy /= position.w;\n    position.z = vertexZIndex;\n    position.w = 1.0;\n\n    gl_Position = position;\n\n    color = vertexColor;\n}\n"

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polygon_renderer__ = __webpack_require__(27);


/**
 * Renderer of transparent polygon
 * primitives.
 */
class TransparentPolygonRenderer extends __WEBPACK_IMPORTED_MODULE_1__polygon_renderer__["a" /* default */] {
    constructor(context) {
        super(context, new __WEBPACK_IMPORTED_MODULE_0__state__["b" /* default */](__WEBPACK_IMPORTED_MODULE_1__polygon_renderer__["a" /* default */].DEFAULT_RENDER_STATE_PARAMS, { depthMask: false }, __WEBPACK_IMPORTED_MODULE_0__state__["a" /* BLEND_OVER_RENDER_STATE */]));
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TransparentPolygonRenderer;



/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_matrix4__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector2__ = __webpack_require__(1);


/**
 * Container of global uniforms.
 */
class GlobalFrameUniforms {
    constructor() {
        this.viewProjMatrix = __WEBPACK_IMPORTED_MODULE_0__math_matrix4__["d" /* create */]();
        this.cameraPositions = [];
        this.pixelSize = __WEBPACK_IMPORTED_MODULE_1__math_vector2__["e" /* create */](0, 0);
        this.worldToPxFactor = 0;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = GlobalFrameUniforms;



/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = computeSquaresCoveredByConvexPolygon;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);


/**
 * Container of indexed min/max values with a single update method.
 */
class ExtremumStorage {
    constructor(length) {
        this._mins = new Array(length);
        this._maxs = new Array(length);
        this._mins.fill(Number.POSITIVE_INFINITY);
        this._maxs.fill(Number.NEGATIVE_INFINITY);
    }
    updateValue(index, value) {
        this._mins[index] = Math.min(this._mins[index], value);
        this._maxs[index] = Math.max(this._maxs[index], value);
    }
    *values() {
        const item = { min: 0, max: 0, index: -1 };
        for (let i = 0; i < this._mins.length; i++) {
            item.min = this._mins[i];
            item.max = this._maxs[i];
            item.index = i;
            yield item;
        }
    }
}
/**
 * Squares that are ony touched by a line (with no significant crossing an edge) should not be considered "covered".
 * It happens when a point matches the max coordinate (integer) and this case is handled here.
 */
function floorToCellCoordinate(value, maxValue) {
    return Number.isInteger(value) && maxValue == value ? value - 1 : Math.floor(value);
}
/**
 * Calculates squares covered (at least partially) by a convex polygon.
 *
 * @param points Convex polygon point coordinates (on the grid).
 * @returns List of unit square coordinates.
 */
function computeSquaresCoveredByConvexPolygon(points) {
    const result = [];
    const bbox = Object(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["c" /* computeBBoxForPoints */])(points);
    const minX = Math.floor(bbox.minX);
    const xLength = Math.ceil(bbox.maxX) - minX;
    const extremums = new ExtremumStorage(xLength);
    for (let i = points.length - 1, j = 0; j < points.length; i = j++) {
        let p1 = points[i];
        let p2 = points[j];
        // go from left to right always to not handle the opposite case
        if (p1.x > p2.x) {
            const tmp = p1;
            p1 = p2;
            p2 = tmp;
        }
        // calculate from/to interval so that only "internal" integer x-es are captured
        const fromX = Math.floor(p1.x + 1);
        const toX = Math.ceil(p2.x - 1);
        const slope = (p1.y - p2.y) / (p1.x - p2.x);
        // handle terminal points separately from the "internal" ones
        extremums.updateValue(floorToCellCoordinate(p1.x, bbox.maxX) - minX, floorToCellCoordinate(p1.y, bbox.maxY));
        extremums.updateValue(floorToCellCoordinate(p2.x, bbox.maxX) - minX, floorToCellCoordinate(p2.y, bbox.maxY));
        for (let x = fromX; x <= toX; x++) {
            const yIntercept = (isFinite(slope) ? slope * (x - p1.x) : 0) + p1.y;
            const nextX = x - minX;
            const prevX = nextX - 1;
            const y = Math.floor(yIntercept);
            // check if we hit exactly the intersection of two integer coordinates
            if (Number.isInteger(yIntercept)) {
                if (yIntercept == bbox.maxY) {
                    extremums.updateValue(prevX, y - 1);
                    extremums.updateValue(nextX, y - 1);
                }
                else if (slope > 0) {
                    // two diagonal squares intersected by a line with positive slope
                    extremums.updateValue(prevX, y - 1);
                    extremums.updateValue(nextX, y);
                }
                else if (slope < 0) {
                    // two diagonal squares intersected by a line with negative slope
                    extremums.updateValue(prevX, y);
                    extremums.updateValue(nextX, y - 1);
                }
            }
            else {
                extremums.updateValue(prevX, y);
                extremums.updateValue(nextX, y);
            }
        }
    }
    for (const { min, max, index } of extremums.values()) {
        const x = minX + index;
        for (let y = min; y <= max; y++) {
            result.push(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* create */](x, y));
        }
    }
    return result;
}


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polyline_renderer__ = __webpack_require__(25);


/**
 * Renderer of transparent polyline primitives.
 */
class TransparentPolylineRenderer extends __WEBPACK_IMPORTED_MODULE_1__polyline_renderer__["a" /* default */] {
    constructor(context) {
        super(context, new __WEBPACK_IMPORTED_MODULE_0__state__["b" /* default */](__WEBPACK_IMPORTED_MODULE_1__polyline_renderer__["a" /* default */].DEFAULT_RENDER_STATE_PARAMS, { depthMask: false }, __WEBPACK_IMPORTED_MODULE_0__state__["a" /* BLEND_OVER_RENDER_STATE */]));
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TransparentPolylineRenderer;



/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_iterable__ = __webpack_require__(13);

/**
 * Some types of primitives should be prepared before being passed to renderer, it could be sorting or filtering,
 * this storage provides functionality similar to Set but also allows to get prepared primitives more efficiently.
 */
class PrimitiveStorage {
    constructor() {
        this._primitiveSet = new Set();
        this._isDirty = false;
        this._primitives = [];
    }
    get primitives() {
        if (this._isDirty) {
            this._primitives.splice(0, this._primitives.length, ...this._filterPrimitives(this._primitiveSet));
            this._isDirty = false;
        }
        return this._primitives;
    }
    add(primitive) {
        this._primitiveSet.add(primitive);
        this._isDirty = true;
    }
    delete(primitive) {
        this._primitiveSet.delete(primitive);
        this._isDirty = true;
    }
    clear() {
        this._primitiveSet.clear();
        this._isDirty = true;
    }
    /**
     * Does no filtering by default, just returns primitives as is.
     */
    _filterPrimitives(primitives) {
        return primitives;
    }
}
/**
 * Primitives which visibility depends on current zoom. Its a temporary solution that should be replaced
 * by proper zoom slice management.
 */
class TmpZoomDependantPrimitiveStorage extends PrimitiveStorage {
    constructor() {
        super();
        this._zoom = -1;
    }
    set zoom(zoom) {
        if (this._zoom !== zoom) {
            this._isDirty = true;
            this._zoom = zoom;
        }
    }
    _filterPrimitives(primitives) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__util_iterable__["b" /* filterIterable */])(primitives, ({ minZoom }) => this._zoom >= minZoom);
    }
}
class Scene {
    constructor() {
        this._opaquePolygons = new PrimitiveStorage();
        this._transparentPolygons = new PrimitiveStorage();
        this._texturedPolygons = new PrimitiveStorage();
        this._opaquePolylines = new PrimitiveStorage();
        this._transparentPolylines = new PrimitiveStorage();
        this._texturedPolylines = new PrimitiveStorage();
        this._pointLabels = new TmpZoomDependantPrimitiveStorage();
        this._curvedLabels = new TmpZoomDependantPrimitiveStorage();
        this._icons = new TmpZoomDependantPrimitiveStorage();
        this._models = new PrimitiveStorage();
        this._rasterLayer = new PrimitiveStorage();
    }
    addPolygon(polygon) {
        if (polygon.isOpaque) {
            this._opaquePolygons.add(polygon);
        }
        else {
            this._transparentPolygons.add(polygon);
        }
    }
    removePolygon(polygon) {
        if (polygon.isOpaque) {
            this._opaquePolygons.delete(polygon);
        }
        else {
            this._transparentPolygons.delete(polygon);
        }
    }
    addTexturedPolygon(polygon) {
        this._texturedPolygons.add(polygon);
    }
    removeTexturedPolygon(ngon) {
        this._texturedPolygons.delete(ngon);
    }
    addPolyline(polyline) {
        if (polyline.isOpaque) {
            this._opaquePolylines.add(polyline);
        }
        else {
            this._transparentPolylines.add(polyline);
        }
    }
    removePolyline(polyline) {
        if (polyline.isOpaque) {
            this._opaquePolylines.delete(polyline);
        }
        else {
            this._transparentPolylines.delete(polyline);
        }
    }
    addTexturedPolyline(polyline) {
        this._texturedPolylines.add(polyline);
    }
    removeTexturedPolyline(polyline) {
        this._texturedPolylines.delete(polyline);
    }
    addPointLabel(label) {
        this._pointLabels.add(label);
    }
    removePointLabel(label) {
        this._pointLabels.delete(label);
    }
    addCurvedLabel(label) {
        this._curvedLabels.add(label);
    }
    removeCurvedLabel(label) {
        this._curvedLabels.delete(label);
    }
    addIcon(icon) {
        this._icons.add(icon);
    }
    removeIcon(icon) {
        this._icons.delete(icon);
    }
    addModel(model) {
        this._models.add(model);
    }
    removeModel(model) {
        this._models.delete(model);
    }
    addToRasterLayer(image) {
        this._rasterLayer.add(image);
    }
    removeFromRasterLayer(image) {
        this._rasterLayer.delete(image);
    }
    getVisibleOpaquePolygons() {
        return this._opaquePolygons.primitives;
    }
    getVisibleTransparentPolygons() {
        return this._transparentPolygons.primitives;
    }
    getVisibleTexturedPolygons() {
        return this._texturedPolygons.primitives;
    }
    getVisibleOpaquePolylines() {
        return this._opaquePolylines.primitives;
    }
    getVisibleTransparentPolylines() {
        return this._transparentPolylines.primitives;
    }
    getVisibleTexturedPolylines() {
        return this._texturedPolylines.primitives;
    }
    getVisiblePointLabels(camera) {
        this._pointLabels.zoom = camera.zoom;
        return this._pointLabels.primitives;
    }
    getVisibleCurvedLabels(camera) {
        this._curvedLabels.zoom = camera.zoom;
        return this._curvedLabels.primitives;
    }
    getVisibleIcons(camera) {
        this._icons.zoom = camera.zoom;
        return this._icons.primitives;
    }
    getVisibleModels() {
        return this._models.primitives;
    }
    getVisibleRasterLayer() {
        return this._rasterLayer.primitives;
    }
    clear() {
        this._opaquePolygons.clear();
        this._texturedPolygons.clear();
        this._opaquePolylines.clear();
        this._transparentPolylines.clear();
        this._texturedPolylines.clear();
        this._pointLabels.clear();
        this._curvedLabels.clear();
        this._icons.clear();
        this._rasterLayer.clear();
        this._models.clear();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Scene;



/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This class encapsulates logic of engine's scene rendering, synchronizing rendering requests from multiple sources.
 * Synchronization is important because of performance constraints: there should be only one GPU rendering in a frame
 * no matter how many animations or individual update requests are there.
 * It works via requestingAnimationFrame() calls chain, updates animators in each frame and switches itself off
 * if there is nothing to update.
 */
class EngineRenderLoop {
    constructor(renderer, scene, camera) {
        this._renderer = renderer;
        this._scene = scene;
        this._camera = camera;
        this._animators = new Set();
        this._renderFrame = (time) => {
            this._stop();
            this._renderFrameImplementation(time);
        };
        this._animatorStateUpdateListener = this._onAnimatorStateUpdate.bind(this);
        this._running = false;
        this._updateInitiator = 0 /* NONE */;
    }
    /**
     * Adds animator (that is being started right away) to the loop. If the rendering loop is not active it starts up.
     * @param animator
     */
    addAnimator(animator) {
        this._animators.add(animator);
        animator.onStateChange.addListener(this._animatorStateUpdateListener);
        if (animator.getState() === 1 /* ACTIVE */) {
            this._run();
        }
    }
    removeAnimator(animator) {
        animator.onStateChange.removeListener(this._animatorStateUpdateListener);
        this._animators.delete(animator);
    }
    start() {
        this._updateInitiator = 2 /* USER */;
        this._running = true;
        this._run();
    }
    stop() {
        this._running = false;
        if (!this._renderer.isComplete) {
            this._updateInitiator = 3 /* RENDERER */;
            this._run();
        }
        else {
            this._updateInitiator = 0 /* NONE */;
            this._stop();
        }
    }
    /**
     * Forces the scene to be rendered. It is not guarantied that the scene is rendered immediately, it can happen in
     * the next frame, that is due to potential performance impact: to prevent multiple rendering in a single frame.
     */
    update(type = 1 /* CONTENT */) {
        switch (type) {
            case 0 /* CAMERA */:
                this._updateInitiator = 2 /* USER */;
                break;
            case 1 /* CONTENT */:
                if (this._updateInitiator === 3 /* RENDERER */) {
                    this._updateInitiator = 2 /* USER */;
                }
                else if (this._updateInitiator !== 2 /* USER */) {
                    this._updateInitiator = 1 /* CONTENT */;
                }
                break;
        }
        this._run();
    }
    /**
     * Stops all the rendering activities.
     */
    destroy() {
        this._updateInitiator = 0 /* NONE */;
        this._stop();
        this._animators.clear();
    }
    /**
     * RAF's callback, where most of the logic is concentrated: updating animators,
     * rendering scene, scheduling the next frame, etc.
     *
     * @param time
     */
    _renderFrameImplementation(time) {
        let isAnyAnimatorActive = false;
        for (const animator of this._animators) {
            if (animator.getState() === 1 /* ACTIVE */) {
                animator.update(time);
                // check is it still active after update
                isAnyAnimatorActive = isAnyAnimatorActive || (animator.getState() === 1 /* ACTIVE */);
            }
        }
        this._renderer.render(this._scene, this._camera, this._updateInitiator);
        if (isAnyAnimatorActive || this._running) {
            this._updateInitiator = 2 /* USER */;
            this._run();
        }
        else if (!this._renderer.isComplete) {
            this._updateInitiator = 3 /* RENDERER */;
            this._run();
        }
        else {
            this._updateInitiator = 0 /* NONE */;
            this._stop();
        }
    }
    /**
     * Starts the loop if it is not active by scheduling the next frame.
     */
    _run() {
        if (!this._scheduledFrameHandle) {
            this._scheduledFrameHandle = requestAnimationFrame(this._renderFrame);
        }
    }
    /**
     * Stops the loop. It can be started again by adding an animator.
     */
    _stop() {
        if (this._scheduledFrameHandle) {
            cancelAnimationFrame(this._scheduledFrameHandle);
        }
        this._scheduledFrameHandle = 0;
    }
    _onAnimatorStateUpdate(animatorStateUpdate) {
        const state = animatorStateUpdate.state;
        if (state === 1 /* ACTIVE */) {
            this._run();
        }
        else if (state === 4 /* FINISHED */ || state === 3 /* CANCELED */) {
            this.removeAnimator(animatorStateUpdate.animator);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EngineRenderLoop;



/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__font_df_glyph_atlas__ = __webpack_require__(105);

/**
 * Atlas that manages allocation in GL texture.
 */
class RenderableDfGlyphAtlas extends __WEBPACK_IMPORTED_MODULE_0__font_df_glyph_atlas__["a" /* default */] {
    constructor(context) {
        super(0, 0, new Uint8Array(0), new Map());
        this._context = context;
        this.texture = this._createTexture(0, 0);
    }
    destroy() {
        this.texture.destroy();
    }
    /**
     * Updates the whole content of the glyph bitmap atlas, texture also get updated.
     *
     * @param width new bitmap width
     * @param height new bitmap height
     * @param data, length should be strictly equal to width * height
     */
    updateContent(width, height, data, glyphLocations) {
        this.width = width;
        this.height = height;
        this.data = data;
        this._glyphLocations = glyphLocations;
        const texture = this.texture;
        if (!texture || texture.getWidth() !== width || texture.getHeight() !== height) {
            if (this.texture) {
                this.texture.destroy();
            }
            this.texture = this._createTexture(width, height);
        }
        this._context.bindTexture(this.texture);
        this.texture.setData(data);
    }
    _createTexture(width, height) {
        return this._context.createEmpty2DTexture(width, height, 6406 /* ALPHA */, 5121 /* UNSIGNED_BYTE */, {
            wrapS: 33071 /* CLAMP_TO_EDGE */,
            wrapT: 33071 /* CLAMP_TO_EDGE */,
            magnificationFilter: 9729 /* LINEAR */,
            minificationFilter: 9729 /* LINEAR */
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableDfGlyphAtlas;



/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const UNKNOWN_GLYPH_LOCATION = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
};
/**
 * Abstract glyph atlas interface.
 */
class DfGlyphAtlas {
    constructor(width, height, data, glyphLocations) {
        this.width = width;
        this.height = height;
        this.data = data;
        this._glyphLocations = glyphLocations;
    }
    /**
     * @return Glyph location or fake location pointing to the origin (0, 0).
     */
    getGlyphLocation(fontId, glyphId) {
        const glyphLocation = this._glyphLocations.get(fontId + glyphId);
        if (glyphLocation) {
            return glyphLocation;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyph locations');
            return UNKNOWN_GLYPH_LOCATION;
        }
    }
    /**
     * @return All glyph locations as [glyph id, glyph location] array. Glyph id is font id concatenated with glyph id.
     */
    getAllGlyphLocations() {
        return [...this._glyphLocations.entries()];
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DfGlyphAtlas;



/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__font_registry__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__df_font__ = __webpack_require__(28);


/**
 * Registry that stores distance field fonts.
 */
class DfFontRegistry extends __WEBPACK_IMPORTED_MODULE_0__font_registry__["a" /* default */] {
    constructor() {
        super(new __WEBPACK_IMPORTED_MODULE_1__df_font__["a" /* default */]('UNKNOWN_DF_FONT', 14, 0));
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DfFontRegistry;



/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A central storage of all available fonts.
 */
class FontRegistry {
    /**
     * @param unknownFontInstance An instance of specific font type to be served as a stub when nonexistent font
     *     is requested. Requesting nonexistent fonts normally should not happen.
     *     The stub just allows to avoid tedious null checks in registry clients.
     */
    constructor(unknownFontInstance) {
        this._fonts = new Map();
        this._unknownFontInstance = unknownFontInstance;
    }
    /**
     * @return If a font with specified id is in the registry.
     */
    contains(fontId) {
        return this._fonts.has(fontId);
    }
    /**
     * @return Font with specified id or unknown font instance if it is not found.
     */
    get(fontId) {
        const font = this._fonts.get(fontId);
        if (font) {
            return font;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent fonts');
            return this._unknownFontInstance;
        }
    }
    /**
     * @return All stored fonts.
     */
    getAll() {
        return [...this._fonts.values()];
    }
    /**
     * Adds new for to the registry.
     */
    add(font) {
        this._fonts.set(font.id, font);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FontRegistry;



/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Font is just a collection of glyph descriptions.
 */
class Font {
    /**
     * @param id Font id.
     * @param xheight The height of the "x" char in abstract points, in fact is used a the font size.
     * @param unknownGlyphInstance An instance of glyph to be served as a stub when nonexistent glyph
     *     is requested. Requesting nonexistent glyphs normally should not happen.
     *     The stub just allows to avoid tedious null checks in font clients.
     */
    constructor(id, xheight, unknownGlyphInstance) {
        this.id = id;
        this.xheight = xheight;
        this._unknownGlyphInstance = unknownGlyphInstance;
        this._glyphs = new Map();
    }
    /**
     * @return Glyph with specified id or unknown glyph instance.
     */
    getGlyph(glyphId) {
        const glyph = this._glyphs.get(glyphId);
        if (glyph) {
            return glyph;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyphs');
            return this._unknownGlyphInstance;
        }
    }
    /**
     * @returns All stored glyphs.
     */
    getAllGlyphs() {
        return [...this._glyphs.values()];
    }
    /**
     * Adds glyph description.
     */
    addGlyph(glyph) {
        this._glyphs.set(glyph.id, glyph);
    }
    /**
     * Adds glyph descriptions from the iterable.
     */
    addAllGlyphs(glyphs) {
        for (const glyph of glyphs) {
            this.addGlyph(glyph);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Font;



/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__billboard_image_atlas__ = __webpack_require__(110);

/**
 * Atlas that manages allocation in GL texture.
 */
class RenderableImageAtlas extends __WEBPACK_IMPORTED_MODULE_0__billboard_image_atlas__["a" /* default */] {
    constructor(context) {
        super();
        this._context = context;
        this.texture = this._createTexture(this.width, this.height);
        this.isDirty = false;
    }
    /**
     * Updates GL texture with changed data. Should be called after each image added to take effect in shaders.
     */
    syncTexture() {
        this._context.bindTexture(this.texture);
        this.texture.setDataFromDomElement(this.canvas);
        this.isDirty = false;
    }
    destroy() {
        this.texture.destroy();
    }
    _expand(newWidth, newHeight) {
        super._expand(newWidth, newHeight);
        this.texture.destroy();
        this.texture = this._createTexture(this.width, this.height);
        this.isDirty = true;
    }
    _putImageBitmap(image, location) {
        super._putImageBitmap(image, location);
        this.isDirty = true;
    }
    _createTexture(width, height) {
        return this._context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableImageAtlas;



/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_allocator_2d__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_event_emitter__ = __webpack_require__(4);


const INIT_ATLAS_WIDTH = 256;
const INIT_ATLAS_HEIGHT = 256;
const MAX_ATLAS_WIDTH = 2048;
const MAX_ATLAS_HEIGHT = 2048;
const EXPAND_FACTOR = 2;
/**
 * Manages allocation of images. It resizes itself (up to a fixed limit) when there is no region
 * of enough size for the next image.
 */
class ImageAtlas {
    constructor(initAtlasWidth = INIT_ATLAS_WIDTH, initAtlasHeight = INIT_ATLAS_HEIGHT) {
        this.onContentUpdate = new __WEBPACK_IMPORTED_MODULE_1__util_event_emitter__["b" /* VoidEventEmitter */]();
        this.canvas = document.createElement('canvas');
        this.canvas.width = initAtlasWidth;
        this.canvas.height = initAtlasHeight;
        this._canvasContext = this.canvas.getContext('2d');
        this._allocator = new __WEBPACK_IMPORTED_MODULE_0__util_allocator_2d__["a" /* ShelfAllocator2D */](this.width, this.height);
    }
    get width() {
        return this.canvas.width;
    }
    get height() {
        return this.canvas.width;
    }
    /**
     * Allocates image bitmap.
     */
    allocateImage(descriptor, image) {
        const location = this._allocate(descriptor);
        if (location) {
            this._putImageBitmap(image, location);
        }
        return location;
    }
    /**
     * Deallocates image from the atlas.
     */
    removeImage(image) {
        this._allocator.deallocate(image);
    }
    _allocate(descriptor) {
        let location = this._allocator.allocate(descriptor);
        // incremental expand can be inefficient if two or more iterations are needed to allocate an image,
        // but it is expected to be a rare (if any) case, rework if it turns out to be wrong
        while (!location) {
            const expandedWidth = this.width * EXPAND_FACTOR;
            const expandedHeight = this.height * EXPAND_FACTOR;
            if (expandedWidth <= MAX_ATLAS_WIDTH && expandedHeight <= MAX_ATLAS_HEIGHT) {
                this._expand(expandedWidth, expandedHeight);
                location = this._allocator.allocate(descriptor);
            }
            else {
                break;
            }
        }
        return location;
    }
    _putImageBitmap(image, location) {
        this._canvasContext.clearRect(location.minX, location.minY, location.maxX - location.minX, location.maxY - location.minY);
        this._canvasContext.drawImage(image, location.minX, location.minY, location.maxX - location.minX, location.maxY - location.minY);
        this.onContentUpdate.fire();
    }
    _expand(newWidth, newHeight) {
        this._allocator.resize(newWidth, newHeight);
        // setting new width/height to canvas will clear it,
        // so current data is saved to be restored immediately after resizing
        const data = this._canvasContext.getImageData(0, 0, this.width, this.height);
        this.canvas.width = newWidth;
        this.canvas.height = newHeight;
        this._canvasContext.putImageData(data, 0, 0);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageAtlas;



/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__allocator__ = __webpack_require__(18);

/**
 * A rectangular region with fixed height. Utility class for shelf allocation defined below.
 */
class Shelf {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this._allocator = new __WEBPACK_IMPORTED_MODULE_0__allocator__["b" /* FreeListAllocator */](this.width);
    }
    allocate(width) {
        return this._allocator.allocate(width);
    }
    deallocate(offset) {
        this._allocator.deallocate(offset);
    }
    isAllocated(offset) {
        return this._allocator.isAllocated(offset);
    }
    canAllocate(width) {
        return this._allocator.maxAllocableSize >= width;
    }
    resize(width) {
        this._allocator.extend(width);
        this.width = width;
    }
}
/**
 * Allocates rectangles in "shelves" (height fixed regions). They are created of necessity when the next object doesnt
 * fit any existing shelf. To optimize space usage it tries to find the best shelf for allocation (min height diff).
 * A shelf when allocated is never deallocated back and exists during all the allocator lifetime.
 */
class ShelfAllocator2D {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this._shelves = new Map();
        this._shelfAllocator = new __WEBPACK_IMPORTED_MODULE_0__allocator__["a" /* ArenaAllocator */](height); // no shelf deallocation, that is why ArenaAllocator is fine
    }
    allocate(object) {
        let bestShelf;
        let bestShelfOffset = -1;
        let bestShelfRatio = -1;
        for (const [offset, shelf] of this._shelves.entries()) {
            const shelfRatio = object.height / shelf.height;
            if (shelfRatio === 1 && shelf.canAllocate(object.width)) {
                bestShelf = shelf;
                bestShelfOffset = offset;
                break;
            }
            else if (shelfRatio < 1 && shelfRatio > bestShelfRatio && shelf.canAllocate(object.width)) {
                bestShelf = shelf;
                bestShelfOffset = offset;
                bestShelfRatio = shelfRatio;
            }
        }
        if (!bestShelf && this._shelfAllocator.maxAllocableSize >= object.height && this.width >= object.width) {
            const offset = this._shelfAllocator.allocate(object.height);
            bestShelf = new Shelf(this.width, object.height);
            bestShelfOffset = offset;
            this._shelves.set(offset, bestShelf);
        }
        if (bestShelf) {
            const left = bestShelf.allocate(object.width);
            const top = bestShelfOffset;
            const location = {
                minX: left,
                maxX: left + object.width,
                minY: top,
                maxY: top + object.height
            };
            return location;
        }
        else {
            return null;
        }
    }
    deallocate(objectLocation) {
        const shelf = this._shelves.get(objectLocation.minY);
        if (shelf) {
            shelf.deallocate(objectLocation.minX);
        }
    }
    isAllocated(objectLocation) {
        const shelf = this._shelves.get(objectLocation.minY);
        return !!shelf && shelf.isAllocated(objectLocation.minX);
    }
    resize(width, height) {
        this._shelfAllocator.extend(height);
        for (const shelf of this._shelves.values()) {
            shelf.resize(width);
        }
        this.width = width;
        this.height = height;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ShelfAllocator2D;



/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tile_based_adapter_adapter__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__primitive_icon_icon_buffer_writer__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__primitive_point__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__billboard_identified_image_atlas_manager__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__primitive_polygon__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__primitive_polyline__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__primitive_label__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__font_df_font__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__api_image_provider__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__primitive_model__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__primitive_model_model_buffer_writer__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__primitive_textured_polyline__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__primitive_polyline_textured_polyline_buffer_writer__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__billboard_image_manager__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__primitive_textured_polygon__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__primitive_polygon_textured_polygon_buffer_rewiter__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__primitive_polygon_polygon_attribute_mapping__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__primitive_polygon_textured_polygon_attribute_mapping__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__primitive_billboard_rectangle_attribute_mapping__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__primitive_label_point_label_attribute_mapping__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__primitive_label_curved_label_attribute_mapping__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__primitive_polyline_polyline_attribute_mapping__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__primitive_polyline_transparent_polyline_attribute_mapping__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__worker_tile_provider_worker_client__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__worker_tile_provider_worker_messages__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__primitive_polygon_transparent_polygon_attribute_mapping__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__scene_primitive_manager__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__util_event_emitter__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__tile_based_adapter_tile_id__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__util_idle_task_queue__ = __webpack_require__(151);































/**
 * Computes a minimum zoom an object should be still displayed on.
 *
 * @param tile Tile the object belongs to.
 * @param delta Tolerance of the visibility to zooming out, default value was empirically chosen.
 * @returns Minimum zoom for the object.
 */
function computeMinZoom(tile, delta = 2) {
    return tile.zoom - delta;
}
const WORLD_SIZE = 2.0;
const TILE_SIZE_PX = 256; // tile's vector data is optimized for displaying in a 256x256 css px square
class VectorApiAdapter extends __WEBPACK_IMPORTED_MODULE_0__tile_based_adapter_adapter__["a" /* default */] {
    constructor(engine, camera, tileProviderWorkerUrl, { imageUrlTemplate, tileUrlTemplate, meshUrlTemplate, glyphRangeUrlTemplate }) {
        super(engine, camera);
        this.onTileLoadChange = new __WEBPACK_IMPORTED_MODULE_28__util_event_emitter__["a" /* EventEmitter */]();
        this._requestedTiles = new Map();
        this._readyTiles = new Set();
        this._tileProvider = new __WEBPACK_IMPORTED_MODULE_24__worker_tile_provider_worker_client__["a" /* TileProviderWorkerClient */](tileProviderWorkerUrl);
        this._tileProvider.sendMessage({
            type: __WEBPACK_IMPORTED_MODULE_25__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].INIT,
            tileUrlTemplate,
            meshUrlTemplate,
            glyphRangeUrlTemplate
        }, 1 /* IMMEDIATE */);
        this._memoryManager = engine.getRenderer().getMemoryManager();
        this._glyphAtlas = engine.glyphAtlas;
        this._fontRegistry = engine.fontRegistry;
        this._imageManager = new __WEBPACK_IMPORTED_MODULE_14__billboard_image_manager__["a" /* ImageManager */](new __WEBPACK_IMPORTED_MODULE_4__billboard_identified_image_atlas_manager__["a" /* default */](engine.createImageAtlas()), new __WEBPACK_IMPORTED_MODULE_9__api_image_provider__["a" /* ApiImageProvider */](imageUrlTemplate));
        this._primitiveTypes = [
            new __WEBPACK_IMPORTED_MODULE_27__scene_primitive_manager__["b" /* ScenePrimitiveManager */]((data) => data.polygons, (scene, primitive) => scene.addPolygon(primitive.renderablePolygon), (scene, primitive) => scene.removePolygon(primitive.renderablePolygon)),
            new __WEBPACK_IMPORTED_MODULE_27__scene_primitive_manager__["b" /* ScenePrimitiveManager */]((data) => data.texturedPolygons, (scene, primitive) => scene.addTexturedPolygon(primitive.renderablePolygon), (scene, primitive) => scene.removeTexturedPolygon(primitive.renderablePolygon)),
            new __WEBPACK_IMPORTED_MODULE_27__scene_primitive_manager__["b" /* ScenePrimitiveManager */]((data) => data.pointLabels, (scene, primitive) => scene.addPointLabel(primitive.renderableLabel), (scene, primitive) => scene.removePointLabel(primitive.renderableLabel)),
            new __WEBPACK_IMPORTED_MODULE_27__scene_primitive_manager__["b" /* ScenePrimitiveManager */]((data) => data.curvedLabels, (scene, primitive) => scene.addCurvedLabel(primitive.renderableLabel), (scene, primitive) => scene.removeCurvedLabel(primitive.renderableLabel)),
            new __WEBPACK_IMPORTED_MODULE_27__scene_primitive_manager__["b" /* ScenePrimitiveManager */]((data) => data.points, (scene, primitive) => scene.addIcon(primitive.renderableIcon), (scene, primitive) => scene.removeIcon(primitive.renderableIcon)),
            new __WEBPACK_IMPORTED_MODULE_27__scene_primitive_manager__["b" /* ScenePrimitiveManager */]((data) => data.polylines, (scene, primitive) => scene.addPolyline(primitive.renderablePolyline), (scene, primitive) => scene.removePolyline(primitive.renderablePolyline)),
            new __WEBPACK_IMPORTED_MODULE_27__scene_primitive_manager__["b" /* ScenePrimitiveManager */]((data) => data.texturedPolylines, (scene, primitive) => scene.addTexturedPolyline(primitive.renderablePolyline), (scene, primitive) => scene.removeTexturedPolyline(primitive.renderablePolyline)),
            new __WEBPACK_IMPORTED_MODULE_27__scene_primitive_manager__["b" /* ScenePrimitiveManager */]((data) => data.models, (scene, primitive) => scene.addModel(primitive.renderableModel), (scene, primitive) => scene.removeModel(primitive.renderableModel)),
            new __WEBPACK_IMPORTED_MODULE_27__scene_primitive_manager__["a" /* ExternalMeshScenePrimitiveManager */](engine.renderLoop, this._tileProvider, this._memoryManager)
        ];
        this._taskQueue = new __WEBPACK_IMPORTED_MODULE_30__util_idle_task_queue__["a" /* default */]();
        this._tileProvider.on(__WEBPACK_IMPORTED_MODULE_25__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_RESPONSE, (response) => {
            this._taskQueue.enqueue(() => {
                const tile = response.tile;
                // atlas must be updated notwithstanding the tile is active or not
                // as these new glyphs will be used in next tiles
                const atlas = response.glyphAtlasToUpdate;
                if (atlas) {
                    this._glyphAtlas.updateContent(atlas.width, atlas.height, atlas.data, new Map(atlas.glyphLocations));
                }
                const registry = response.fontRegistryToUpdate;
                if (registry) {
                    for (const fontData of registry) {
                        let font;
                        if (this._fontRegistry.contains(fontData.id)) {
                            font = this._fontRegistry.get(fontData.id);
                        }
                        else {
                            font = new __WEBPACK_IMPORTED_MODULE_8__font_df_font__["a" /* default */](fontData.id, fontData.xheight, fontData.margin);
                            this._fontRegistry.add(font);
                        }
                        font.addAllGlyphs(fontData.glyphs);
                    }
                }
                if (!this._isTileStillActive(tile))
                    return;
                this._taskQueue.enqueue(() => this._putTileData(tile, {
                    polygons: this._allocatePolygons(response),
                    models: this._allocateMeshes(response),
                    externalMeshes: this._allocateExternalMeshes(response),
                    polylines: this._allocatePolylines(response),
                    pointLabels: this._allocatePointLabels(response),
                    curvedLabels: this._allocateCurvedLabels(response)
                }, false));
                this._allocateIcons(tile, response).then((icons) => {
                    this._taskQueue.enqueue(() => this._putTileData(tile, { points: icons }));
                });
                this._allocateTexturedPolylines(response).then((texturedPolylines) => {
                    this._taskQueue.enqueue(() => this._putTileData(tile, { texturedPolylines }));
                });
                this._allocateTexturedPolygons(response).then((texturedPolygons) => {
                    this._taskQueue.enqueue(() => this._putTileData(tile, { texturedPolygons }));
                });
                const requestedTileData = this._requestedTiles.get(Object(__WEBPACK_IMPORTED_MODULE_29__tile_based_adapter_tile_id__["a" /* getTileId */])(tile));
                if (requestedTileData !== undefined) {
                    // TODO: the data is synced on these two properties and this code doesn't make much sense for now,
                    //       but it is left "as is" since it is not clear how it will be changed in nearest future
                    requestedTileData.isGeometryReady = true;
                    requestedTileData.areLabelsReady = true;
                }
                this._checkTileReady(tile);
            });
        });
        this._onCameraUpdate();
    }
    destroy() {
        this._tileProvider.destroy();
        super.destroy();
    }
    _onVisibleTilesChanged(visibleTiles, tileCoordinateSystem) {
        let readyTilesSetChanged = false;
        for (const tileId of this._readyTiles) {
            if (!visibleTiles.find((visibleItem) => {
                return Object(__WEBPACK_IMPORTED_MODULE_29__tile_based_adapter_tile_id__["a" /* getTileId */])(visibleItem) === tileId;
            })) {
                this._readyTiles.delete(tileId);
                readyTilesSetChanged = true;
            }
        }
        if (readyTilesSetChanged) {
            this._fireTileLoadChange();
        }
        super._onVisibleTilesChanged(visibleTiles, tileCoordinateSystem);
    }
    _requestTiles(tiles) {
        for (const tile of tiles) {
            this._requestedTiles.set(Object(__WEBPACK_IMPORTED_MODULE_29__tile_based_adapter_tile_id__["a" /* getTileId */])(tile.tile), {
                isGeometryReady: false,
                areLabelsReady: false
            });
        }
        this._fireTileLoadChange();
        this._tileProvider.sendMessage({
            type: __WEBPACK_IMPORTED_MODULE_25__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_REQUEST,
            tiles
        }, 1 /* IMMEDIATE */);
    }
    _cancelTileRequest(tileItem) {
        if (this._requestedTiles.has(Object(__WEBPACK_IMPORTED_MODULE_29__tile_based_adapter_tile_id__["a" /* getTileId */])(tileItem))) {
            this._requestedTiles.delete(Object(__WEBPACK_IMPORTED_MODULE_29__tile_based_adapter_tile_id__["a" /* getTileId */])(tileItem));
            this._fireTileLoadChange();
        }
        this._tileProvider.sendMessage({
            type: __WEBPACK_IMPORTED_MODULE_25__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_REQUEST_CANCEL,
            tile: tileItem
        });
    }
    _onTileDataUpdate(dataToShow, dataToHide) {
        for (const primitiveManager of this._primitiveTypes) {
            primitiveManager.updateScene(this.engine.getScene(), this.camera, dataToShow, dataToHide);
        }
        this.engine.renderLoop.update();
    }
    _onTileDestroy(_tileItem, data) {
        for (const primitiveManager of this._primitiveTypes) {
            for (const portion of data) {
                primitiveManager.destroy(portion);
            }
        }
        this.engine.renderLoop.update();
    }
    _allocatePolygons(response) {
        const apiPolygons = new Array(response.polygons.length + response.transparentPolygons.length);
        const memoryChunks = new MemoryChunks(response.polygonPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_17__primitive_polygon_polygon_attribute_mapping__["a" /* POLYGON_ATTRIBUTE_MAPPING */]);
        const transparentPolygonsMemoryChunks = new MemoryChunks(response.transparentPolygonPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_26__primitive_polygon_transparent_polygon_attribute_mapping__["a" /* TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING */]);
        let index = 0;
        for (let i = 0; i < response.polygons.length; i++, index++) {
            const { bufferLocation, styles } = response.polygons[i];
            apiPolygons[index] = new __WEBPACK_IMPORTED_MODULE_5__primitive_polygon__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[bufferLocation.bufferIndex], bufferLocation), styles, true);
        }
        for (let i = 0; i < response.transparentPolygons.length; i++, index++) {
            const { bufferLocation, styles } = response.transparentPolygons[i];
            apiPolygons[index] = new __WEBPACK_IMPORTED_MODULE_5__primitive_polygon__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](transparentPolygonsMemoryChunks[bufferLocation.bufferIndex], bufferLocation), styles, false);
        }
        memoryChunks.forEach((chunk) => chunk.release());
        transparentPolygonsMemoryChunks.forEach((chunk) => chunk.release());
        return apiPolygons;
    }
    _allocateTexturedPolygons(response) {
        return Promise.all(response.texturedPolygons.map((texturedPolygon) => {
            const style = texturedPolygon.styles[0];
            const pattern = style && style.pattern;
            if (pattern) {
                return this._imageManager.getImage(pattern.imageId).then((allocatedImage) => ({ bufferLocation: texturedPolygon.bufferLocation, allocatedImage, style }), () => null);
            }
            else {
                return null;
            }
        })).then((texturedPolygons) => {
            return new Promise((resolve) => this._taskQueue.enqueue(() => {
                if (!this._isTileStillActive(response.tile))
                    resolve([]);
                const apiPolygonImages = [];
                if (this._isTileStillActive(response.tile)) {
                    const pages = response.texturedPolygonPages;
                    const texturedPolygonRewriter = new __WEBPACK_IMPORTED_MODULE_16__primitive_polygon_textured_polygon_buffer_rewiter__["a" /* default */](pages);
                    const rewrittenPolygonImages = [];
                    const worldToPxFactor = WORLD_SIZE / (TILE_SIZE_PX * Math.pow(2, response.tile.zoom));
                    for (const texturedPolygon of texturedPolygons) {
                        if (texturedPolygon && texturedPolygon.allocatedImage) {
                            const allocatedImage = texturedPolygon.allocatedImage;
                            const pattern = texturedPolygon.style.pattern;
                            const imageScale = pattern.width / allocatedImage.descriptor.width;
                            texturedPolygonRewriter.rewriteUV(texturedPolygon.bufferLocation, allocatedImage.bbox, worldToPxFactor * imageScale);
                            rewrittenPolygonImages.push(Object.assign({}, texturedPolygon, { allocatedImage }));
                        }
                    }
                    const chunks = new MemoryChunks(pages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_18__primitive_polygon_textured_polygon_attribute_mapping__["a" /* TEXTURED_POLYGON_ATTRIBUTE_MAPPING */]);
                    for (const { bufferLocation, allocatedImage } of rewrittenPolygonImages) {
                        apiPolygonImages.push(new __WEBPACK_IMPORTED_MODULE_15__primitive_textured_polygon__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](chunks[bufferLocation.bufferIndex], bufferLocation), allocatedImage));
                    }
                    chunks.forEach((chunk) => chunk.release());
                }
                // allocated images were retained on request, need to release all of them
                for (const polygonImage of texturedPolygons) {
                    if (polygonImage && polygonImage.allocatedImage) {
                        polygonImage.allocatedImage.release();
                    }
                }
                resolve(apiPolygonImages);
            }));
        }, () => []);
    }
    _allocateMeshes(tileResponse) {
        const memoryChunks = tileResponse.meshPages.map((page) => this._memoryManager.allocate(page.vertexBuffer, page.indexBuffer, __WEBPACK_IMPORTED_MODULE_11__primitive_model_model_buffer_writer__["a" /* default */].ATTRIBUTE_MAPPING));
        const meshes = tileResponse.meshes.map((mesh) => new __WEBPACK_IMPORTED_MODULE_10__primitive_model__["b" /* default */](mesh.styles, new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[mesh.bufferLocation.bufferIndex], mesh.bufferLocation)));
        memoryChunks.forEach((chunk) => chunk.release());
        return meshes;
    }
    _allocateExternalMeshes(tileResponse) {
        return tileResponse.externalMeshes.map((mesh) => new __WEBPACK_IMPORTED_MODULE_10__primitive_model__["a" /* ApiPolygonMesh */](mesh.mesh, mesh.styles));
    }
    _allocatePolylines(response) {
        const apiPolylines = new Array(response.polylines.length + response.transparentPolylines.length);
        const memoryChunks = new MemoryChunks(response.polylinePages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_22__primitive_polyline_polyline_attribute_mapping__["a" /* POLYLINE_ATTRIBUTE_MAPPING */]);
        const transparentPolylinesMemoryChunks = new MemoryChunks(response.transparentPolylinePages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_23__primitive_polyline_transparent_polyline_attribute_mapping__["a" /* TRANSPARENT_POLYLINE_ATTRIBUTE_MAPPING */]);
        let index = 0;
        for (let i = 0; i < response.polylines.length; i++, index++) {
            const { bufferLocation, styles } = response.polylines[i];
            apiPolylines[index] = new __WEBPACK_IMPORTED_MODULE_6__primitive_polyline__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[bufferLocation.bufferIndex], bufferLocation), styles, true);
        }
        for (let i = 0; i < response.transparentPolylines.length; i++, index++) {
            const { bufferLocation, styles } = response.transparentPolylines[i];
            apiPolylines[index] = new __WEBPACK_IMPORTED_MODULE_6__primitive_polyline__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](transparentPolylinesMemoryChunks[bufferLocation.bufferIndex], bufferLocation), styles, false);
        }
        memoryChunks.forEach((chunk) => chunk.release());
        transparentPolylinesMemoryChunks.forEach((chunk) => chunk.release());
        return apiPolylines;
    }
    _allocateTexturedPolylines(tileResponse) {
        return Promise.all(tileResponse.texturedPolylines.map((texturedPolyline) => {
            const style = texturedPolyline.styles[0];
            const pattern = style && style.inline && style.inline.pattern;
            if (pattern) {
                return this._imageManager.getImage(pattern.imageId).then((allocatedImage) => allocatedImage ? { texturedPolyline, allocatedImage } : null, () => null);
            }
            else {
                return null;
            }
        })).then((images) => {
            return new Promise((resolve) => this._taskQueue.enqueue(() => {
                if (!this._isTileStillActive(tileResponse.tile))
                    resolve([]);
                const texturedPolylineWriter = new __WEBPACK_IMPORTED_MODULE_13__primitive_polyline_textured_polyline_buffer_writer__["a" /* default */]();
                const worldToPxFactor = 2.0 / (256 * Math.pow(2, tileResponse.tile.zoom));
                const writtenTexturedPolylines = [];
                for (const texturedPolyline of images) {
                    if (texturedPolyline) {
                        const style = texturedPolyline.texturedPolyline.styles[0];
                        const width = (style.inline || style.outline).strokeWidth;
                        const imageLocation = texturedPolyline.allocatedImage.bbox;
                        // image size may not match polyline's strokeWidth, so it must be scaled accordingly in
                        // both directions, this factor can be passed to the writer in worldToPxFactor updated.
                        const pixelRatio = width / (imageLocation.maxY - imageLocation.minY);
                        const bufferLocation = texturedPolylineWriter.writeTexturedPolyline(texturedPolyline.texturedPolyline, width, worldToPxFactor * pixelRatio, texturedPolyline.allocatedImage.bbox, style.zIndex);
                        writtenTexturedPolylines.push({ bufferLocation, allocatedImage: texturedPolyline.allocatedImage });
                    }
                }
                const pages = texturedPolylineWriter.getBuffers();
                const memoryChunks = new MemoryChunks(pages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_13__primitive_polyline_textured_polyline_buffer_writer__["a" /* default */].ATTRIBUTE_MAPPING);
                const texturedPolylines = writtenTexturedPolylines.map((texturedPolyline) => {
                    const apiTexturedPolyline = new __WEBPACK_IMPORTED_MODULE_12__primitive_textured_polyline__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[texturedPolyline.bufferLocation.bufferIndex], texturedPolyline.bufferLocation), [], texturedPolyline.allocatedImage.atlas.imageAtlas, texturedPolyline.allocatedImage);
                    texturedPolyline.allocatedImage.release();
                    return apiTexturedPolyline;
                });
                memoryChunks.forEach((chunk) => chunk.release());
                resolve(texturedPolylines);
            }));
        }, () => []);
    }
    _allocatePointLabels(response) {
        const memoryChunks = new MemoryChunks(response.pointLabelPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_20__primitive_label_point_label_attribute_mapping__["a" /* POINT_LABEL_ATTRIBUTE_MAPPING */]);
        const backgroundMemoryChunks = new MemoryChunks(response.pointLabelBackgroundPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_19__primitive_billboard_rectangle_attribute_mapping__["a" /* BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING */]);
        const pointLabels = response.pointLabels.map(({ bufferLocation, styles, backgroundBufferLocation }) => new __WEBPACK_IMPORTED_MODULE_7__primitive_label__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[bufferLocation.bufferIndex], bufferLocation), computeMinZoom(response.tile), styles, this._glyphAtlas, backgroundBufferLocation ? new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](backgroundMemoryChunks[backgroundBufferLocation.bufferIndex], backgroundBufferLocation) : undefined));
        backgroundMemoryChunks.forEach((chunk) => chunk.release());
        memoryChunks.forEach((chunk) => chunk.release());
        console.log(pointLabels);
        return pointLabels;
    }
    _allocateCurvedLabels(response) {
        const memoryChunks = new MemoryChunks(response.curvedLabelPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_21__primitive_label_curved_label_attribute_mapping__["a" /* CURVED_LABEL_ATTRIBUTE_MAPPING */]);
        const curvedLabels = response.curvedLabels.map(({ bufferLocation, styles }) => new __WEBPACK_IMPORTED_MODULE_7__primitive_label__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[bufferLocation.bufferIndex], bufferLocation), computeMinZoom(response.tile), styles, this._glyphAtlas));
        memoryChunks.forEach((chunk) => chunk.release());
        return curvedLabels;
    }
    _allocateIcons(tile, tileResponse) {
        return Promise.all(tileResponse.points.map((icon) => {
            const style = icon.styles[0];
            return this._imageManager.getImage(style.imageId).then((allocatedImage) => allocatedImage ? { icon, allocatedImage } : null, () => null);
        })).then((images) => {
            return new Promise((resolve) => this._taskQueue.enqueue(() => {
                if (!this._isTileStillActive(tile))
                    resolve([]);
                const iconWriter = new __WEBPACK_IMPORTED_MODULE_1__primitive_icon_icon_buffer_writer__["a" /* default */]();
                const writtenIcons = images.filter((image) => !!image).map((image) => {
                    const style = image.icon.styles[0];
                    const allocatedImage = image.allocatedImage;
                    const location = allocatedImage.bbox;
                    const size = allocatedImage.descriptor;
                    const pixelRatio = style.width / size.width;
                    return Object.assign({}, image, { location: iconWriter.writeIcon(image.icon, location, size, style.offset, pixelRatio) });
                });
                const pages = iconWriter.getBuffers();
                const memoryChunks = new MemoryChunks(pages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_1__primitive_icon_icon_buffer_writer__["a" /* default */].ATTRIBUTE_MAPPING);
                const icons = writtenIcons.map((icon) => {
                    const apiPoint = new __WEBPACK_IMPORTED_MODULE_3__primitive_point__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[icon.location.bufferIndex], icon.location), icon.icon.styles, icon.allocatedImage, icon.allocatedImage.atlas.imageAtlas, computeMinZoom(tile));
                    icon.allocatedImage.release();
                    return apiPoint;
                });
                memoryChunks.forEach((chunk) => chunk.release());
                resolve(icons);
            }));
        }, () => []);
    }
    _fireTileLoadChange() {
        this.onTileLoadChange.fire({
            totalTileNumber: this._requestedTiles.size + this._readyTiles.size,
            readyTileNumber: this._readyTiles.size
        });
    }
    _checkTileReady(tileItem) {
        const tileId = Object(__WEBPACK_IMPORTED_MODULE_29__tile_based_adapter_tile_id__["a" /* getTileId */])(tileItem);
        const tileData = this._requestedTiles.get(tileId);
        if (tileData !== undefined) {
            if (tileData.areLabelsReady && tileData.isGeometryReady) {
                this._readyTiles.add(tileId);
                this._requestedTiles.delete(tileId);
                this._fireTileLoadChange();
            }
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = VectorApiAdapter;

/**
 * Helper class for allocation of an array of memory chunks.
 */
class MemoryChunks extends Array {
    constructor(pages, memoryManager, attribMapping) {
        super(pages.length);
        for (let i = 0; i < pages.length; i++) {
            this[i] = memoryManager.allocate(pages[i].vertexBuffer, pages[i].indexBuffer, attribMapping);
        }
    }
}


/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adapter__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vector_api_util_tile_system__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_iterable__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tile_id__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__vector_api_util_compute_visible_tiles__ = __webpack_require__(117);





/* VECTOR-82 Turn off tile preloading until fix rendering speed issues.
import Camera, {CenterWrapMode} from '../../camera/camera';
import {calculateBeltTiles} from './belt_tiles';
*/
/**
 * This class is the main unit of the whole process of tile management. It stores visualizable data and links to
 * dependant tiles (for parent/child overlapping cases).
 */
class Tile {
    constructor(tileItem) {
        this.data = [];
        this.tileItem = tileItem;
        this.id = `${tileItem.x}:${tileItem.y}:${tileItem.zoom}`;
        this.isReadyToVisualize = false;
        this.isRemoved = false;
        this.toBeReplacedBy = new Set();
        this.replacementFor = new Set();
    }
}
const NO_TILES_TO_HANDLE = [];
const FILTER_VISIBLE = (data) => data.isVisible;
const FILTER_INVISIBLE = (data) => !data.isVisible;
const DATA_MAPPER = (data) => data.data;
const flattenDataPortions = function* (tiles) {
    for (const tile of tiles) {
        yield* tile.data;
    }
};
/**
 * Base class for adapters that get their data in tiles. Content of tiles that come into field of view should
 * be requested, as well as content of invisible tiles should be removed, also tiles on different zoom levels can
 * overlap each other. Managing of all these cases and other tile-specific logic is the responsibility of this class.
 */
class TileBasedAdapter extends __WEBPACK_IMPORTED_MODULE_0__adapter__["a" /* default */] {
    constructor(engine, camera) {
        super(engine, camera);
        this._currentTiles = new Map();
        this._preloadedTiles = new Map();
        this._allTiles = new Map();
        // this._beltSize = preloadedTilesBeltSize;
    }
    /**
     * @param tileItem The tile to which the data belongs.
     * @param data Data portion to be shown in tile once it is ready to visualize.
     * @param visualize Is this data portion enough to render this tile and replace overlapped ones if any.
     */
    _putTileData(tileItem, data, visualize = true) {
        const tile = this._allTiles.get(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem));
        if (tile) {
            const isCurrent = this._currentTiles.has(tile.id);
            const dataPortion = { isVisible: false, data: data };
            tile.data.push(dataPortion);
            if (!tile.isReadyToVisualize && visualize) {
                tile.isReadyToVisualize = true;
                if (isCurrent) {
                    this._checkTileReplacements(tile);
                }
            }
            else if (isCurrent) {
                this._updateTileData([tile], NO_TILES_TO_HANDLE);
            }
        }
        else {
            // Data recieved late and probably the tile had been destroyed.
            // Destroy data too.
            this._onTileDestroy(tileItem, [data]);
        }
    }
    _onCameraUpdate() {
        this._onVisibleTilesChanged([...Object(__WEBPACK_IMPORTED_MODULE_4__vector_api_util_compute_visible_tiles__["a" /* default */])(this.camera)], new __WEBPACK_IMPORTED_MODULE_1__vector_api_util_tile_system__["a" /* default */](this.camera.zoom));
    }
    /**
     * This method is where the whole magic happens, it manages replacement of current set of visible/preloaded tiles
     * with a new one.
     */
    _onVisibleTilesChanged(visibleTiles, tileCoordinateSystem) {
        this._currentTiles.clear();
        const tilesToRequest = [];
        const center = tileCoordinateSystem.toTileCoordinates(this.camera.center);
        for (const tileItem of visibleTiles) {
            let tile = this._allTiles.get(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem));
            if (!tile) {
                tile = new Tile(tileItem);
                tilesToRequest.push({
                    tile: tileItem,
                    // Shorter the distance from the tile to the viewport center,
                    // higher its priority.
                    priority: 1 / Math.hypot(tileItem.x - center.x, tileItem.y - center.y)
                });
                this._allTiles.set(tile.id, tile);
            }
            this._currentTiles.set(tile.id, tile);
        }
        this._requestTiles(tilesToRequest);
        /* VECTOR-82 Turn off tile preloading until fix rendering speed issues.
        // preload some tiles
        this._preloadedTiles.clear();
        for (const tileItem of calculateBeltTiles(
            visibleTiles,
            this._beltSize,
            this.camera.options.wrapModeX == CenterWrapMode.REPEAT,
            this.camera.options.wrapModeY == CenterWrapMode.REPEAT
        )) {
            const tileId = getTileId(tileItem);
            let tile = this._allTiles.get(tileId);
            if (!tile) {
                tile = new Tile(tileItem);
                this._requestTile(tileItem);
                this._allTiles.set(tileId, tile);
            }
            this._preloadedTiles.set(tileId, tile);
        }
        */
        // broke current relationships to set them up again but with new set of visible tiles
        for (const tile of this._allTiles.values()) {
            tile.toBeReplacedBy.clear();
            tile.replacementFor.clear();
        }
        // TODO: optimize this n^2 relationships resolver
        for (const currentTile of this._currentTiles.values()) {
            for (const tile of this._allTiles.values()) {
                if (tile.isReadyToVisualize &&
                    (Object(__WEBPACK_IMPORTED_MODULE_1__vector_api_util_tile_system__["b" /* isParent */])(tile.tileItem, currentTile.tileItem) || Object(__WEBPACK_IMPORTED_MODULE_1__vector_api_util_tile_system__["b" /* isParent */])(currentTile.tileItem, tile.tileItem))) {
                    tile.toBeReplacedBy.add(currentTile);
                    currentTile.replacementFor.add(tile);
                }
            }
        }
        // remove invisible
        for (const tile of this._allTiles.values()) {
            if (!this._currentTiles.has(tile.id) && tile.toBeReplacedBy.size === 0) {
                this._updateTileData(NO_TILES_TO_HANDLE, [tile]);
                if (!this._preloadedTiles.has(tile.id)) {
                    this._destroyTile(tile);
                }
            }
        }
        // this checks prevents leaks of tiles when quick zoom-in/zoom-out happens
        for (const tile of this._currentTiles.values()) {
            if (tile.isReadyToVisualize) {
                this._checkTileReplacements(tile);
            }
        }
    }
    /**
     * Shows/hides tiles if they are not shown/hidden yet. It notifies subclasses by calling appropriate
     * abstract method. Even though visible/invisible tiles are not supposed to be shown/hidden again,
     * there are cases where it simplifies tile visualization logic.
     * It is important to have exactly "update", not "add"/"remove" separately, as some business logic may rely on it,
     * e.g. morphing visible data or managing shared resources.
     */
    _updateTileData(toShow, toRemove) {
        const visible = Array.from(Object(__WEBPACK_IMPORTED_MODULE_2__util_iterable__["b" /* filterIterable */])(flattenDataPortions(toShow), FILTER_INVISIBLE), DATA_MAPPER);
        const invisible = Array.from(Object(__WEBPACK_IMPORTED_MODULE_2__util_iterable__["b" /* filterIterable */])(flattenDataPortions(toRemove), FILTER_VISIBLE), DATA_MAPPER);
        if (visible.length > 0 || invisible.length > 0) {
            this._onTileDataUpdate(visible, invisible);
            for (const dataPortion of flattenDataPortions(toShow)) {
                dataPortion.isVisible = true;
            }
            for (const dataPortion of flattenDataPortions(toRemove)) {
                dataPortion.isVisible = false;
            }
        }
    }
    /**
     * Removes tile if is not removed with calling all appropriate callbacks (abstract methods)
     * to notify descendant classes. Even though removed tile is not supposed to be removed again,
     * allowing this makes much simpler tile management, especially in tile replacements logic where multiple
     * tiles can have links to the same tile (that is to be removed).
     */
    _destroyTile(tile) {
        if (!tile.isRemoved) {
            tile.isRemoved = true;
            this._allTiles.delete(tile.id);
            this._currentTiles.delete(tile.id);
            this._preloadedTiles.delete(tile.id);
            // issue cancellation also in case there are non processed data enqueued to try to save some efforts
            this._cancelTileRequest(tile.tileItem);
            this._onTileDestroy(tile.tileItem, tile.data.map(DATA_MAPPER));
        }
    }
    _isTileStillActive(tileItem) {
        return this._allTiles.has(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem));
    }
    /**
     * Checks tiles that could be replaced by this one, should be called when tile becomes ready to visualize.
     * As overlapping relationships can happen in both directions (children by parents / parent by children) this
     * method goes one step deeper, i.e. it check not only tiles that should be replaced (to remove them),
     * but also all tiles that cover the replaced ones (to show them).
     */
    _checkTileReplacements(tile) {
        const toDestroy = new Set();
        const toShow = new Set();
        for (const tileToReplace of tile.replacementFor) {
            if (Object(__WEBPACK_IMPORTED_MODULE_2__util_iterable__["a" /* allOfIterable */])(tileToReplace.toBeReplacedBy, (tile) => tile.isReadyToVisualize)) {
                toDestroy.add(tileToReplace);
                for (const tileToShow of tileToReplace.toBeReplacedBy) {
                    toShow.add(tileToShow);
                }
            }
        }
        if (tile.replacementFor.size === 0) {
            toShow.add(tile);
        }
        this._updateTileData(toShow, toDestroy);
        for (const tileToDestroy of toDestroy) {
            this._destroyTile(tileToDestroy);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TileBasedAdapter;



/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_function__ = __webpack_require__(115);

class Adapter {
    constructor(engine, camera, cameraUpdateDelay = 25) {
        this.engine = engine;
        this.camera = camera;
        this._cameraUpdateListener = Object(__WEBPACK_IMPORTED_MODULE_0__util_function__["a" /* debounce */])(this._onCameraUpdate.bind(this), cameraUpdateDelay);
        camera.onUpdate.addListener(this._cameraUpdateListener);
    }
    destroy() {
        this.camera.onUpdate.removeListener(this._cameraUpdateListener);
    }
    /**
     * Camera update handler, by default do nothing.
     */
    _onCameraUpdate() { }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Adapter;



/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = debounce;
/**
 * Creates new function which execution is "debounced".
 */
function debounce(func, wait) {
    let timeout;
    return function (...args) {
        const later = () => {
            timeout = undefined;
            func.apply(this, args);
        };
        if (timeout !== undefined) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(later, wait);
    };
}


/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = isParent;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_scalar__ = __webpack_require__(11);

/**
 * @return `true` if the first param overlaps the second in tile hierarchy.
 */
function isParent(potentialParent, possibleChild) {
    const zoomDiff = possibleChild.zoom - potentialParent.zoom;
    return zoomDiff > 0 &&
        possibleChild.x >> zoomDiff == potentialParent.x &&
        possibleChild.y >> zoomDiff == potentialParent.y;
}
class TileCoordinateSystem {
    constructor(zoom) {
        this._zoom = Math.ceil(Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(zoom, 0, 31));
        this._tileSize = 2 / (1 << this._zoom);
    }
    getZoom() {
        return this._zoom;
    }
    /**
     * @return Tile side length in units of the world coordinate system.
     */
    getTileSize() {
        return this._tileSize;
    }
    /**
     * @return Top left corner coordinates of the tile.
     */
    getTileOffset(tile) {
        return {
            x: this.getTileSize() * tile.x - 1,
            y: 1 - this.getTileSize() * tile.y
        };
    }
    toTileCoordinates(worldCoordinates) {
        return {
            x: (worldCoordinates.x + 1) / this._tileSize,
            y: (1 - worldCoordinates.y) / this._tileSize
        };
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TileCoordinateSystem;



/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = computeVisibleTiles;
const TILE_0_0_0 = { x: 0, y: 0, zoom: 0 };
/**
 * Computes set of tiles visible through a camera. Tiles in the set are guaranteed
 * to be unique.
 *
 * FIXME(dmikis) The uniqueness guarantee is broken currently, but code that uses
 *      this function doesn't suffer from that.
 *
 * @param camera The camera.
 * @returns An iterator over visible tile items.
 */
function* computeVisibleTiles(camera) {
    const zoom = Math.round(camera.zoom);
    if (zoom === 0) {
        // The only tile on zoom 0 encompasses the whole world. Thus there's
        // little to no point computing that camera sees it: we can tell that
        // right away.
        yield TILE_0_0_0;
        return;
    }
    const tileCount = 1 << zoom;
    const tileIdxMask = tileCount - 1;
    // The idea behind the code below is quite simple: determine columns of the
    // tile grid that are visible to the camera, then for each column find
    // range of row indices that are visible.
    // Here's how we approach computing tile indices from world coordinates.
    // First, we transform world coordinates from [-1, 1] range to [0, 2],
    // dealing with inconsistency with Y axis direction in world and tile grid
    // coordinate system. Let's designate such a coordinate as C (for either X
    // or Y). Size of a tile is 2 / tileCount. Thus,
    //
    //      tileIdx = Math.floor(C / (2 / tileCount))
    //              = Math.floor(C * tileCount / 2)
    //
    const { minX, maxX, minY, maxY } = camera.getVisibleRegionBBox();
    const { wrapModeX, wrapModeY } = camera.options;
    const minTX = Math.floor((minX + 1) * tileCount / 2);
    const maxTX = Math.floor((maxX + 1) * tileCount / 2);
    const columnCount = maxTX - minTX + 1;
    // Arrays of indices of bottommost and topmost tiles correspondingly for
    // each column.
    // FIXME(dmikis) If number of columns is too large, we'll consume a lot of
    //      memory here. There's a method to do without the arrays, but it's a
    //      bit more complicated to implement.
    const minYs = new Array(columnCount);
    const maxYs = new Array(columnCount);
    // Common sense suggests that those indices can't be greater (less) than the
    // index of a tile row intersected by a line y = minY (y = maxY). Note that
    // maxY corresponds to a tile row with lesser index, not other way around.
    minYs.fill(Math.floor((1 - minY) * tileCount / 2));
    maxYs.fill(Math.floor((1 - maxY) * tileCount / 2));
    const visiblePolygon = camera.getVisibleRegion();
    const visiblePolygonLength = visiblePolygon.length;
    let prevX = visiblePolygon[visiblePolygonLength - 1].x + 1;
    let prevY = 1 - visiblePolygon[visiblePolygonLength - 1].y;
    let prevTX = Math.floor(prevX * tileCount / 2);
    let prevTY = Math.floor(prevY * tileCount / 2);
    // Iterate over edges of visible polygon of the camera to compute index of
    // topmost and bottommost tiles for each column.
    for (let i = 0; i < visiblePolygonLength; ++i) {
        const x = visiblePolygon[i].x + 1;
        const y = 1 - visiblePolygon[i].y;
        const tx = Math.floor(x * tileCount / 2);
        const ty = Math.floor(y * tileCount / 2);
        // For each edge we compute 4-connected line of tiles on the tile grid.
        // Length of a 4-connected line always equals Manhattan distance between
        // its ends. However, to avoid unnecessary computation, we omit last tile
        // for every edge. But, since the polygon is closed, we'll iterate over
        // all tiles intersected by edges anyway.
        const l = Math.abs(tx - prevTX) + Math.abs(ty - prevTY);
        const lx = x - prevX;
        const ly = y - prevY;
        const dtx = lx > 0 ? 1 : -1;
        const dty = ly > 0 ? 1 : -1;
        const a = 2 * dtx * ly;
        const b = -2 * dtx * lx;
        const c = dtx * tileCount * (lx * prevY - ly * prevX) + a * (~dtx >>> 31);
        for (let i = 0, tx = prevTX, ty = prevTY; i < l; ++i) {
            const intercept = a * tx + b * ty + c;
            // The math here is somewhat cumbersome to avoid divisions, but the
            // essence is that we try to check through which side the edge of
            // visible polygon exits the tile. Depending on that we "move" to
            // next tile in either vertical or horizontal direction.
            if (0 <= intercept && intercept <= -b) {
                tx += dtx;
            }
            else {
                ty += dty;
            }
            const yIdx = tx - minTX;
            if (maxYs[yIdx] < ty) {
                maxYs[yIdx] = ty;
            }
            if (minYs[yIdx] > ty) {
                minYs[yIdx] = ty;
            }
        }
        prevX = x;
        prevY = y;
        prevTX = tx;
        prevTY = ty;
    }
    // If the world is repeated along X axis, we need to "fold" the array of columns,
    // i.e. compute union of row intervals for columns tileCount indices apart.
    if (wrapModeX === 2 /* REPEAT */ && columnCount > tileCount) {
        for (let i = 0; i < tileCount; ++i) {
            for (let j = i + tileCount; j < columnCount; j += tileCount) {
                if (maxYs[i] < maxYs[j]) {
                    maxYs[i] = maxYs[j];
                }
                if (minYs[i] > minYs[j]) {
                    minYs[i] = minYs[j];
                }
            }
        }
    }
    // If the world is repeated along Y axis, we need to wrap indices in minYs
    // and maxYs arrays to [0, tileCount) interval.
    if (wrapModeY === 2 /* REPEAT */) {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            const dy = maxYs[i] - minYs[i];
            // If there's more than tileCount rows between maxY and minY, then the
            // world is encompassed somewhere within visible region.
            if (dy > tileCount) {
                minYs[i] = 0;
                maxYs[i] = tileIdxMask;
            }
            else {
                const minY = minYs[i] &= tileIdxMask;
                maxYs[i] = minY + dy;
            }
        }
    }
    else {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            minYs[i] = Math.max(minYs[i], 0);
            maxYs[i] = Math.min(maxYs[i], tileIdxMask);
        }
    }
    if (wrapModeX === 2 /* REPEAT */) {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            const tx = (i + minTX) & tileIdxMask;
            for (let ty = minYs[i]; ty <= maxYs[i]; ++ty) {
                yield {
                    x: tx,
                    y: ty & tileIdxMask,
                    zoom
                };
            }
        }
    }
    else {
        for (let tx = Math.max(minTX, 0), txEnd = Math.min(maxTX, tileIdxMask); tx <= txEnd; ++tx) {
            const i = tx - minTX;
            for (let ty = minYs[i]; ty <= maxYs[i]; ++ty) {
                yield {
                    x: tx,
                    y: ty & tileIdxMask,
                    zoom
                };
            }
        }
    }
}


/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(10);


/**
 * Writer of geometry data of icons.
 */
class IconBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(IconBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Writes an icon to buffers.
     *
     * @param icon Icon to be written to buffer.
     * @param location Image location in atlas.
     * @param size Image size in atlas.
     * @param offset Offset of image points in CSS pixels.
     * @param pixelRatio Ratio of image size in CSS pixels to the size in atlas pixels.
     *
     * @returns Location of the icon data in buffers.
     */
    writeIcon(icon, location, size, offset, pixelRatio) {
        const top = offset.y;
        const bottom = offset.y + size.height * pixelRatio;
        const left = offset.x;
        const right = offset.x + size.width * pixelRatio;
        this.writeVertex(icon.position, left, bottom, location.minX, location.minY);
        this.writeVertex(icon.position, left, top, location.minX, location.maxY);
        this.writeVertex(icon.position, right, bottom, location.maxX, location.minY);
        this.writeVertex(icon.position, right, top, location.maxX, location.maxY);
        this.writeIndicesForContinuousStrip(4);
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer.
     *
     * @param position Position of the vertex in display coordinates.
     * @param uv UVs of the vertex.
     * @return Index of the written vertex.
     */
    writeVertex(position, displacementX, displacementY, uvX, uvY) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(position);
        this._writeHalfWords(displacementX, displacementY);
        this._writeHalfWords(uvX, uvY);
        return vertexIdx;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IconBufferWriter;

/** Description of how a writer stores vertex data. */
IconBufferWriter.ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5122 /* SHORT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
]);


/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__primitive_icon_renderable_icon__ = __webpack_require__(121);


/**
 * API's point object representative. See PointObjects from tile.proto.
 */
class ApiPoint extends __WEBPACK_IMPORTED_MODULE_0__primitive__["a" /* default */] {
    /**
     * Constructs a new point object.
     *
     * @param memorySubChunk
     * @param styles
     * @param allocatedImage
     * @param imageAtlas
     * @param minZoom Minimal camera zoom the point should be still displayed on.
     *      If camera zoom's less than `minZoom` the point doesn't get rendered.
     */
    constructor(memorySubChunk, styles, allocatedImage, imageAtlas, minZoom) {
        super(styles);
        this._allocatedImage = allocatedImage;
        this.renderableIcon = new __WEBPACK_IMPORTED_MODULE_1__primitive_icon_renderable_icon__["a" /* default */](memorySubChunk, imageAtlas, minZoom);
        this._allocatedImage.retain();
    }
    /**
     * Update point's visibility according to the parameter.
     */
    onVisibilityChanged(_isVisible) {
        // TODO
    }
    /**
     * Update point's style according to the parameter.
     */
    onStyleChanged(_style) {
        // TODO
    }
    destroy() {
        super.destroy();
        this.renderableIcon.destroy();
        this._allocatedImage.release();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ApiPoint;



/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Objects are styled using the concept of zoom slices ({@link ZoomSlice} in presentation.proto)
 * where styles are defined per each supported zoom range or invisible if no style specified.
 * This class implements this concept providing proper style according to zoom.
 */
class PrimitivePresentationClass {
    constructor(styles) {
        this._styles = styles;
    }
    /**
     * Returns style that corresponds to the zoom parameter or null if no style found.
     * When null is returned the object must be hidden.
     */
    getStyle(zoom) {
        zoom = Math.round(zoom);
        // TODO: consider using hashmap or something for styles look up
        for (const style of this._styles) {
            if (style.minZoom <= zoom && zoom <= style.maxZoom) {
                return style;
            }
        }
        return null;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PrimitivePresentationClass;



/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__image_renderable_image__ = __webpack_require__(122);

class RenderableIcon extends __WEBPACK_IMPORTED_MODULE_0__image_renderable_image__["a" /* default */] {
    /**
     * Constructs a new renderable icon.
     *
     * @param memorySubChunk
     * @param atlas
     * @param minZoom Minimal camera zoom the icon should be still displayed on.
     *      If camera zoom's less than `minZoom` the icon doesn't get rendered.
     */
    constructor(memorySubChunk, atlas, minZoom) {
        super(memorySubChunk, atlas);
        this.minZoom = minZoom;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableIcon;



/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(8);

class RenderableImage extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    constructor(memorySubChunk, atlas) {
        super(memorySubChunk);
        this.atlas = atlas;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableImage;



/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__ = __webpack_require__(17);

/**
 * Represents an allocated image. Allocated image is a shareable resource that should be resealed
 * when there are no clients use it. As it is not possible to rely on the GC, clients should
 * manually retain their required images and release them when they are not required anymore.
 */
class AllocatedImage extends __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__["a" /* default */] {
    constructor(descriptor, bbox, atlas) {
        super();
        this.descriptor = descriptor;
        this.bbox = bbox;
        this.atlas = atlas;
    }
    destroy() {
        this.atlas.removeImage(this.descriptor);
    }
}
/* unused harmony export AllocatedImage */

/**
 * Manages allocation of images by id.
 */
class IdentifiedImageAtlasManager {
    constructor(imageAtlas) {
        this.imageAtlas = imageAtlas;
        this._locations = new Map();
    }
    get size() {
        return this._locations.size;
    }
    getImage(id, retain = false) {
        const imageLocation = this._locations.get(id);
        if (retain && imageLocation) {
            imageLocation.retain();
        }
        return imageLocation || null;
    }
    allocateImage(descriptor, image) {
        const location = this.imageAtlas.allocateImage(descriptor, image);
        if (location) {
            const image = new AllocatedImage(descriptor, location, this);
            this._locations.set(descriptor.id, image);
            return image;
        }
        return null;
    }
    removeImage(image) {
        const location = this._locations.get(image.id);
        if (location) {
            this.imageAtlas.removeImage(location.bbox);
            this._locations.delete(image.id);
        }
    }
    contains(id) {
        return this._locations.has(id);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IdentifiedImageAtlasManager;



/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__primitive_polygon_renderable_polygon__ = __webpack_require__(125);


/**
 * API's polygon representative. See PolygonObjects from tile.proto.
 */
class ApiPolygon extends __WEBPACK_IMPORTED_MODULE_0__primitive__["a" /* default */] {
    constructor(memorySubChunk, styles, isOpaque) {
        super(styles);
        this.renderablePolygon = new __WEBPACK_IMPORTED_MODULE_1__primitive_polygon_renderable_polygon__["a" /* default */](memorySubChunk, isOpaque);
    }
    destroy() {
        this.renderablePolygon.destroy();
        super.destroy();
    }
    /**
     * Update polygon's visibility according to the parameter.
     */
    onVisibilityChanged(_isVisible) { }
    /**
     * Update polygon's style according to the parameter.
     */
    onStyleChanged(_style) { }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ApiPolygon;



/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(8);

/**
 * Allocated in GPU memory polygon.
 */
class RenderablePolygon extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    constructor(memorySubChunk, isOpaque) {
        super(memorySubChunk);
        this.isOpaque = isOpaque;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderablePolygon;



/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_polyline_renderable_polyline__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__primitive__ = __webpack_require__(6);


class ApiPolyline extends __WEBPACK_IMPORTED_MODULE_1__primitive__["a" /* default */] {
    constructor(memoryChunk, styles, isOpaque) {
        super(styles);
        this.renderablePolyline = new __WEBPACK_IMPORTED_MODULE_0__primitive_polyline_renderable_polyline__["a" /* default */](memoryChunk, isOpaque);
    }
    destroy() {
        this.renderablePolyline.destroy();
        super.destroy();
    }
    onVisibilityChanged(_isVisible) { }
    onStyleChanged(_style) { }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ApiPolyline;



/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__primitive_label_renderable_label__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__primitive_billboard_rectangle_renderable_billboard_rectangle__ = __webpack_require__(129);



/**
 * Base class for API labels: point and curved ones.
 */
class ApiLabel extends __WEBPACK_IMPORTED_MODULE_0__primitive__["a" /* default */] {
    /**
     * Constructs a new label.
     *
     * @param memorySubChunk
     * @param minZoom Minimal camera zoom the label should be still displayed on.
     *      If camera zoom's less than `minZoom` the label doesn't get rendered.
     * @param styles
     * @param glyphAtlas
     * @param backgroundMemorySubChunk
     */
    constructor(memorySubChunk, minZoom, styles, glyphAtlas, backgroundMemorySubChunk) {
        super(styles);
        console.log('Api Label constructor', memorySubChunk._location);
        this.renderableLabel = new __WEBPACK_IMPORTED_MODULE_1__primitive_label_renderable_label__["a" /* default */](memorySubChunk, glyphAtlas, minZoom, backgroundMemorySubChunk ? new __WEBPACK_IMPORTED_MODULE_2__primitive_billboard_rectangle_renderable_billboard_rectangle__["a" /* default */](backgroundMemorySubChunk) : undefined);
    }
    destroy() {
        this.renderableLabel.destroy();
        super.destroy();
    }
    /**
     * Updates label's visibility.
     */
    onVisibilityChanged(_isVisible) {
        // TODO
    }
    /**
     * Updates label's style.
     */
    onStyleChanged(_style) {
        // TODO
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ApiLabel;



/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(8);

/**
 * Allocated in GPU memory label.
 */
class RenderableLabel extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    /**
     * Constructs a new renderable label.
     *
     * @param memorySubChunk
     * @param atlas
     * @param minZoom Minimal camera zoom the point should be still displayed on.
     *      If camera zoom's less than `minZoom` the point doesn't get rendered.
     * @param background
     */
    constructor(memorySubChunk, atlas, minZoom, background) {
        super(memorySubChunk);
        this.atlas = atlas;
        this.minZoom = minZoom;
        this.background = background;
    }
    destroy() {
        super.destroy();
        if (this.background) {
            this.background.destroy();
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableLabel;



/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class RenderableBillboardRectangle {
    constructor(memorySubChunk) {
        this.memorySubChunk = memorySubChunk;
    }
    destroy() {
        this.memorySubChunk.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableBillboardRectangle;



/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__billboard_image_provider__ = __webpack_require__(131);

/**
 * Image provider that gets images from specific API entry point.
 */
class ApiImageProvider extends __WEBPACK_IMPORTED_MODULE_0__billboard_image_provider__["a" /* ImageProvider */] {
    constructor(imageUrlTemplate) {
        super();
        this._imageUrlTemplate = imageUrlTemplate;
    }
    getImageUrl(id) {
        // API can return scaled images that allows us to request images according
        // to user's DPI and render them properly, non-integer numbers are accepted.
        return this._imageUrlTemplate
            .replace('{{id}}', id)
            .replace('{{scale}}', devicePixelRatio.toString());
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ApiImageProvider;



/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Abstract image content provider, concrete implementations should specify the entry point in getImageUrl().
 */
class ImageProvider {
    /**
     * Gets image bitmap via an HTMLImageElement and a canvas.
     */
    getImage(id) {
        return new Promise((resolve, reject) => {
            const imageElement = new Image();
            imageElement.crossOrigin = 'anonymous';
            imageElement.onload = () => resolve(imageElement);
            imageElement.onerror = reject;
            imageElement.src = this.getImageUrl(id);
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageProvider;



/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(8);

/**
 * A general primitive that is best suitable for storing simple colored 3D models.
 */
class RenderableModel extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableModel;



/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__primitive_polyline_renderable_textured_polyline__ = __webpack_require__(134);


class TexturedPolyline extends __WEBPACK_IMPORTED_MODULE_0__primitive__["a" /* default */] {
    constructor(memoryChunk, styles, atlas, allocatedImage) {
        super(styles);
        this._allocatedImage = allocatedImage;
        this.renderablePolyline = new __WEBPACK_IMPORTED_MODULE_1__primitive_polyline_renderable_textured_polyline__["a" /* default */](memoryChunk, atlas);
        this._allocatedImage.retain();
    }
    onVisibilityChanged(_isVisible) { }
    onStyleChanged(_style) { }
    destroy() {
        super.destroy();
        this.renderablePolyline.destroy();
        this._allocatedImage.release();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolyline;



/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_polyline__ = __webpack_require__(31);

class RenderableTexturedPolyline extends __WEBPACK_IMPORTED_MODULE_0__renderable_polyline__["a" /* default */] {
    constructor(memoryChunk, atlas) {
        super(memoryChunk, false);
        this.atlas = atlas;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableTexturedPolyline;



/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__textured_polyline_geometry__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_gputypes__ = __webpack_require__(12);




/**
 * Writer of geometry data of polyline hulls.
 */
class TexturedPolylineBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(TexturedPolylineBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Generates a hull for a polyline and writes it to the writer.
     *
     * @param polyline The polyline to be written.
     * @param width Thickness of the polyline.
     * @param worldToPxFactor Ratio of world coordinates to pixels.
     * @param imageLocation Image location in atlas.
     */
    writeTexturedPolyline(polyline, width, worldToPxFactor, imageLocation, zIndex) {
        Object(__WEBPACK_IMPORTED_MODULE_2__textured_polyline_geometry__["a" /* default */])(this, polyline.vertices, worldToPxFactor, imageLocation, width, Object(__WEBPACK_IMPORTED_MODULE_3__util_gputypes__["c" /* int24ToFloat */])(zIndex + 1));
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer.
     *
     * @param position Position of the vertex in world coordinates.
     * @param displacement Displacement vector, in most cases must be normalized, the width is considered in shaders.
     * @param width Thickness of the polyline.
     * @param patterWidth Width of the image that is repeated along the polyline.
     * @param length Length of the polyline for current vertex, needed to correctly calculate image uv x coordinate.
     * @return Index of the written vertex.
     */
    writeVertex(position, displacement, width, patterWidth, length, uv, zIndex) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(position);
        this._writeFloat32(displacement.x);
        this._writeFloat32(displacement.y);
        this._writeHalfWords(uv.x, uv.y);
        this._writeFloat32(zIndex);
        this._writeFloat32(width);
        this._writeHalfWords(patterWidth, length);
        return vertexIdx;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolylineBufferWriter;

/** Description of how a writer stores vertex data. */
TexturedPolylineBufferWriter.ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        12 /* AUX1 */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = writeTexturedPolylineGeometry;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);

/**
 * Writes polyline image geometry (set of triangles that draw up a solid thick polyline) into a buffer writer.
 *
 * @param writer Output buffer writer.
 * @param polyline Polyline to be written.
 * @param worldToPxFactor Ratio of world coordinates to pixels.
 * @param imageLocation Image location in atlas.
 * @param width Thickness of the polyline.
 * @param color Color of the polyline.
 */
function writeTexturedPolylineGeometry(writer, polyline, worldToPxFactor, imageLocation, width, z) {
    const hWidth = width / 2;
    const patternWidth = imageLocation.maxX - imageLocation.minX;
    const segment = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* create */](0, 0);
    const dir = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* create */](0, 0);
    const prevDir = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* create */](0, 0);
    const norm = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* create */](0, 0);
    const normInv = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* create */](0, 0);
    const uv = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* create */](imageLocation.minX, 0);
    let prevBottomRight = -1;
    let prevTopRight = -1;
    let length = 0;
    let prevLength = 0;
    for (let i = 1; i < polyline.length; i++) {
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["k" /* sub */](polyline[i], polyline[i - 1], segment);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["i" /* normalize */](segment, dir);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["j" /* rotate90 */](dir, norm);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["h" /* muln */](norm, -1, normInv);
        // segment is written as a rectangle (two triangles)
        uv.y = imageLocation.minY;
        const topLeft = writer.writeVertex(polyline[i - 1], norm, hWidth, patternWidth, length, uv, z);
        uv.y = imageLocation.maxY;
        const bottomLeft = writer.writeVertex(polyline[i - 1], normInv, hWidth, patternWidth, length, uv, z);
        // update length of the polyline in pixels
        length += __WEBPACK_IMPORTED_MODULE_0__math_vector2__["g" /* length */](segment) / worldToPxFactor;
        uv.y = imageLocation.minY;
        const topRight = writer.writeVertex(polyline[i], norm, hWidth, patternWidth, length, uv, z);
        uv.y = imageLocation.maxY;
        const bottomRight = writer.writeVertex(polyline[i], normInv, hWidth, patternWidth, length, uv, z);
        // write line join that fills an empty space on corners
        if (1 < i && i < polyline.length) {
            uv.y = (imageLocation.maxY + imageLocation.minY) / 2;
            const joinPointIndex = writer.writeVertex(polyline[i - 1], __WEBPACK_IMPORTED_MODULE_0__math_vector2__["a" /* ZERO */], hWidth, patternWidth, prevLength, uv, z);
            // find out where the fracture of segments is located to create correct join with minimum overdraw
            const turnLeft = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* crossZ */](prevDir, dir) > 0;
            if (turnLeft) {
                writer.writeIndices([
                    joinPointIndex, bottomLeft, prevBottomRight
                ]);
            }
            else {
                writer.writeIndices([
                    joinPointIndex, prevTopRight, topLeft
                ]);
            }
        }
        writer.writeIndices([
            topLeft, topRight, bottomLeft,
            topRight, bottomRight, bottomLeft
        ]);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["d" /* copy */](dir, prevDir);
        prevBottomRight = bottomRight;
        prevTopRight = topRight;
        prevLength = length;
    }
}


/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Manages allocation of requested images. The same images can be requested multiple times from different places,
 * this class takes over duplication of HTTP requests/atlas allocations providing simple async interface for
 * getting allocated images.
 */
class ImageManager {
    constructor(atlas, provider) {
        this._atlas = atlas;
        this._provider = provider;
        this._requests = new Map();
    }
    /**
     * Pay attention that resulted allocated image is "retained", so it must be released
     * once it is passed to a responsible client.
     */
    getImage(id) {
        const allocatedImage = this._atlas.getImage(id, true);
        if (allocatedImage) {
            return Promise.resolve(allocatedImage);
        }
        else {
            const request = this._requests.get(id);
            if (request) {
                request.then((allocatedImage) => allocatedImage && allocatedImage.retain());
                return request;
            }
            else {
                const request = this._provider
                    .getImage(id)
                    .then((image) => this._onImageReceived(id, image), () => this._onImageFailed(id));
                this._requests.set(id, request);
                return request;
            }
        }
    }
    _onImageReceived(id, image) {
        const allocatedImage = this._atlas.allocateImage({ id, width: image.width, height: image.height }, image);
        this._requests.delete(id);
        return allocatedImage;
    }
    _onImageFailed(id) {
        this._requests.delete(id);
        return null;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageManager;



/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__primitive_polygon_renderable_textured_polygon__ = __webpack_require__(139);


class ApiTexturedPolygon extends __WEBPACK_IMPORTED_MODULE_0__primitive__["a" /* default */] {
    constructor(memoryChunk, allocatedImage) {
        super([]);
        this._allocatedImage = allocatedImage;
        this.renderablePolygon = new __WEBPACK_IMPORTED_MODULE_1__primitive_polygon_renderable_textured_polygon__["a" /* default */](memoryChunk, allocatedImage.atlas.imageAtlas);
        this._allocatedImage.retain();
    }
    onVisibilityChanged(_isVisible) { }
    onStyleChanged(_style) { }
    destroy() {
        super.destroy();
        this.renderablePolygon.destroy();
        this._allocatedImage.release();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ApiTexturedPolygon;



/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(8);

class RenderableTexturedPolygon extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    constructor(memoryChunk, atlas) {
        super(memoryChunk);
        this.atlas = atlas;
    }
    destroy() {
        this.memorySubChunk.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableTexturedPolygon;



/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_buffer_rewriter__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__textured_polygon_attribute_mapping__ = __webpack_require__(34);


class TexturedPolygonBufferRewriter extends __WEBPACK_IMPORTED_MODULE_0__util_buffer_rewriter__["a" /* default */] {
    constructor(buffers) {
        super(__WEBPACK_IMPORTED_MODULE_1__textured_polygon_attribute_mapping__["a" /* TEXTURED_POLYGON_ATTRIBUTE_MAPPING */], buffers);
    }
    /**
     * @param location Location of the polygon in memory.
     * @param imageLocation Location of the pattern in atlas.
     * @param imageScale How world coordinates relate to the image size.
     */
    rewriteUV(location, imageLocation, imageScale) {
        const uvOffset = this._getAttribOffset(4 /* UV */);
        const scaleOffset = this._getAttribOffset(11 /* AUX */);
        this._forEachVertex(location, (writer) => {
            writer.writeHalfWords(uvOffset, imageLocation.minX, imageLocation.minY);
            writer.writeHalfWords(uvOffset + 1, imageLocation.maxX - imageLocation.minX, imageLocation.maxY - imageLocation.minY);
            writer.writeFloat32(scaleOffset, imageScale);
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolygonBufferRewriter;



/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__buffer_writer__ = __webpack_require__(10);

/**
 * Class that is exposed as an interface for writing to a specific vertex attribute.
 */
class VertexWriter {
    constructor(vertexBuffer) {
        this._vertexBuffer = new Uint32Array(vertexBuffer.buffer, 0, vertexBuffer.length);
        this._vertexBufferFloat32View = new Float32Array(vertexBuffer.buffer, 0, vertexBuffer.length);
    }
    /**
     * Writes float attribute into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeFloat32(attribOffset, value) {
        this._vertexBufferFloat32View[this.vertexOffset + attribOffset] = value;
    }
    /**
     * Writes a word attribute into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeWord(attribOffset, value) {
        this._vertexBuffer[this.vertexOffset + attribOffset] = value;
    }
    /**
     * Writes two half word attribute values into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeHalfWords(attribOffset, v1, v2) {
        this.writeWord(attribOffset, v2 << 16 | v1 & 0xffff);
    }
}
/**
 * Provides some utils for rewriting vertex attribute values, see VertexWriter and tests for some tips of how to do it.
 * TODO: consider supporting of separate buffers for different attributes, that will make this class less useful
 */
class BufferRewriter {
    constructor(attribMapping, buffers) {
        this._attribMapping = attribMapping;
        this._buffers = buffers;
    }
    /**
     * Walks over all vertices exposing VertexWriter for each one by calling the handler argument.
     */
    _forEachVertex(location, handler) {
        const vertexWriter = new VertexWriter(this._buffers[location.bufferIndex].vertexBuffer);
        const vertexByteSize = this._attribMapping.vertexByteSize;
        for (let i = 0; i < location.vertexByteLength; i += vertexByteSize) {
            vertexWriter.vertexOffset = (location.vertexByteOffset + i) / __WEBPACK_IMPORTED_MODULE_0__buffer_writer__["a" /* WORD_BYTE_SIZE */];
            handler(vertexWriter);
        }
    }
    /**
     * @returns Offset in words (4 bytes) of specific attribute in a vertex (format is defined by AttributeMapping).
     */
    _getAttribOffset(attrib) {
        const attribPointer = this._attribMapping.get(attrib);
        return attribPointer ? attribPointer.offset / __WEBPACK_IMPORTED_MODULE_0__buffer_writer__["a" /* WORD_BYTE_SIZE */] : -1;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BufferRewriter;



/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(2);

/** Description of how a writer stores vertex data. */
const BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5122 /* SHORT */,
            normalized: true
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        11 /* AUX */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING;



/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(2);

/** Description of how a writer stores vertex data. */
const POINT_LABEL_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        8 /* OUTLINE_COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = POINT_LABEL_ATTRIBUTE_MAPPING;



/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(2);

/** Description of how a writer stores vertex data. */
const CURVED_LABEL_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 3,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        8 /* OUTLINE_COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        12 /* AUX1 */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        13 /* AUX2 */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        14 /* AUX3 */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        15 /* AUX4 */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = CURVED_LABEL_ATTRIBUTE_MAPPING;



/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polyline_attribute_mapping__ = __webpack_require__(36);


/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const TRANSPARENT_POLYLINE_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */](__WEBPACK_IMPORTED_MODULE_1__polyline_attribute_mapping__["a" /* POLYLINE_ATTRIBUTE_MAPPING */]);
/* harmony export (immutable) */ __webpack_exports__["a"] = TRANSPARENT_POLYLINE_ATTRIBUTE_MAPPING;



/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_worker__ = __webpack_require__(147);

class TileProviderWorkerClient extends __WEBPACK_IMPORTED_MODULE_0__util_worker__["a" /* WebWorkerClient */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TileProviderWorkerClient;



/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export messageIs */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__event_emitter__ = __webpack_require__(4);
/**
 * Base interface for webworker messages, both incoming and outgoing ones.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Transferable
 */

const MESSAGE_BATCH_MAX_SIZE = 50;
const FLUSH_TIMEOUT = 50;
// each subsequent message debounces postMessage call, that can lead to infinite delay, this const limits it
const MAX_FLUSH_TIMEOUT = 250;
/**
 * Checks message type with type guarding. It gives a little bit more elegant alternative
 * to tagged type unions providing the same type safety.
 *
 * @param message to be checked
 * @param type the value of the "type" property
 * @return {boolean}
 */
function messageIs(message, type) {
    return message.type === type;
}
/**
 * Base class for both sides of a webworker: its implementation (separate js that is run in a worker thread) and
 * a controller for the main thread. They have similar mechanism of sending/receiving messages that is implement here.
 */
class WebWorkerCommunicator {
    constructor(addressee) {
        this._addressee = addressee;
        this._events = new __WEBPACK_IMPORTED_MODULE_0__event_emitter__["a" /* EventEmitter */]();
        this._listeners = new Map();
        this._transferableExtractors = new Map();
        this._messages = [];
        this._transferables = [];
        this._timeoutHandle = 0;
        this._flushMessagesBinded = this._flushMessages.bind(this);
    }
    setTransferableExtractor(type, extractor) {
        this._transferableExtractors.set(type, extractor);
    }
    /**
     * Send a message to the opposite side of the web worker communication channel.
     * Messages are batched by delaying postMessage call to group messages that come during this delay and minimize
     * the number of interprocess communications that badly affect performance.
     *
     * @param message Message to be sent.
     * @param urgency IMMEDIATE forces message to be sent immediately (synchronous call) with no batching delay,
     *                DEFAULT debounces sending for another FLUSH_TIMEOUT.
     */
    sendMessage(message, urgency = 0 /* DEFAULT */) {
        const transferableExtractor = this._transferableExtractors.get(message.type);
        const transferables = transferableExtractor ? transferableExtractor(message) : undefined;
        const isFirstMessageInBatch = (this._messages.length === 0);
        if (isFirstMessageInBatch) {
            this._firstMessageTime = performance.now();
        }
        // Send messages asynchronously packing them into one message.
        // We don't want to abuse the web worker communication channel and
        // send messages asynchronously in short period of time or many messages synchronously.
        this._messages.push(message);
        if (transferables) {
            this._transferables.concat(transferables);
        }
        clearTimeout(this._timeoutHandle);
        if (this._messages.length > MESSAGE_BATCH_MAX_SIZE ||
            urgency === 1 /* IMMEDIATE */ ||
            (!isFirstMessageInBatch && (performance.now() - this._firstMessageTime) > MAX_FLUSH_TIMEOUT)) {
            this._flushMessages();
        }
        else {
            this._timeoutHandle = setTimeout(this._flushMessagesBinded, FLUSH_TIMEOUT);
        }
    }
    /**
     * Sends request message to/from worker as promise, the other side can respond and the promise is resolved.
     * Request/response is synchronized by the requestId field.
     */
    request(request, urgency) {
        return new Promise((resolve) => {
            request.requestId = (Date.now() << 16) | (0x10000 * Math.random());
            const listener = (message) => {
                if (messageIs(message, request.responseType) && message.requestId === request.requestId) {
                    resolve(message);
                    this.off(listener);
                }
            };
            this._events.addListener(listener);
            this.sendMessage(request, urgency);
        });
    }
    /**
     * Responds to provided request.
     */
    respond(request, response, urgency) {
        response.requestId = request.requestId;
        this.sendMessage(response, urgency);
    }
    /**
     * Sets a listener to specific type of incoming messages.
     */
    on(type, listener) {
        const typeSafeListener = (message) => {
            if (messageIs(message, type)) {
                listener(message);
            }
        };
        this._listeners.set(listener, typeSafeListener);
        this._events.addListener(typeSafeListener);
    }
    /**
     * Removes incoming messages listener.
     */
    off(listener) {
        const typeSafeListener = this._listeners.get(listener);
        if (typeSafeListener) {
            this._events.removeListener(typeSafeListener);
        }
    }
    /**
     * Starts listening for incoming messages.
     */
    listen() {
        this._addressee.onmessage = ({ data: messages }) => {
            for (const message of messages) {
                this.onMessage(message);
            }
        };
    }
    /**
     * Handler of incoming messages.
     */
    onMessage(message) {
        this._events.fire(message);
    }
    _flushMessages() {
        this._addressee.postMessage(this._messages, this._transferables);
        this._messages.length = 0;
        this._transferables.length = 0;
    }
}
/* unused harmony export WebWorkerCommunicator */

/**
 * Base class for a webworker controller for the main thread code.
 * It also wraps creation of a native Worker.
 */
class WebWorkerClient extends WebWorkerCommunicator {
    /**
     * @param url URL of webworker's deployed js file
     */
    constructor(url) {
        const worker = new Worker(url);
        super(worker);
        this._worker = worker;
        this.listen();
    }
    destroy() {
        this._worker.terminate();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = WebWorkerClient;

/**
 * Base class for a webworker thread implementation. Concrete class should be the entry point for a webworker js build:
 *     new ConcreteWebWorkerImplementation(<DedicatedWorkerGlobalScope>self).run();
 */
class WebWorkerImplementation extends WebWorkerCommunicator {
    run() {
        this.listen();
    }
}
/* unused harmony export WebWorkerImplementation */



/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = extractTransferables;
/**
 * Extract ArrayBuffers (that are tansferable) from pages.
 */
function extractTransferables(pages, output) {
    for (const page of pages) {
        output.push(page.vertexBuffer.buffer, page.indexBuffer.buffer);
    }
}


/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polygon_attribute_mapping__ = __webpack_require__(35);


/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */](__WEBPACK_IMPORTED_MODULE_1__polygon_attribute_mapping__["a" /* POLYGON_ATTRIBUTE_MAPPING */]);
/* harmony export (immutable) */ __webpack_exports__["a"] = TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING;



/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_model__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_tile_provider_worker_messages__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__primitive_model_model_buffer_writer__ = __webpack_require__(33);




const EMPTY_LIST = [];
class ScenePrimitiveManager {
    constructor(extract, append = () => { }, remove = () => { }) {
        this._extract = extract;
        this._append = append;
        this._remove = remove;
    }
    /**
     * This method specifies the order in which tiles are replaced: firstly remove old tiles and then add new ones.
     * This order is preferable because it reduces (potentially) fragmentation and releases limited resources decreasing
     * the chances (ah, snap) of corresponding errors.
     */
    updateScene(scene, camera, dataToShow, dataToRemove) {
        this._removeFromScene(scene, dataToRemove);
        this._addToScene(scene, camera, dataToShow);
    }
    destroy(data) {
        for (const primitive of this._extract(data) || EMPTY_LIST) {
            this._destroyPrimitive(primitive);
        }
    }
    _addToScene(scene, camera, dataToShow) {
        for (const data of dataToShow) {
            for (const primitive of this._extract(data) || EMPTY_LIST) {
                this._addPrimitive(scene, camera, primitive);
            }
        }
    }
    _removeFromScene(scene, dataToHide) {
        for (const data of dataToHide) {
            for (const primitive of this._extract(data) || EMPTY_LIST) {
                this._removePrimitive(scene, primitive);
            }
        }
    }
    _addPrimitive(scene, camera, primitive) {
        this._append(scene, primitive);
        primitive.setZoom(camera.zoom);
    }
    _removePrimitive(scene, primitive) {
        this._remove(scene, primitive);
    }
    _destroyPrimitive(primitive) {
        primitive.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = ScenePrimitiveManager;

/**
 * Special primitive manager that monitors polygons with external models, requests these models, checks
 * their visibility and destroy them when no references are remaining.
 */
class ExternalMeshScenePrimitiveManager extends ScenePrimitiveManager {
    constructor(renderLoop, geometryProvider, memoryManager) {
        super((data) => data.externalMeshes);
        this._renderLoop = renderLoop;
        this._tileProvider = geometryProvider;
        this._memoryManager = memoryManager;
        this._externalMeshes = new Map();
    }
    /**
     * It is important to make sure new tiles are added first and then old ones are removed, since these references are
     * monitored to know when to destroy externally requested models. And if tiles are removed first it is possible to
     * reset all the references and destroy the model while it can be requested right away by new tiles to show,
     * causing unnecessary model request/parsing/allocation.
     */
    updateScene(scene, camera, dataToShow, dataToRemove) {
        this._addToScene(scene, camera, dataToShow);
        this._removeFromScene(scene, dataToRemove);
    }
    _addPrimitive(scene, _camera, primitive) {
        const id = this._getId(primitive.externalMesh);
        let external = this._externalMeshes.get(id);
        if (!external) {
            external = {
                polygons: new Set(),
                visiblePolygons: new Set(),
                isVisible: false
            };
            this._externalMeshes.set(id, external);
            this._tileProvider.request({
                type: __WEBPACK_IMPORTED_MODULE_1__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].MESH_REQUEST,
                responseType: __WEBPACK_IMPORTED_MODULE_1__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].MESH_RESPONSE,
                mesh: primitive.externalMesh,
                styles: primitive.styles
            }).then((response) => {
                if (!this._externalMeshes.get(id)) {
                    return;
                }
                const location = response.location;
                const memoryChunks = response.pages.map((page) => this._memoryManager.allocate(page.vertexBuffer, page.indexBuffer, __WEBPACK_IMPORTED_MODULE_3__primitive_model_model_buffer_writer__["a" /* default */].ATTRIBUTE_MAPPING));
                external.mesh = new __WEBPACK_IMPORTED_MODULE_0__primitive_model__["b" /* default */]([], new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[location.bufferIndex], location));
                memoryChunks.forEach((chunk) => chunk.release());
                this._showExternal(scene, external);
            });
        }
        external.visiblePolygons.add(primitive);
        external.polygons.add(primitive);
        this._showExternal(scene, external);
    }
    _removePrimitive(scene, primitive) {
        const external = this._externalMeshes.get(this._getId(primitive.externalMesh));
        if (external) {
            external.visiblePolygons.delete(primitive);
            this._hideExternal(scene, external);
        }
    }
    _destroyPrimitive(primitive) {
        const id = this._getId(primitive.externalMesh);
        const external = this._externalMeshes.get(id);
        if (external) {
            external.polygons.delete(primitive);
            if (external.polygons.size === 0) {
                primitive.destroy();
                if (external.mesh) {
                    external.mesh.destroy();
                }
                this._externalMeshes.delete(id);
                // if no mesh yet returned cancel request
                if (!external.mesh) {
                    this._tileProvider.sendMessage({
                        type: __WEBPACK_IMPORTED_MODULE_1__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].MESH_REQUEST_CANCEL,
                        mesh: primitive.externalMesh
                    });
                }
            }
        }
    }
    _showExternal(scene, external) {
        if (!external.isVisible && external.visiblePolygons.size > 0 && external.mesh) {
            scene.addModel(external.mesh.renderableModel);
            external.isVisible = true;
            this._renderLoop.update();
        }
    }
    _hideExternal(scene, external) {
        if (external.isVisible && external.visiblePolygons.size === 0 && external.mesh) {
            scene.removeModel(external.mesh.renderableModel);
            external.isVisible = false;
        }
    }
    _getId(mesh) {
        return mesh.objectId + mesh.meshId;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ExternalMeshScenePrimitiveManager;



/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const MAX_DEQUEUE_TIMEOUT = 100; // ms
// TODO: remove this shim when all supported browsers implement it
const SHIMMED_PROCESSING_DURATION_MS = 25;
window.cancelIdleCallback = window.cancelIdleCallback || window.clearTimeout;
window.requestIdleCallback = window.requestIdleCallback || function (handler) {
    const startTime = performance.now();
    return setTimeout(() => {
        handler({
            didTimeout: false,
            timeRemaining: () => Math.max(0, SHIMMED_PROCESSING_DURATION_MS - (performance.now() - startTime))
        });
    });
};
/**
 * It is a task queue. Tasks are dequeued during idle period.
 */
class IdleTaskQueue {
    constructor() {
        this._queue = [];
        this._dequeueIdleHandle = 0;
    }
    destroy() {
        cancelIdleCallback(this._dequeueIdleHandle);
    }
    /**
     * Enqueues a task to the queue.
     *
     * @param task The task.
     */
    enqueue(execute) {
        this._queue.push(execute);
        this._run();
    }
    _dequeue(deadline) {
        while ((deadline.didTimeout || deadline.timeRemaining() > 0) && this._queue.length) {
            const execute = this._queue.shift();
            execute();
        }
        this._dequeueIdleHandle = 0;
        if (this._queue.length) {
            this._run();
        }
    }
    _run() {
        if (!this._dequeueIdleHandle) {
            this._dequeueIdleHandle = requestIdleCallback((deadline) => {
                this._dequeue(deadline);
            }, { timeout: MAX_DEQUEUE_TIMEOUT });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IdleTaskQueue;



/***/ })
/******/ ]);
;console.warn(`Hash: 0b4195e2c65e8bbca20d
Version: webpack 3.8.1
Time: 146ms
   Asset    Size  Chunks         Chunk Names
index.ts  465 kB       0  [big]  index
   [0] ./src/render/state.ts 3.13 kB {0}
   [4] ./src/util/event_emitter.ts 878 bytes {0}
   [7] ./src/math/vector3.ts 10.2 kB {0}
   [9] ./src/math/matrix4.ts 8.32 kB {0}
  [11] ./src/math/scalar.ts 1.57 kB {0}
  [14] ./src/util/color.ts 1.84 kB {0}
  [38] ./src/index.ts 6.82 kB {0}
  [39] ./src/camera/camera.ts 10.5 kB {0}
  [43] ./src/render/context.ts 31 kB {0}
  [52] ./src/engine.ts 2.26 kB {0}
 [112] ./src/adapters/vector_api/adapter.ts 23.6 kB {0}
 [142] ./src/primitive/billboard_rectangle/attribute_mapping.ts 1.25 kB {0}
 [143] ./src/primitive/label/point_label_attribute_mapping.ts 1.55 kB {0}
 [144] ./src/primitive/label/curved_label_attribute_mapping.ts 2.12 kB {0}
 [145] ./src/primitive/polyline/transparent_polyline_attribute_mapping.ts 329 bytes {0}
    + 137 hidden modules

ERROR in ./src/adapters/vector_api/primitive/label.ts
[90m[tsl] [39m[1m[31mERROR[39m[22m[1m[31m in [39m[22m[1m[36m/Users/mstepanova/www/vector/src/adapters/vector_api/primitive/label.ts(32,61)[39m[22m
[1m[31m      TS2341: Property '_location' is private and only accessible within class 'MemorySubChunk'.[39m[22m`);ymaps.modules.define('vectorEngine.tileWorkerImpl',[],function(p){p(URL.createObjectURL(new Blob(["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 30);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export create */\n/* unused harmony export copy */\n/* unused harmony export areEqual */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = decodeAbgr8;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = encodeRgba8;\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = isOpaque;\nconst OPAQUE_BLACK = create(0, 0, 0, 1);\n/* unused harmony export OPAQUE_BLACK */\n\nconst TRANSPARENT_BLACK = create(0, 0, 0, 0);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = TRANSPARENT_BLACK;\n\n/**\n * @param r Red component as a normalized value [0..1]\n * @param g Green component as a normalized value [0..1]\n * @param b Blue component as a normalized value [0..1]\n * @param a Alpha component as a normalized value [0..1]\n *\n * @returns A color with given values assigned to components.\n */\nfunction create(r, g, b, a = 1) {\n    return { r, g, b, a };\n}\n/**\n * Copies a color to another one.\n *\n * @param src The source color.\n * @param dst The color the source color will be copied to.\n * @returns `dst`.\n */\nfunction copy(src, dst = create(0, 0, 0, 0)) {\n    dst.r = src.r;\n    dst.g = src.g;\n    dst.b = src.b;\n    dst.a = src.a;\n    return dst;\n}\nfunction areEqual(c1, c2) {\n    return c1.r == c2.r && c1.g == c2.g && c1.b == c2.b && c1.a == c2.a;\n}\n/**\n * Decodes a color represented as four 8-bit channels encoded into a 32-bit\n * number in ABGR order (from MSB to LSB).\n *\n * @param color Color encoded into unsigned 32-bit integer.\n * @returns Decoded color.\n */\nfunction decodeAbgr8(color) {\n    return {\n        r: (color >>> 24) / 0xff,\n        g: (color >>> 16 & 0xff) / 0xff,\n        b: (color >>> 8 & 0xff) / 0xff,\n        a: (color & 0xff) / 0xff\n    };\n}\n/**\n * Encodes a color components into four 8 bit numbers packed into 32-bit one.\n *\n * @param c The color to be encoded.\n * @returns The color as 32-bit integer.\n */\nfunction encodeRgba8(c) {\n    return (c.r * 0xff |\n        (c.g * 0xff << 8) |\n        (c.b * 0xff << 16) |\n        (c.a * 0xff << 24));\n}\n/**\n * Checks if a color is completely opaque.\n *\n * @param color The color to be checked.\n * @returns `true` if the color is opaque and `false` otherwise.\n */\nfunction isOpaque(color) {\n    return color.a === 1;\n}\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"f\"] = create;\n/* harmony export (immutable) */ __webpack_exports__[\"e\"] = copy;\n/* unused harmony export areEqual */\n/* unused harmony export areCollinear */\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = areFuzzyEqual;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = add;\n/* harmony export (immutable) */ __webpack_exports__[\"p\"] = sub;\n/* unused harmony export mulv */\n/* harmony export (immutable) */ __webpack_exports__[\"l\"] = muln;\n/* unused harmony export divv */\n/* unused harmony export divn */\n/* unused harmony export mod */\n/* harmony export (immutable) */ __webpack_exports__[\"k\"] = mix;\n/* harmony export (immutable) */ __webpack_exports__[\"n\"] = rotate;\n/* unused harmony export rotate45 */\n/* harmony export (immutable) */ __webpack_exports__[\"o\"] = rotate90;\n/* unused harmony export rotateNeg90 */\n/* unused harmony export invert */\n/* harmony export (immutable) */ __webpack_exports__[\"j\"] = length;\n/* harmony export (immutable) */ __webpack_exports__[\"h\"] = distance;\n/* harmony export (immutable) */ __webpack_exports__[\"m\"] = normalize;\n/* harmony export (immutable) */ __webpack_exports__[\"i\"] = dot;\n/* harmony export (immutable) */ __webpack_exports__[\"g\"] = crossZ;\n/* unused harmony export bboxesOverlap */\n/* unused harmony export pointIsInBBox */\n/* unused harmony export computeBBoxForPoints */\n/* unused harmony export getLineFromPoints */\n/* unused harmony export getSignedDistanceToLine */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__ = __webpack_require__(15);\n\n/**\n * Creates a new vector and initializes it with given components.\n *\n * @param x X component of the vector.\n * @param y Y component of the vector.\n * @returns The vector.\n */\nfunction create(x, y) {\n    return { x, y };\n}\nconst ZERO = create(0, 0);\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = ZERO;\n\nconst ORIGIN = ZERO;\n/* unused harmony export ORIGIN */\n\nconst POSITIVE_X = create(1, 0);\n/* unused harmony export POSITIVE_X */\n\nconst NEGATIVE_X = create(-1, 0);\n/* unused harmony export NEGATIVE_X */\n\nconst POSITIVE_Y = create(0, 1);\n/* unused harmony export POSITIVE_Y */\n\nconst NEGATIVE_Y = create(0, -1);\n/* unused harmony export NEGATIVE_Y */\n\n/**\n * Copies a vector to another one.\n *\n * @param src The source vector.\n * @param dst The vector the source vector will be copied to.\n * @returns `dst`.\n */\nfunction copy(src, dst = create(0, 0)) {\n    dst.x = src.x;\n    dst.y = src.y;\n    return dst;\n}\n/**\n * Checks if two vectors are strictly equal component-wise.\n *\n * @param v1 The first vector.\n * @param v2 The second vector.\n * @returns `true` if the vectors are equal and `false` otherwise.\n */\nfunction areEqual(v1, v2) {\n    return v1.x == v2.x && v1.y == v2.y;\n}\n/**\n * Checks if two vectors are collinear.\n *\n * @param v1 The first vector.\n * @param v2 The second vector.\n * @returns `true` if the vectors are collinear and `false` otherwise.\n */\nfunction areCollinear(v1, v2) {\n    return v1.x / v2.x == v1.y / v2.y;\n}\n/**\n * Checks if corresponding components of two vectors are all within given\n * tolerance from each other.\n *\n * @param v1 The first vector.\n * @param v2 The second vector.\n * @param tolerance The tolerance.\n * @returns `true` if the vectors are \"fuzzy\" equal and `false` otherwise.\n */\nfunction areFuzzyEqual(v1, v2, tolerance = __WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__[\"a\" /* DEFAULT_TOLERANCE */]) {\n    return (Object(__WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__[\"b\" /* default */])(v1.x, v2.x, tolerance) &&\n        Object(__WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__[\"b\" /* default */])(v1.y, v2.y, tolerance));\n}\n/**\n * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.\n *\n * @param a The first vector.\n * @param b The second vector.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction add(a, b, dst = create(0, 0)) {\n    dst.x = a.x + b.x;\n    dst.y = a.y + b.y;\n    return dst;\n}\n/**\n * Subtracts a vector from another one and stores the result to a third one, i.e.\n * `dst = a - b`.\n *\n * @param a The minuend vector.\n * @param b The subtrahend vector.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction sub(a, b, dst = create(0, 0)) {\n    dst.x = a.x - b.x;\n    dst.y = a.y - b.y;\n    return dst;\n}\n/**\n * Multiplies two vectors component-wise and stores the result into a third one.\n *\n * @param a The first vector.\n * @param b The second vector.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction mulv(a, b, dst = create(0, 0)) {\n    dst.x = a.x * b.x;\n    dst.y = a.y * b.y;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar and stores the result into a third vector.\n *\n * @param a The vector.\n * @param n The scalar.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction muln(a, n, dst = create(0, 0)) {\n    dst.x = a.x * n;\n    dst.y = a.y * n;\n    return dst;\n}\n/**\n * Divides a vector by another one component wise and stores the result into a\n * third one.\n *\n * @param a The dividend vector.\n * @param b The divisor vector.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction divv(a, b, dst = create(0, 0)) {\n    dst.x = a.x / b.x;\n    dst.y = a.y / b.y;\n    return dst;\n}\n/**\n * Divides a vector by a scalar and stores the result into a third vector.\n *\n * @param a The dividend vector.\n * @param n The scalar.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction divn(a, n, dst = create(0, 0)) {\n    dst.x = a.x / n;\n    dst.y = a.y / n;\n    return dst;\n}\n/**\n * Calculates the reminder after division of a's components by n and stores the result into a third vector.\n *\n * @param a The dividend vector.\n * @param n The scalar.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction mod(a, n, dst = create(0, 0)) {\n    dst.x = a.x % n;\n    dst.y = a.y % n;\n    return dst;\n}\n/**\n * Linearly interpolates between two vectors, i.e. computes\n * `(1 - factor) * a + factor * b`, and writes the result into a third vector.\n *\n * @param a The first vector.\n * @param b The second vector.\n * @param factor The interpolation factor.\n * @param dst The vector the result will be written to.\n * @returns `dst`.\n */\nfunction mix(a, b, factor, dst = create(0, 0)) {\n    dst.x = (1 - factor) * a.x + factor * b.x;\n    dst.y = (1 - factor) * a.y + factor * b.y;\n    return dst;\n}\n/**\n * Rotates a vector by a given angle and stores the result into a second vector.\n * Positive direction is from +X to +Y.\n *\n * @param v The vector to rotate.\n * @param angle The angle of rotation.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction rotate(v, angle, dst = create(0, 0)) {\n    const x = v.x;\n    const y = v.y;\n    const angleCos = Math.cos(angle);\n    const angleSin = Math.sin(angle);\n    dst.x = angleCos * x - angleSin * y;\n    dst.y = angleSin * x + angleCos * y;\n    return dst;\n}\n/**\n * Rotates a vector by 45 degrees and stores the result into a second vector.\n * Analogous to `rotate(v, Math.PI / 4, dst)`, but faster.\n *\n * @param v The vector to rotate.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction rotate45(v, dst = create(0, 0)) {\n    const y = v.y;\n    const s = Math.SQRT1_2;\n    dst.y = s * v.x + s * v.y;\n    dst.x = s * v.x - s * y;\n    return dst;\n}\n/**\n * Rotates a vector by 90 degrees and stores the result into a second vector.\n * Analogous to `rotate(v, Math.PI / 2, dst)`, but faster.\n *\n * @param v The vector to rotate.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction rotate90(v, dst = create(0, 0)) {\n    const y = v.y;\n    dst.y = v.x;\n    dst.x = -y;\n    return dst;\n}\n/**\n * Rotates a vector by -90 degrees and stores the result into a second vector.\n * Analogous to `rotate(v, -Math.PI / 2, dst)`, but faster.\n *\n * @param v The vector to rotate.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction rotateNeg90(v, dst = create(0, 0)) {\n    const y = v.y;\n    dst.y = -v.x;\n    dst.x = y;\n    return dst;\n}\n/**\n * Inverts signs of components of a vector and stores the result into a second\n * vector. Analogous to `rotate(v, Math.PI, dst)` (or `rotate(v, -Math.PI, dst)`,\n * which is the same), but faster.\n *\n * @param v The vector to invert.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction invert(v, dst = create(0, 0)) {\n    dst.x = -v.x;\n    dst.y = -v.y;\n    return dst;\n}\n/**\n * Computes length of a vector.\n *\n * @param v The vector.\n * @returns The length.\n */\nfunction length(v) {\n    return Math.hypot(v.x, v.y);\n}\n/**\n * Computes distance between ends of two vectors.\n *\n * @param a The first vector.\n * @param b The second vector.\n * @returns The distance, i.e. `length(sub(a, b))`.\n */\nfunction distance(a, b) {\n    return Math.hypot(a.x - b.x, a.y - b.y);\n}\n/**\n * Divides a vector by its length (thus making it a unit vector) and stores the\n * result to another one.\n *\n * @param v The vector to be normalized.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction normalize(v, dst = create(0, 0)) {\n    return divn(v, length(v), dst);\n}\n/**\n * Computes dot product of two vectors.\n *\n * @param a The first vector.\n * @param b The second vector.\n * @returns The dot product.\n */\nfunction dot(a, b) {\n    return a.x * b.x + a.y * b.y;\n}\n/**\n * Computes Z-component of a cross product of two vectors.\n *\n * @param a The first vector.\n * @param b The second vector.\n * @returns Z-component of the cross product.\n */\nfunction crossZ(a, b) {\n    return a.x * b.y - a.y * b.x;\n}\nconst EMPTY = {\n    minX: 0,\n    maxX: 0,\n    minY: 0,\n    maxY: 0\n};\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = EMPTY;\n\nconst UNIT_BBOX = {\n    minX: -1,\n    maxX: 1,\n    minY: -1,\n    maxY: 1\n};\n/* unused harmony export UNIT_BBOX */\n\n/**\n * Checks if two bounding boxes overlap.\n *\n * @param bbox1 A bounding box.\n * @param bbox2 Another bounding box.\n * @returns `true` if given bounding boxes do overlap and `false` otherwise.\n */\nfunction bboxesOverlap(bbox1, bbox2) {\n    let leftBBox;\n    let rightBBox;\n    if (bbox1.minX < bbox2.minX) {\n        leftBBox = bbox1;\n        rightBBox = bbox2;\n    }\n    else {\n        leftBBox = bbox2;\n        rightBBox = bbox1;\n    }\n    let topBBox;\n    let bottomBBox;\n    if (bbox1.maxY > bbox2.maxY) {\n        topBBox = bbox1;\n        bottomBBox = bbox2;\n    }\n    else {\n        topBBox = bbox2;\n        bottomBBox = bbox1;\n    }\n    return rightBBox.minX < leftBBox.maxX && bottomBBox.maxY > topBBox.minY;\n}\n/**\n * Checks if a 2D point lies inside a bounding box or on its border.\n *\n * @param point The point.\n * @param bbox The bounding box.\n * @returns `true` if the point is inside of the box and `false` otherwise.\n */\nfunction pointIsInBBox(point, bbox) {\n    return bbox.minX <= point.x && point.x <= bbox.maxX &&\n        bbox.minY <= point.y && point.y <= bbox.maxY;\n}\n/**\n * Computes bounding box of an array of points and stores it to a given object.\n *\n * @param points The array of points.\n * @param dst The bbox the result will be written to. Left unmodified if the array\n *      of points is empty.\n * @returns `dst`.\n */\nfunction computeBBoxForPoints(points, dst = { minX: 0, maxX: 0, minY: 0, maxY: 0 }) {\n    if (points.length === 0) {\n        return dst;\n    }\n    dst.minX = dst.maxX = points[0].x;\n    dst.minY = dst.maxY = points[0].y;\n    for (let i = 1; i < points.length; ++i) {\n        const { x, y } = points[i];\n        if (x < dst.minX) {\n            dst.minX = x;\n        }\n        if (x > dst.maxX) {\n            dst.maxX = x;\n        }\n        if (y < dst.minY) {\n            dst.minY = y;\n        }\n        if (y > dst.maxY) {\n            dst.maxY = y;\n        }\n    }\n    return dst;\n}\nconst X_AXIS = {\n    origin: ORIGIN,\n    tangent: POSITIVE_X\n};\n/* unused harmony export X_AXIS */\n\nconst Y_AXIS = {\n    origin: ORIGIN,\n    tangent: POSITIVE_Y\n};\n/* unused harmony export Y_AXIS */\n\nfunction getLineFromPoints(p1, p2, dst = {\n    origin: create(0, 0),\n    tangent: create(0, 0)\n}) {\n    copy(p1, dst.origin);\n    sub(p2, p1, dst.tangent);\n    return dst;\n}\n/**\n * Computes signed distance from a point to a line.\n *\n * @param p The point.\n * @param l1 Start point of the line.\n * @param l2 End point of the line.\n * @returns Distance from the point to the line. It'll be greater than 0 if the\n *      point lies to the left of the line and less than 0 otherwise.\n */\nfunction getSignedDistanceToLine(p, l) {\n    const tangent = l.tangent;\n    return dot(sub(p, l.origin), create(-tangent.y, tangent.x)) / length(tangent);\n}\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = floatToUint16;\n/* unused harmony export floatToInt16 */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = floatToUint32;\n/* unused harmony export floatToInt32 */\n/* unused harmony export int32ToFloat */\n/* unused harmony export uint32ToFloat */\n/* unused harmony export int16ToFloat */\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = int24ToFloat;\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = uint16ToFloat;\nconst UINT16_MAX = 0xffff;\nconst UINT32_MAX = 0xffffffff;\nfunction floatToUint16(x) {\n    return x * UINT16_MAX | 0;\n}\nfunction floatToInt16(x) {\n    return (x * UINT16_MAX - 1) / 2 | 0;\n}\nfunction floatToUint32(x) {\n    return x * UINT32_MAX | 0;\n}\nfunction floatToInt32(x) {\n    return (x * UINT32_MAX - 1) / 2 | 0;\n}\nfunction int32ToFloat(x) {\n    return (2 * x + 1) / UINT32_MAX;\n}\nfunction uint32ToFloat(x) {\n    return x / UINT32_MAX;\n}\nfunction int16ToFloat(x) {\n    return (2 * x + 1) / UINT16_MAX;\n}\nfunction int24ToFloat(x) {\n    return Math.max(-1, x / 0x7fffff);\n}\nfunction uint16ToFloat(x) {\n    return x / UINT16_MAX;\n}\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\r\nvar util = exports;\r\n\r\n// used to return a Promise where callback is omitted\r\nutil.asPromise = __webpack_require__(54);\r\n\r\n// converts to / from base64 encoded strings\r\nutil.base64 = __webpack_require__(55);\r\n\r\n// base class of rpc.Service\r\nutil.EventEmitter = __webpack_require__(56);\r\n\r\n// float handling accross browsers\r\nutil.float = __webpack_require__(57);\r\n\r\n// requires modules optionally and hides the call from bundlers\r\nutil.inquire = __webpack_require__(58);\r\n\r\n// converts to / from utf8 encoded strings\r\nutil.utf8 = __webpack_require__(59);\r\n\r\n// provides a node-like buffer pool in the browser\r\nutil.pool = __webpack_require__(60);\r\n\r\n// utility to work with the low and high bits of a 64 bit value\r\nutil.LongBits = __webpack_require__(61);\r\n\r\n/**\r\n * An immuable empty array.\r\n * @memberof util\r\n * @type {Array.<*>}\r\n * @const\r\n */\r\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\r\n\r\n/**\r\n * An immutable empty object.\r\n * @type {Object}\r\n * @const\r\n */\r\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\r\n\r\n/**\r\n * Whether running within node or not.\r\n * @memberof util\r\n * @type {boolean}\r\n * @const\r\n */\r\nutil.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);\r\n\r\n/**\r\n * Tests if the specified value is an integer.\r\n * @function\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is an integer\r\n */\r\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\r\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\r\n};\r\n\r\n/**\r\n * Tests if the specified value is a string.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a string\r\n */\r\nutil.isString = function isString(value) {\r\n    return typeof value === \"string\" || value instanceof String;\r\n};\r\n\r\n/**\r\n * Tests if the specified value is a non-null object.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a non-null object\r\n */\r\nutil.isObject = function isObject(value) {\r\n    return value && typeof value === \"object\";\r\n};\r\n\r\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * This is an alias of {@link util.isSet}.\r\n * @function\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\r\nutil.isset =\r\n\r\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\r\nutil.isSet = function isSet(obj, prop) {\r\n    var value = obj[prop];\r\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\r\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\r\n    return false;\r\n};\r\n\r\n/**\r\n * Any compatible Buffer instance.\r\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\r\n * @interface Buffer\r\n * @extends Uint8Array\r\n */\r\n\r\n/**\r\n * Node's Buffer class if available.\r\n * @type {Constructor<Buffer>}\r\n */\r\nutil.Buffer = (function() {\r\n    try {\r\n        var Buffer = util.inquire(\"buffer\").Buffer;\r\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\r\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\r\n    } catch (e) {\r\n        /* istanbul ignore next */\r\n        return null;\r\n    }\r\n})();\r\n\r\n// Internal alias of or polyfull for Buffer.from.\r\nutil._Buffer_from = null;\r\n\r\n// Internal alias of or polyfill for Buffer.allocUnsafe.\r\nutil._Buffer_allocUnsafe = null;\r\n\r\n/**\r\n * Creates a new buffer of whatever type supported by the environment.\r\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\r\n * @returns {Uint8Array|Buffer} Buffer\r\n */\r\nutil.newBuffer = function newBuffer(sizeOrArray) {\r\n    /* istanbul ignore next */\r\n    return typeof sizeOrArray === \"number\"\r\n        ? util.Buffer\r\n            ? util._Buffer_allocUnsafe(sizeOrArray)\r\n            : new util.Array(sizeOrArray)\r\n        : util.Buffer\r\n            ? util._Buffer_from(sizeOrArray)\r\n            : typeof Uint8Array === \"undefined\"\r\n                ? sizeOrArray\r\n                : new Uint8Array(sizeOrArray);\r\n};\r\n\r\n/**\r\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\r\n * @type {Constructor<Uint8Array>}\r\n */\r\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\r\n\r\n/**\r\n * Any compatible Long instance.\r\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\r\n * @interface Long\r\n * @property {number} low Low bits\r\n * @property {number} high High bits\r\n * @property {boolean} unsigned Whether unsigned or not\r\n */\r\n\r\n/**\r\n * Long.js's Long class if available.\r\n * @type {Constructor<Long>}\r\n */\r\nutil.Long = /* istanbul ignore next */ global.dcodeIO && /* istanbul ignore next */ global.dcodeIO.Long || util.inquire(\"long\");\r\n\r\n/**\r\n * Regular expression used to verify 2 bit (`bool`) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key2Re = /^true|false|0|1$/;\r\n\r\n/**\r\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\r\n\r\n/**\r\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\r\n\r\n/**\r\n * Converts a number or long to an 8 characters long hash string.\r\n * @param {Long|number} value Value to convert\r\n * @returns {string} Hash\r\n */\r\nutil.longToHash = function longToHash(value) {\r\n    return value\r\n        ? util.LongBits.from(value).toHash()\r\n        : util.LongBits.zeroHash;\r\n};\r\n\r\n/**\r\n * Converts an 8 characters long hash string to a long or number.\r\n * @param {string} hash Hash\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {Long|number} Original value\r\n */\r\nutil.longFromHash = function longFromHash(hash, unsigned) {\r\n    var bits = util.LongBits.fromHash(hash);\r\n    if (util.Long)\r\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\r\n    return bits.toNumber(Boolean(unsigned));\r\n};\r\n\r\n/**\r\n * Merges the properties of the source object into the destination object.\r\n * @memberof util\r\n * @param {Object.<string,*>} dst Destination object\r\n * @param {Object.<string,*>} src Source object\r\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\r\n * @returns {Object.<string,*>} Destination object\r\n */\r\nfunction merge(dst, src, ifNotSet) { // used by converters\r\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\r\n        if (dst[keys[i]] === undefined || !ifNotSet)\r\n            dst[keys[i]] = src[keys[i]];\r\n    return dst;\r\n}\r\n\r\nutil.merge = merge;\r\n\r\n/**\r\n * Converts the first character of a string to lower case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\r\nutil.lcFirst = function lcFirst(str) {\r\n    return str.charAt(0).toLowerCase() + str.substring(1);\r\n};\r\n\r\n/**\r\n * Creates a custom error constructor.\r\n * @memberof util\r\n * @param {string} name Error name\r\n * @returns {Constructor<Error>} Custom error constructor\r\n */\r\nfunction newError(name) {\r\n\r\n    function CustomError(message, properties) {\r\n\r\n        if (!(this instanceof CustomError))\r\n            return new CustomError(message, properties);\r\n\r\n        // Error.call(this, message);\r\n        // ^ just returns a new error instance because the ctor can be called as a function\r\n\r\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\r\n\r\n        /* istanbul ignore next */\r\n        if (Error.captureStackTrace) // node\r\n            Error.captureStackTrace(this, CustomError);\r\n        else\r\n            Object.defineProperty(this, \"stack\", { value: (new Error()).stack || \"\" });\r\n\r\n        if (properties)\r\n            merge(this, properties);\r\n    }\r\n\r\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\r\n\r\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\r\n\r\n    CustomError.prototype.toString = function toString() {\r\n        return this.name + \": \" + this.message;\r\n    };\r\n\r\n    return CustomError;\r\n}\r\n\r\nutil.newError = newError;\r\n\r\n/**\r\n * Constructs a new protocol error.\r\n * @classdesc Error subclass indicating a protocol specifc error.\r\n * @memberof util\r\n * @extends Error\r\n * @template T extends Message<T>\r\n * @constructor\r\n * @param {string} message Error message\r\n * @param {Object.<string,*>} [properties] Additional properties\r\n * @example\r\n * try {\r\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\r\n * } catch (e) {\r\n *     if (e instanceof ProtocolError && e.instance)\r\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\r\n * }\r\n */\r\nutil.ProtocolError = newError(\"ProtocolError\");\r\n\r\n/**\r\n * So far decoded message instance.\r\n * @name util.ProtocolError#instance\r\n * @type {Message<T>}\r\n */\r\n\r\n/**\r\n * A OneOf getter as returned by {@link util.oneOfGetter}.\r\n * @typedef OneOfGetter\r\n * @type {function}\r\n * @returns {string|undefined} Set field name, if any\r\n */\r\n\r\n/**\r\n * Builds a getter for a oneof's present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfGetter} Unbound getter\r\n */\r\nutil.oneOfGetter = function getOneOf(fieldNames) {\r\n    var fieldMap = {};\r\n    for (var i = 0; i < fieldNames.length; ++i)\r\n        fieldMap[fieldNames[i]] = 1;\r\n\r\n    /**\r\n     * @returns {string|undefined} Set field name, if any\r\n     * @this Object\r\n     * @ignore\r\n     */\r\n    return function() { // eslint-disable-line consistent-return\r\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\r\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\r\n                return keys[i];\r\n    };\r\n};\r\n\r\n/**\r\n * A OneOf setter as returned by {@link util.oneOfSetter}.\r\n * @typedef OneOfSetter\r\n * @type {function}\r\n * @param {string|undefined} value Field name\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Builds a setter for a oneof's present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfSetter} Unbound setter\r\n */\r\nutil.oneOfSetter = function setOneOf(fieldNames) {\r\n\r\n    /**\r\n     * @param {string} name Field name\r\n     * @returns {undefined}\r\n     * @this Object\r\n     * @ignore\r\n     */\r\n    return function(name) {\r\n        for (var i = 0; i < fieldNames.length; ++i)\r\n            if (fieldNames[i] !== name)\r\n                delete this[fieldNames[i]];\r\n    };\r\n};\r\n\r\n/**\r\n * Default conversion options used for {@link Message#toJSON} implementations.\r\n *\r\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\r\n *\r\n * - Longs become strings\r\n * - Enums become string keys\r\n * - Bytes become base64 encoded strings\r\n * - (Sub-)Messages become plain objects\r\n * - Maps become plain objects with all string keys\r\n * - Repeated fields become arrays\r\n * - NaN and Infinity for float and double fields become strings\r\n *\r\n * @type {IConversionOptions}\r\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\r\n */\r\nutil.toJSONOptions = {\r\n    longs: String,\r\n    enums: String,\r\n    bytes: String,\r\n    json: true\r\n};\r\n\r\nutil._configure = function() {\r\n    var Buffer = util.Buffer;\r\n    /* istanbul ignore if */\r\n    if (!Buffer) {\r\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\r\n        return;\r\n    }\r\n    // because node 4.x buffers are incompatible & immutable\r\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\r\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\r\n        /* istanbul ignore next */\r\n        function Buffer_from(value, encoding) {\r\n            return new Buffer(value, encoding);\r\n        };\r\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\r\n        /* istanbul ignore next */\r\n        function Buffer_allocUnsafe(size) {\r\n            return new Buffer(size);\r\n        };\r\n};\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gputypes__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(13);\n\n\nconst WORD_BYTE_SIZE = 4;\n/* unused harmony export WORD_BYTE_SIZE */\n\n/**\n * Generates triangles of a fan of a given length as if it is continuous and\n * starts with 0.\n *\n * @param count Number of vertices in the fan.\n * @returns Iterator over indices of triangles.\n */\nfunction* generateFan(count) {\n    for (let i = 2; i < count; ++i) {\n        yield 0;\n        yield i - 1;\n        yield i;\n    }\n}\n/**\n * Generates triangles of a strip of a given length as if it is continuous and\n * starts with 0.\n *\n * @param count Number of vertices in the fan.\n * @returns Iterator over indices of triangles.\n */\nfunction* generateStrip(count) {\n    yield 0;\n    yield 1;\n    yield 2;\n    let offset0 = 1;\n    let offset1 = 2;\n    for (let i = 3; i < count; ++i) {\n        yield i - offset0;\n        yield i - offset1;\n        yield i;\n        const tmp = offset0;\n        offset0 = offset1;\n        offset1 = tmp;\n    }\n}\n/**\n * Vertex buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.\n * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.\n */\nclass VertexBuffer {\n    /**\n     * @param byteSize Initial size of the buffer in bytes. As it gets filled by words\n     *      the size must be a multiply of 4.\n     */\n    constructor(byteSize) {\n        this._nextWordOffset = 0;\n        this._initBuffers(byteSize);\n    }\n    /**\n     * @returns true if there is no free space remaining in buffer.\n     */\n    get isFull() {\n        return this._nextWordOffset >= this._uint32View.length;\n    }\n    /**\n     * @returns The number of words (4 bytes values) already written.\n     */\n    get occupiedSize() {\n        return this._nextWordOffset;\n    }\n    /**\n     * @return Max number of bytes this buffer is able to store. It can be increased by the extend() method.\n     */\n    get byteSize() {\n        return this._uint32View.byteLength;\n    }\n    /**\n     * Extends buffer to the new size. The new size must be not less than current one and it must be a multiply of 4.\n     */\n    extend(newByteSize) {\n        // TODO assert newByteLength is larger than current _arrayBuffer and its is a multiply of the word size.\n        const oldUint32View = this._uint32View;\n        this._initBuffers(newByteSize);\n        this._uint32View.set(oldUint32View);\n    }\n    /**\n     * Appends value as a uint32 number.\n     */\n    pushUint32(value) {\n        this._uint32View[this._nextWordOffset++] = value;\n    }\n    /**\n     * Appends value as a float32 number.\n     */\n    pushFloat32(value) {\n        this._float32View[this._nextWordOffset++] = value;\n    }\n    /**\n     * @returns uint8 view of this buffer. The size of the view matches the amount of written data.\n     */\n    asUint32Array() {\n        return this._uint32View.subarray(0, this.occupiedSize);\n    }\n    _initBuffers(byteLength) {\n        const arrayBuffer = new ArrayBuffer(byteLength);\n        this._uint32View = new Uint32Array(arrayBuffer);\n        this._float32View = new Float32Array(arrayBuffer);\n    }\n    /**\n     * Moves \"tail\" data (from the offset specified to the end of the buffer) of one buffer to another. The cursors of\n     * buffers will be appropriately updated to reflect data changes.\n     */\n    static transferDataTail(src, dst, srcWordOffset, dstOffset = 0) {\n        const tailLength = src.occupiedSize - srcWordOffset;\n        const srcTail = src._uint32View.subarray(srcWordOffset, src.occupiedSize);\n        dst._uint32View.set(srcTail, dstOffset);\n        dst._nextWordOffset = tailLength;\n        src._nextWordOffset = srcWordOffset;\n    }\n}\n/**\n * Index buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.\n * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.\n */\nclass IndexBuffer {\n    /**\n     * @param size Initial size of the buffer.\n     */\n    constructor(size) {\n        this._nextIndexOffset = 0;\n        this._uint16View = new Uint16Array(size);\n    }\n    /**\n     * @returns The number of indices already written.\n     */\n    get occupiedSize() {\n        return this._nextIndexOffset;\n    }\n    /**\n     * @return Max number of indices this buffer is able to store. It can be increased by the extend() method.\n     */\n    get size() {\n        return this._uint16View.length;\n    }\n    /**\n     * Extends buffer to the new size.\n     */\n    extend(newSize) {\n        // TODO assert newByteLength is larger than current _arrayBuffer\n        const oldUint16View = this._uint16View;\n        this._uint16View = new Uint16Array(newSize);\n        this._uint16View.set(oldUint16View);\n    }\n    /**\n     * Appends index to the end of the buffer.\n     */\n    push(index) {\n        this._uint16View[this._nextIndexOffset++] = index;\n    }\n    /**\n     * @returns uint16 view of this buffer. The size of the view matches the amount of written data.\n     */\n    asUint16Array() {\n        return new Uint16Array(this._uint16View.buffer, 0, this.occupiedSize);\n    }\n    /**\n     * Moves \"tail\" data (from the offset specified to the end of the buffer) of one buffer to another. The offsets of\n     * buffers will be appropriately updated to reflect data changes.\n     * baseIndex will be deducted from all moved indices.\n     */\n    static transferDataTail(src, dst, baseIndex, srcOffset, dstOffset = 0) {\n        for (let i = srcOffset, j = dstOffset; i < src.occupiedSize; i++, j++) {\n            dst._uint16View[j] = src._uint16View[i] - baseIndex;\n        }\n        dst._nextIndexOffset = src.occupiedSize - srcOffset;\n        src._nextIndexOffset = srcOffset;\n    }\n}\n/**\n * Base buffer writer implementation. Can write unsigned short indices and\n * provides facilities for child classes to handle writing vertex data. Defines\n * a concept of current mesh. Basically, it mean that all vertices and indices\n * written to a writer between two `endMesh` calls (or construction of the writer\n * and an `endMesh` call) must be considered belonging to one atomic piece of\n * geometry and should not be spitted between separate buffers.\n */\nclass BufferWriter {\n    /**\n     * Creates a new writer and allocates initial amount of memory to store data.\n     * Also implicitly \"start\" a mesh.\n     *\n     * @param vertexByteSize\n     * @param initVertexBufferSize Init size (in vertices) of growing vertex buffers.\n     * @param maxVertexBufferSize Max size (in vertices) of vertex buffers.\n     * @param initIndexBufferUint16Size Init size (in uint16 number) of growing index buffers.\n     */\n    constructor(vertexByteSize, initVertexBufferSize = 0x400, maxVertexBufferSize = 0x10000, initIndexBufferUint16Size = 0xc00) {\n        this._vertexByteSize = vertexByteSize;\n        this._initVertexBufferByteSize = vertexByteSize * initVertexBufferSize;\n        this._maxVertexBufferByteSize = vertexByteSize * maxVertexBufferSize;\n        this._initIndexBufferUint16Size = initIndexBufferUint16Size;\n        this._vertexBuffer = new VertexBuffer(this._initVertexBufferByteSize);\n        this._vertexBuffers = [this._vertexBuffer];\n        this._indexBuffer = new IndexBuffer(this._initIndexBufferUint16Size);\n        this._indexBuffers = [this._indexBuffer];\n        this._currentMeshVertexOffset = 0;\n        this._currentMeshIndexOffset = 0;\n        this._currentMeshBaseIndex = 0;\n    }\n    /**\n     * Writes a bunch of indices to the underlying storage as unsigned short\n     * numbers. If current storage doesn't have enough space to accommodate\n     * given indices, the writer will automatically resize it. The writer\n     * automatically adds base index to the supplied values, so from a user\n     * point of view first vertex of a mesh has index 0 and there's no need\n     * to take into account it's offset while generating mesh's topology.\n     *\n     * @param indices Array of indices to write.\n     */\n    writeIndices(indices) {\n        this._ensureEnoughIndexBufferSpace(indices.length);\n        const buffer = this._indexBuffer;\n        const baseIndex = this._currentMeshBaseIndex;\n        for (let i = 0; i < indices.length; ++i) {\n            buffer.push(baseIndex + indices[i]);\n        }\n    }\n    /**\n     * Generates triangle indices from an array of indices of a triangle strip\n     * (as in GL) and writes generated triplets to the managed index buffer.\n     * @see OpenGL ES 2.0 Spec, §2.6.1\n     *\n     * @param indices Indices of the strip.\n     */\n    writeIndicesForStrip(indices) {\n        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));\n        const buffer = this._indexBuffer;\n        const baseIndex = this._currentMeshBaseIndex;\n        for (const i of generateStrip(indices.length)) {\n            buffer.push(baseIndex + indices[i]);\n        }\n    }\n    /**\n     * Generates triangle indices from a continuous triangle strip of a given\n     * length and writes generated triplets to managed index buffer.\n     * @see OpenGL ES 2.0 Spec, §2.6.1\n     *\n     * @param indexCount\n     * @param baseIndexInMesh\n     */\n    writeIndicesForContinuousStrip(indexCount, baseIndexInMesh = 0) {\n        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));\n        const buffer = this._indexBuffer;\n        const baseIndex = this._currentMeshBaseIndex + baseIndexInMesh;\n        for (const i of generateStrip(indexCount)) {\n            buffer.push(baseIndex + i);\n        }\n    }\n    /**\n     * Generates triangle indices from an array of indices of a triangle fan (as\n     * in GL) and writes generated triplets to the managed index buffer.\n     * @see OpenGL ES 2.0 Spec, §2.6.1\n     *\n     * @param indices Indices of the strip.\n     */\n    writeIndicesForFan(indices) {\n        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));\n        const buffer = this._indexBuffer;\n        const baseIndex = this._currentMeshBaseIndex;\n        for (const i of generateFan(indices.length)) {\n            buffer.push(baseIndex + indices[i]);\n        }\n    }\n    /**\n     * Generates triangle indices from a continuous triangle fan of a given length\n     * and writes generated triplets to managed index buffer.\n     * @see OpenGL ES 2.0 Spec, §2.6.1\n     *\n     * @param indexCount\n     * @param baseIndexInMesh\n     */\n    writeIndicesForContinuousFan(indexCount, baseIndexInMesh = 0) {\n        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));\n        const buffer = this._indexBuffer;\n        const baseIndex = baseIndexInMesh + this._currentMeshBaseIndex;\n        for (const i of generateFan(indexCount)) {\n            buffer.push(baseIndex + i);\n        }\n    }\n    /**\n     * Ends current mesh and implicitly starts a new one.\n     *\n     * @returns Internal index of vertex and index buffers the mesh was written\n     *      to and its memory location in them.\n     */\n    endMesh() {\n        const currentMeshVertexOffset = this._currentMeshVertexOffset;\n        const vertexOccupiedSize = this._vertexBuffer.occupiedSize;\n        this._currentMeshVertexOffset = vertexOccupiedSize;\n        this._currentMeshBaseIndex = (vertexOccupiedSize << 2) / this._vertexByteSize;\n        const currentMeshIndexOffset = this._currentMeshIndexOffset;\n        const indexOccupiedSize = this._indexBuffer.occupiedSize;\n        this._currentMeshIndexOffset = indexOccupiedSize;\n        return {\n            vertexByteOffset: currentMeshVertexOffset << 2,\n            vertexByteLength: vertexOccupiedSize - currentMeshVertexOffset << 2,\n            indexByteOffset: currentMeshIndexOffset << 1,\n            indexByteLength: indexOccupiedSize - currentMeshIndexOffset << 1,\n            // We can't return actual buffer reference since it can change if\n            // the buffer gets reallocated.\n            bufferIndex: this._vertexBuffers.length - 1\n        };\n    }\n    /**\n     * Returns an array of currently owned buffer data. This call's better\n     * made when you're done with the writer since if the writer decides to\n     * resize any of the buffers some of the references in the returned array\n     * may become outdated.\n     */\n    getBuffers() {\n        return Object(__WEBPACK_IMPORTED_MODULE_1__array__[\"d\" /* zip */])(this._vertexBuffers, this._indexBuffers, (vertexBuffer, indexBuffer) => ({\n            vertexBuffer: vertexBuffer.asUint32Array(),\n            indexBuffer: indexBuffer.asUint16Array()\n        }));\n    }\n    /**\n     * Returns an offset in the current vertex buffer to the location where next\n     * piece of data will be written.\n     */\n    getCurrentVertexBufferByteOffset() {\n        return this._vertexBuffer.occupiedSize << 2;\n    }\n    /**\n     * Returns index of currently written vertex structure in the current vertex\n     * buffer.\n     */\n    getCurrentVertexIdx() {\n        return ((this._vertexBuffer.occupiedSize << 2) / this._vertexByteSize | 0) - this._currentMeshBaseIndex;\n    }\n    /**\n     * Writes a floating point value to the current vertex buffer and advances\n     * the offset by 4 bytes.\n     *\n     * @param value The value to be written.\n     */\n    _writeFloat32(value) {\n        this._ensureEnoughVertexBufferSpace();\n        this._vertexBuffer.pushFloat32(value);\n    }\n    /**\n     * Writes an unsigned integer value to the current vertex buffer and advances\n     * the offset by 4 bytes.\n     *\n     * @param value The value to be written.\n     */\n    _writeWord(value) {\n        this._ensureEnoughVertexBufferSpace();\n        this._vertexBuffer.pushUint32(value);\n    }\n    /**\n     * Writes an unsigned short value to the current vertex buffer and advances\n     * the offset by 2 bytes. Passed values will be truncated to 16 bits.\n     *\n     * @param value The value to be written.\n     */\n    _writeHalfWords(v1, v2) {\n        this._writeWord(v2 << 16 | v1 & 0xffff);\n    }\n    /**\n     * Writes an unsigned byte value to the current vertex buffer and advances\n     * the offset by 1 byte. Passed values will be truncated to 8 bits.\n     *\n     * @param value The value to be written.\n     */\n    _writeBytes(v1, v2, v3, v4) {\n        this._writeWord(v4 << 24 |\n            (v3 & 0xff) << 16 |\n            (v2 & 0xff) << 8 |\n            v1 & 0xff);\n    }\n    /**\n     * Encodes a world coordinate vector as a pair of 32-bit integers (splitting\n     * them in turn into to 16-bit ones).\n     *\n     * @param c The world coordinate.\n     */\n    _writeWorldCoordinate(c) {\n        // To avoid using GPU singed integer conversions we shift and scale world\n        // coordinates so they're in [0, 1] range (instead of [-1, 1]) and then\n        // encoded as unsigned 32 bit integers split into to 16 bit ones.\n        const xUint32 = Object(__WEBPACK_IMPORTED_MODULE_0__gputypes__[\"b\" /* floatToUint32 */])(0.5 * (c.x + 1));\n        const yUint32 = Object(__WEBPACK_IMPORTED_MODULE_0__gputypes__[\"b\" /* floatToUint32 */])(0.5 * (c.y + 1));\n        this._writeHalfWords(xUint32 >>> 16, yUint32 >>> 16);\n        this._writeHalfWords(xUint32, yUint32);\n    }\n    /**\n     * Computes new bigger size of a vertex buffer based on its current size. By\n     * default just double the current size.\n     *\n     * @param currentByteSize Current size of the index buffer in bytes.\n     * @returns The new size.\n     */\n    _getNextVertexBufferByteSize(currentByteSize) {\n        return currentByteSize << 1;\n    }\n    /**\n     * Computes new bigger size of an index buffer based on its current size. By\n     * default just double the current size.\n     *\n     * @param currentUint16Size Current size of the index buffer in shorts.\n     * @returns The new size.\n     */\n    _getNextIndexBufferUint16Size(currentUint16Size) {\n        return currentUint16Size << 1;\n    }\n    /**\n     * Ensures that the managed vertex buffer has enough space to fit in a chunk\n     * of data of a given size. Either does nothing, resizes the current vertex\n     * buffer or creates entirely new pair of vertex and index buffers.\n     *\n     * @param valueSize Byte size of the data that needs to be accommodated by\n     *      the vertex buffer.\n     */\n    _ensureEnoughVertexBufferSpace() {\n        const vertexBuffer = this._vertexBuffer;\n        if (!vertexBuffer.isFull) {\n            // We have enough space, so nothing to be done.\n            return;\n        }\n        if (vertexBuffer.byteSize < this._maxVertexBufferByteSize) {\n            // If we can just resize the current vertex buffer, do that.\n            this._vertexBuffer.extend(this._getNextVertexBufferByteSize(vertexBuffer.byteSize));\n            return;\n        }\n        // If there's no enough space in the current vertex buffer and it's\n        // already of maximum size, allocate new vertex and index buffers and\n        // copy data of the current mesh to them from the current buffers.\n        // Then make those buffer the current ones.\n        const currentMeshVertexOffset = this._currentMeshVertexOffset;\n        const currentMeshVertexByteSize = (vertexBuffer.occupiedSize - currentMeshVertexOffset) * 4;\n        const maxVertexBufferByteSize = this._maxVertexBufferByteSize;\n        if (currentMeshVertexByteSize == maxVertexBufferByteSize) {\n            throw new Error('Mesh is too big to fit in.');\n        }\n        let newVertexBufferByteSize = this._initVertexBufferByteSize;\n        // Initial vertex buffer size may be too small to accommodate the current\n        // mesh, so we find next bigger size that is sufficient.\n        while (newVertexBufferByteSize <= currentMeshVertexByteSize) {\n            newVertexBufferByteSize = this._getNextVertexBufferByteSize(newVertexBufferByteSize);\n        }\n        const newVertexBuffer = new VertexBuffer(newVertexBufferByteSize);\n        VertexBuffer.transferDataTail(vertexBuffer, newVertexBuffer, currentMeshVertexOffset);\n        this._vertexBuffer = newVertexBuffer;\n        this._vertexBuffers.push(newVertexBuffer);\n        this._currentMeshVertexOffset = 0;\n        const indexBuffer = this._indexBuffer;\n        const currentMeshIndexOffset = this._currentMeshIndexOffset;\n        const currentMeshIndexSize = indexBuffer.occupiedSize - currentMeshIndexOffset;\n        let newIndexBufferSize = this._initIndexBufferUint16Size;\n        // Initial index buffer size may be too small to accommodate the current\n        // mesh, so we find next bigger size that is sufficient.\n        while (newIndexBufferSize <= currentMeshIndexSize) {\n            newIndexBufferSize = this._getNextIndexBufferUint16Size(newIndexBufferSize);\n        }\n        const newIndexBuffer = new IndexBuffer(newIndexBufferSize);\n        // Since the current mesh's copied to the beginning of the new vertex\n        // buffer, it's base index now is 0. If the mesh has any written indices,\n        // they're already offset by the old base index.\n        IndexBuffer.transferDataTail(indexBuffer, newIndexBuffer, this._currentMeshBaseIndex, currentMeshIndexOffset);\n        this._currentMeshBaseIndex = 0;\n        this._currentMeshIndexOffset = 0;\n        this._indexBuffer = newIndexBuffer;\n        this._indexBuffers.push(newIndexBuffer);\n    }\n    /**\n     * Ensures that the managed index buffer has enough space to fit in a given\n     * number of indices. Either does nothing or resizes the current index\n     * buffer.\n     *\n     * @param indexCount Number of indices client wants to write to the managed\n     *      index buffer.\n     */\n    _ensureEnoughIndexBufferSpace(indexCount) {\n        const buffer = this._indexBuffer;\n        const requiredSize = buffer.occupiedSize + indexCount;\n        if (requiredSize <= buffer.size) {\n            // We have enough space so nothing to be done.\n            return;\n        }\n        let newBufferSize = buffer.size;\n        // Let's compute new larger size of the index buffer until we can\n        // accommodate incoming data.\n        while (requiredSize > newBufferSize) {\n            newBufferSize = this._getNextIndexBufferUint16Size(newBufferSize);\n        }\n        this._indexBuffer.extend(newBufferSize);\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = BufferWriter;\n\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_iterable__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_pow_of_2__ = __webpack_require__(75);\n\n\n/**\n * Gives size of a GL type.\n *\n * @param type The type.\n * @returns Size of the type in bytes.\n */\nfunction getTypeSize(type) {\n    switch (type) {\n        case 5120 /* BYTE */:\n        case 5121 /* UNSIGNED_BYTE */:\n            return 1;\n        case 5122 /* SHORT */:\n        case 5123 /* UNSIGNED_SHORT */:\n            return 2;\n        case 5124 /* INT */:\n        case 5125 /* UNSIGNED_INT */:\n        case 5126 /* FLOAT */:\n            return 4;\n    }\n}\n/**\n * Description of how particular attributes of a vertex are packed into a vertex\n * buffer.\n */\nclass AttributeMapping extends Map {\n    /**\n     * Creates a new attribute mapping with a set of attributes of given types and\n     * sizes. Automatically computes offsets of the attributes.\n     *\n     * @param mapping The mapping from attribute IDs to types and sizes.\n     * @param alignment Desired alignment of attributes in the vertex data\n     *      structure. Must be a power of 2.\n     */\n    constructor(mapping, alignment = 4 /* ALIGN_4_BYTES */) {\n        let offset = 0;\n        super(Object(__WEBPACK_IMPORTED_MODULE_0__util_iterable__[\"a\" /* mapIterable */])(mapping, ([idx, { type, size, normalized }]) => {\n            const pointer = [\n                idx,\n                {\n                    type,\n                    size,\n                    normalized,\n                    offset\n                }\n            ];\n            const attributeSize = size * getTypeSize(type);\n            const newOffset = Object(__WEBPACK_IMPORTED_MODULE_1__util_pow_of_2__[\"a\" /* align */])(offset + attributeSize, -alignment);\n            // FIXME(dmikis) Check this only in debug mode.\n            if (newOffset - offset > attributeSize) {\n                console.warn(`${newOffset - offset} byte padding's inserted`);\n            }\n            offset = newOffset;\n            return pointer;\n        }));\n        this.vertexByteSize = offset;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = AttributeMapping;\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = isTileEdgeCoordinates;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_tile_system__ = __webpack_require__(70);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector2__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_scalar__ = __webpack_require__(12);\n\n\n\n// Tiles from API coordinates are defined in [-0x4000; 0x3FFF] range. See tile.proto for details.\nconst TILE_MIN_COORDINATE = -0x4000;\nconst TILE_MAX_COORDINATE = 0x3FFF;\n/**\n * Check if point with specified coordinates lays on an edge of a tile.\n */\nfunction isTileEdgeCoordinates(tileXCoordinate, tileYCoordinate) {\n    return (tileXCoordinate === TILE_MIN_COORDINATE ||\n        tileXCoordinate === TILE_MAX_COORDINATE ||\n        tileYCoordinate === TILE_MIN_COORDINATE ||\n        tileYCoordinate === TILE_MAX_COORDINATE);\n}\n/**\n * Coordinates converter, from tile units (taking into account tile position) to world units.\n */\nclass TileWorldCoordinatesConverter {\n    constructor(tile) {\n        const worldTileSystem = new __WEBPACK_IMPORTED_MODULE_0__util_tile_system__[\"a\" /* default */](tile.zoom);\n        const tileOffset = worldTileSystem.getTileOffset(tile);\n        const tileSize = worldTileSystem.getTileSize();\n        const tileCenterOffset = tileSize / 2;\n        this._tileCenter = __WEBPACK_IMPORTED_MODULE_1__math_vector2__[\"f\" /* create */](tileOffset.x + tileCenterOffset, tileOffset.y - tileCenterOffset);\n        this._tileWorldRatio = tileSize / (TILE_MAX_COORDINATE - TILE_MIN_COORDINATE);\n    }\n    /**\n     * @return World's x coordinate that corresponds to the tile's one.\n     */\n    toWorldXCoordinate(tileXCoordinate) {\n        return Object(__WEBPACK_IMPORTED_MODULE_2__math_scalar__[\"a\" /* clamp */])(this._tileCenter.x + tileXCoordinate * this._tileWorldRatio, -1, 1);\n    }\n    /**\n     * @return World's y coordinate that corresponds to the tile's one.\n     */\n    toWorldYCoordinate(tileYCoordinate) {\n        return Object(__WEBPACK_IMPORTED_MODULE_2__math_scalar__[\"a\" /* clamp */])(this._tileCenter.y - tileYCoordinate * this._tileWorldRatio, -1, 1);\n    }\n    /**\n     * @return World's z coordinate that corresponds to the tile's one.\n     */\n    toWorldZCoordinate(tileZCoordinate) {\n        return tileZCoordinate * this._tileWorldRatio;\n    }\n    /**\n     * @return World's coordinates that corresponds to the tile's ones.\n     */\n    toWorldCoordinates(tileXCoordinate, tileYCoordinate) {\n        return __WEBPACK_IMPORTED_MODULE_1__math_vector2__[\"f\" /* create */](this.toWorldXCoordinate(tileXCoordinate), this.toWorldYCoordinate(tileYCoordinate));\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = TileWorldCoordinatesConverter;\n\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = extractStyles;\n/**\n * One object is used as a buffer to pass common properties to style extractors,\n * to prevent creation of many temporary objects.\n */\nconst styleBase = {\n    minZoom: 0,\n    maxZoom: 0,\n    zIndex: 0\n};\n/**\n * Utility method for parsing styles from decoded API tile response. It handles some common logic regarding\n * zoom slices and delegates fetching style details to a StyleHandler.\n * Tile min/max zoom params are used to set proper styles to be used in over/under zooming, still adhering\n * the API convention where missing zoom range slice means object invisibility.\n */\nfunction* extractStyles(presentations, classId, toStyle, tileMinZoom, tileMaxZoom, presentationName = 'map') {\n    const presentation = presentations.find((presentation) => presentation.name === presentationName) || presentations[0];\n    const styleClass = presentation.classes[classId];\n    for (const slice of styleClass.slices) {\n        if (slice.visibility) {\n            styleBase.minZoom = slice.visibility.min === tileMinZoom ? -Infinity : slice.visibility.min;\n            styleBase.maxZoom = slice.visibility.max === tileMaxZoom ? +Infinity : slice.visibility.max;\n            styleBase.zIndex = slice.zIndex;\n            const style = toStyle(slice, styleBase);\n            if (style) {\n                yield style;\n            }\n        }\n    }\n}\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export findInIterable */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = mapIterable;\n/* unused harmony export filterIterable */\n/* unused harmony export reduceIterable */\n/* unused harmony export oneOfIterable */\n/* unused harmony export allOfIterable */\n/* unused harmony export rangeIterable */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = zipIterables;\n/**\n * Searches for the first collection item satisfying a predicate.\n *\n * @param collection The collection.\n * @param predicate The predicate.\n * @returns The first item satisfying the predicate or `undefined` if none found.\n */\nfunction findInIterable(collection, predicate) {\n    for (const item of collection) {\n        if (predicate(item)) {\n            return item;\n        }\n    }\n    return;\n}\n/**\n * Transforms a collection to another one.\n *\n * @param collection The source collection.\n * @param mapper A function producing items for destination collection.\n * @returns Collection of produced items.\n */\nfunction* mapIterable(collection, mapper) {\n    for (const item of collection) {\n        yield mapper(item);\n    }\n}\n/**\n * Chooses items of a collection satisfying a predicate.\n *\n * @param collection The collection.\n * @param predicate The predicate.\n * @returns Collection of chosen items.\n */\nfunction* filterIterable(collection, predicate) {\n    for (const item of collection) {\n        if (predicate(item)) {\n            yield item;\n        }\n    }\n}\n/**\n * Traverses a collection from left to right recomputing an accumulator on every\n * iteration.\n *\n * @param collection The collection.\n * @param reducer The function used to compute next value of the accumulator.\n * @param initial\n * @returns Value of the accumulator.\n */\nfunction reduceIterable(collection, reducer, initial) {\n    let result = initial;\n    for (const item of collection) {\n        result = reducer(result, item);\n    }\n    return result;\n}\n/**\n * Checks if there's at least one item in a collection satisfying a predicate.\n *\n * @param collection The collection.\n * @param predicate The predicate.\n * @returns `true` if for at least one item in the collection the predicate returns\n *      `true` and `false` otherwise.\n */\nfunction oneOfIterable(collection, predicate) {\n    for (const item of collection) {\n        if (predicate(item)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Checks if all items of a collection satisfy a predicate.\n *\n * @param collection The collection.\n * @param predicate The predicate.\n * @returns `false` if for at least one item in the collection the predicate returns\n *      `false` and `true` otherwise.\n */\nfunction allOfIterable(collection, predicate) {\n    for (const item of collection) {\n        if (!predicate(item)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Creates an iterator for [startIndex, startIndex+length) range.\n */\nfunction* rangeIterable(length, startIndex = 0) {\n    const endIndex = startIndex + length;\n    for (let i = startIndex; i < endIndex; i++) {\n        yield i;\n    }\n}\nfunction* zipIterables(ts, us, zipper = (t, u) => [t, u]) {\n    const tIterator = ts[Symbol.iterator]();\n    const uIterator = us[Symbol.iterator]();\n    for (let t = tIterator.next(), u = uIterator.next(); !(t.done || u.done); t = tIterator.next(), u = uIterator.next()) {\n        yield zipper(t.value, u.value);\n    }\n}\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = create;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = copy;\n/* unused harmony export areEqual */\n/* unused harmony export areFuzzyEqual */\n/* unused harmony export areCollinear */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = add;\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = sub;\n/* unused harmony export mulv */\n/* unused harmony export muln */\n/* unused harmony export divv */\n/* unused harmony export divn */\n/* unused harmony export length */\n/* unused harmony export distance */\n/* unused harmony export normalize */\n/* unused harmony export dot */\n/* unused harmony export cross */\n/* unused harmony export rotateX */\n/* unused harmony export rotateY */\n/* unused harmony export rotateZ */\n/* unused harmony export getPlaneLineIntersection */\n/* unused harmony export getPlaneRayIntersection */\n/* unused harmony export getPlanePlaneIntersection */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__matrix3__ = __webpack_require__(97);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__ = __webpack_require__(15);\n\n\n/**\n * Creates a new vector and initializes it with given components.\n *\n * @param x X component of the vector.\n * @param y Y component of the vector.\n * @param z Z component of the vector.\n * @returns The vector.\n */\nfunction create(x, y, z) {\n    return { x, y, z };\n}\nconst ORIGIN = create(0, 0, 0);\n/* unused harmony export ORIGIN */\n\nconst POSITIVE_X = create(1, 0, 0);\n/* unused harmony export POSITIVE_X */\n\nconst NEGATIVE_X = create(-1, 0, 0);\n/* unused harmony export NEGATIVE_X */\n\nconst POSITIVE_Y = create(0, 1, 0);\n/* unused harmony export POSITIVE_Y */\n\nconst NEGATIVE_Y = create(0, -1, 0);\n/* unused harmony export NEGATIVE_Y */\n\nconst POSITIVE_Z = create(0, 0, 1);\n/* unused harmony export POSITIVE_Z */\n\nconst NEGATIVE_Z = create(0, 0, -1);\n/* unused harmony export NEGATIVE_Z */\n\n/**\n * Copies a vector to another one.\n *\n * @param src The source vector.\n * @param dst The vector the source vector will be copied to.\n * @returns `dst`.\n */\nfunction copy(src, dst = create(0, 0, 0)) {\n    dst.x = src.x;\n    dst.y = src.y;\n    dst.z = src.z;\n    return dst;\n}\n/**\n * Checks if two vectors are strictly equal component-wise.\n *\n * @param v1 The first vector.\n * @param v2 The second vector.\n * @returns `true` if the vectors are equal and `false` otherwise.\n */\nfunction areEqual(v1, v2) {\n    return v1.x == v2.x && v1.y == v2.y && v1.z == v2.z;\n}\n/**\n * Checks if corresponding components of two vectors are all within given\n * tolerance from each other.\n *\n * @param v1 The first vector.\n * @param v2 The second vector.\n * @param tolerance The tolerance.\n * @returns `true` if the vectors are \"fuzzy\" equal and `false` otherwise.\n */\nfunction areFuzzyEqual(v1, v2, tolerance = __WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__[\"a\" /* DEFAULT_TOLERANCE */]) {\n    return (Object(__WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__[\"b\" /* default */])(v1.x, v2.x, tolerance) &&\n        Object(__WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__[\"b\" /* default */])(v1.y, v2.y, tolerance) &&\n        Object(__WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__[\"b\" /* default */])(v1.z, v2.z, tolerance));\n}\n/**\n * Checks if two vectors are collinear.\n *\n * @param v1 The first vector.\n * @param v2 The second vector.\n * @returns `true` if the vectors are collinear and `false` otherwise.\n */\nfunction areCollinear(v1, v2) {\n    const lambdaX = v1.x / v2.x;\n    const lambdaY = v1.y / v2.y;\n    const lambdaZ = v1.z / v2.z;\n    return lambdaX == lambdaY && lambdaY == lambdaZ;\n}\n/**\n * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.\n *\n * @param a The first vector.\n * @param b The second vector.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction add(a, b, dst = create(0, 0, 0)) {\n    dst.x = a.x + b.x;\n    dst.y = a.y + b.y;\n    dst.z = a.z + b.z;\n    return dst;\n}\n/**\n * Subtracts a vector from another one and stores the result to a third one, i.e.\n * `dst = a - b`.\n *\n * @param a The minuend vector.\n * @param b The subtrahend vector.\n * @param dst The vector the result will be stored to.\n */\nfunction sub(a, b, dst = create(0, 0, 0)) {\n    dst.x = a.x - b.x;\n    dst.y = a.y - b.y;\n    dst.z = a.z - b.z;\n    return dst;\n}\n/**\n * Multiplies two vectors component-wise and stores the result into a third one.\n *\n * @param a The first vector.\n * @param b The second vector.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction mulv(a, b, dst = create(0, 0, 0)) {\n    dst.x = a.x * b.x;\n    dst.y = a.y * b.y;\n    dst.z = a.z * b.z;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar and stores the result into a third vector.\n *\n * @param a The vector.\n * @param n The scalar.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction muln(a, n, dst = create(0, 0, 0)) {\n    dst.x = a.x * n;\n    dst.y = a.y * n;\n    dst.z = a.z * n;\n    return dst;\n}\n/**\n * Divides a vector by another one component wise and stores the result into a\n * third one.\n *\n * @param a The dividend vector.\n * @param b The divisor vector.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction divv(a, b, dst = create(0, 0, 0)) {\n    dst.x = a.x / b.x;\n    dst.y = a.y / b.y;\n    dst.z = a.z / b.z;\n    return dst;\n}\n/**\n * Divides a vector by a scalar and stores the result into a third vector.\n *\n * @param a The dividend vector.\n * @param n The scalar.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction divn(a, n, dst = create(0, 0, 0)) {\n    dst.x = a.x / n;\n    dst.y = a.y / n;\n    dst.z = a.z / n;\n    return dst;\n}\n/**\n * Computes length of a vector.\n *\n * @param v The vector.\n * @returns The length.\n */\nfunction length(v) {\n    return Math.hypot(v.x, v.y, v.z);\n}\n/**\n * Computes distance between ends of two vectors.\n *\n * @param a The first vector.\n * @param b The second vector.\n * @returns The distance, i.e. `length(sub(a, b))`.\n */\nfunction distance(a, b) {\n    return Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);\n}\n/**\n * Divides a vector by its length (thus making it a unit vector) and stores the\n * result to another one.\n *\n * @param v The vector to be normalized.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction normalize(v, dst = create(0, 0, 0)) {\n    return divn(v, length(v), dst);\n}\n/**\n * Computes dot product of two vectors.\n *\n * @param a The first vector.\n * @param b The second vector.\n * @returns The dot product.\n */\nfunction dot(a, b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n/**\n * Computes cross product of two vectors and stores it to a third one.\n *\n * @param a The first vector.\n * @param b The second vector.\n * @param dst The vector the result will be stored to.\n * @returns `dst`.\n */\nfunction cross(a, b, dst = create(0, 0, 0)) {\n    // Write components to a separate variables so we don't produce incorrect\n    // results in cases when a == dst or b == dst.\n    const x = a.y * b.z - a.z * b.y;\n    const y = a.z * b.x - a.x * b.z;\n    const z = a.x * b.y - a.y * b.x;\n    dst.x = x;\n    dst.y = y;\n    dst.z = z;\n    return dst;\n}\n/**\n * Rotates vector about the X axis.\n *\n * @param v The vector to be rotated.\n * @param angle The angle of rotation (in radians), positive values rotates from +Y to +Z\n * @param dst The vector the result will be stored to.\n */\nfunction rotateX(v, angle, dst = create(0, 0, 0)) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const y = v.y;\n    dst.x = v.x;\n    dst.y = y * cos - v.z * sin;\n    dst.z = y * sin + v.z * cos;\n    return dst;\n}\n/**\n * Rotates vector about the Y axis.\n *\n * @param v The vector to be rotated.\n * @param angle The angle of rotation (in radians), positive values rotates from +X to +Z\n * @param dst The vector the result will be stored to.\n */\nfunction rotateY(v, angle, dst = create(0, 0, 0)) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    // handle the case when source and destination are the same object: related components can break each other\n    v = (v === dst) ? copy(v) : v;\n    dst.x = v.x * cos + v.z * sin;\n    dst.y = v.y;\n    dst.z = -v.x * sin + v.z * cos;\n    return dst;\n}\n/**\n * Rotates vector about the Z axis.\n *\n * @param v The vector to be rotated.\n * @param angle The angle of rotation (in radians), positive values rotates from +X to +Y\n * @param dst The vector the result will be stored to.\n */\nfunction rotateZ(v, angle, dst = create(0, 0, 0)) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    // handle the case when source and destination are the same object: related components can break each other\n    v = (v === dst) ? copy(v) : v;\n    dst.x = v.x * cos - v.y * sin;\n    dst.y = v.x * sin + v.y * cos;\n    dst.z = v.z;\n    return dst;\n}\nconst X_AXIS = {\n    origin: ORIGIN,\n    tangent: POSITIVE_X\n};\n/* unused harmony export X_AXIS */\n\nconst Y_AXIS = {\n    origin: ORIGIN,\n    tangent: POSITIVE_Y\n};\n/* unused harmony export Y_AXIS */\n\nconst Z_AXIS = {\n    origin: ORIGIN,\n    tangent: POSITIVE_Z\n};\n/* unused harmony export Z_AXIS */\n\nconst XY = {\n    normal: POSITIVE_Z,\n    distance: 0\n};\n/* unused harmony export XY */\n\nconst YZ = {\n    normal: POSITIVE_X,\n    distance: 0\n};\n/* unused harmony export YZ */\n\nconst ZX = {\n    normal: POSITIVE_Y,\n    distance: 0\n};\n/* unused harmony export ZX */\n\n/**\n * Computes intersection of a plane and a line.\n *\n * @param p The plane.\n * @param l The line.\n * @returns The point or `null` if the line is parallel to the plane.\n */\nfunction getPlaneLineIntersection(p, l) {\n    const dotLP = dot(l.tangent, p.normal);\n    // If plane normal and line tangent vector are perpendicular intersection is\n    // either an empty set or the line itself.\n    if (dotLP == 0) {\n        return null;\n    }\n    const intersection = copy(l.tangent);\n    muln(intersection, (p.distance - dot(p.normal, l.origin)) / dotLP, intersection);\n    add(intersection, l.origin, intersection);\n    return intersection;\n}\n/**\n * Computes an intersection of a plane and a ray and stores it into a given\n * vector.\n *\n * @param plane The plane.\n * @param ray The ray.\n * @param dst The vector the intersection point will be stored to. If there's no\n *      intersection, this vector will be left unmodified.\n * @returns The `dst` or `null` if the ray doesn't have a common point with the\n *      plane.\n */\nfunction getPlaneRayIntersection(plane, ray, dst = create(0, 0, 0)) {\n    const dotRP = dot(ray.direction, plane.normal);\n    if (dotRP === 0) {\n        // The plane normal and the ray direction vector are perpendicular, so\n        // intersection is either an empty set or the ray itself.\n        return null;\n    }\n    const lambda = (plane.distance - dot(plane.normal, ray.origin)) / dotRP;\n    if (lambda < 0) {\n        // The intersection point is on a line that contains the ray, but not on\n        // the ray itself.\n        return null;\n    }\n    copy(ray.direction, dst);\n    muln(dst, lambda, dst);\n    add(dst, ray.origin, dst);\n    return dst;\n}\n/**\n * Computes intersection of two planes.\n *\n * @param p1 The first plane.\n * @param p2 The second plane.\n * @returns The line or `null` if the planes are parallel to each other.\n */\nfunction getPlanePlaneIntersection(p1, p2) {\n    const n1 = p1.normal;\n    const n2 = p2.normal;\n    if (areCollinear(n1, n2)) {\n        return null;\n    }\n    const tangent = cross(n1, n2);\n    normalize(tangent);\n    return {\n        tangent,\n        origin: __WEBPACK_IMPORTED_MODULE_0__matrix3__[\"b\" /* solve */](__WEBPACK_IMPORTED_MODULE_0__matrix3__[\"a\" /* fromRows */](n1, n2, tangent), create(p1.distance, p2.distance, 0))\n    };\n}\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/\n\n\nvar $protobuf = __webpack_require__(51);\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.Tile = (function() {\n\n    /**\n     * Properties of a Tile.\n     * @exports ITile\n     * @interface ITile\n     * @property {Array.<Presentation>} [presentation] Tile presentation\n     * @property {Tile.PointObjects} [points] Tile points\n     * @property {Tile.PolylineObjects} [polylines] Tile polylines\n     * @property {Tile.PolygonObjects} [polygons] Tile polygons\n     * @property {Tile.StraightLabels} [pointLabels] Tile pointLabels\n     * @property {Tile.CurvedLabels} [polylineLabels] Tile polylineLabels\n     * @property {Array.<Tile.Layer>} [layers] Tile layers\n     */\n\n    /**\n     * Constructs a new Tile.\n     * @exports Tile\n     * @classdesc Represents a Tile.\n     * @constructor\n     * @param {ITile=} [properties] Properties to set\n     */\n    function Tile(properties) {\n        this.presentation = [];\n        this.layers = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Tile presentation.\n     * @member {Array.<Presentation>}presentation\n     * @memberof Tile\n     * @instance\n     */\n    Tile.prototype.presentation = $util.emptyArray;\n\n    /**\n     * Tile points.\n     * @member {(Tile.PointObjects|null|undefined)}points\n     * @memberof Tile\n     * @instance\n     */\n    Tile.prototype.points = null;\n\n    /**\n     * Tile polylines.\n     * @member {(Tile.PolylineObjects|null|undefined)}polylines\n     * @memberof Tile\n     * @instance\n     */\n    Tile.prototype.polylines = null;\n\n    /**\n     * Tile polygons.\n     * @member {(Tile.PolygonObjects|null|undefined)}polygons\n     * @memberof Tile\n     * @instance\n     */\n    Tile.prototype.polygons = null;\n\n    /**\n     * Tile pointLabels.\n     * @member {(Tile.StraightLabels|null|undefined)}pointLabels\n     * @memberof Tile\n     * @instance\n     */\n    Tile.prototype.pointLabels = null;\n\n    /**\n     * Tile polylineLabels.\n     * @member {(Tile.CurvedLabels|null|undefined)}polylineLabels\n     * @memberof Tile\n     * @instance\n     */\n    Tile.prototype.polylineLabels = null;\n\n    /**\n     * Tile layers.\n     * @member {Array.<Tile.Layer>}layers\n     * @memberof Tile\n     * @instance\n     */\n    Tile.prototype.layers = $util.emptyArray;\n\n    /**\n     * Decodes a Tile message from the specified reader or buffer.\n     * @function decode\n     * @memberof Tile\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Tile} Tile\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Tile.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tile();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.presentation && message.presentation.length))\n                    message.presentation = [];\n                message.presentation.push($root.Presentation.decode(reader, reader.uint32()));\n                break;\n            case 2:\n                message.points = $root.Tile.PointObjects.decode(reader, reader.uint32());\n                break;\n            case 3:\n                message.polylines = $root.Tile.PolylineObjects.decode(reader, reader.uint32());\n                break;\n            case 4:\n                message.polygons = $root.Tile.PolygonObjects.decode(reader, reader.uint32());\n                break;\n            case 5:\n                message.pointLabels = $root.Tile.StraightLabels.decode(reader, reader.uint32());\n                break;\n            case 6:\n                message.polylineLabels = $root.Tile.CurvedLabels.decode(reader, reader.uint32());\n                break;\n            case 8:\n                if (!(message.layers && message.layers.length))\n                    message.layers = [];\n                message.layers.push($root.Tile.Layer.decode(reader, reader.uint32()));\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    Tile.PointObjects = (function() {\n\n        /**\n         * Properties of a PointObjects.\n         * @memberof Tile\n         * @interface IPointObjects\n         * @property {Array.<number>} [coordsx] PointObjects coordsx\n         * @property {Array.<number>} [coordsy] PointObjects coordsy\n         * @property {Array.<number>} [classId] PointObjects classId\n         * @property {Array.<number>} [zOrder] PointObjects zOrder\n         */\n\n        /**\n         * Constructs a new PointObjects.\n         * @memberof Tile\n         * @classdesc Represents a PointObjects.\n         * @constructor\n         * @param {Tile.IPointObjects=} [properties] Properties to set\n         */\n        function PointObjects(properties) {\n            this.coordsx = [];\n            this.coordsy = [];\n            this.classId = [];\n            this.zOrder = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * PointObjects coordsx.\n         * @member {Array.<number>}coordsx\n         * @memberof Tile.PointObjects\n         * @instance\n         */\n        PointObjects.prototype.coordsx = $util.emptyArray;\n\n        /**\n         * PointObjects coordsy.\n         * @member {Array.<number>}coordsy\n         * @memberof Tile.PointObjects\n         * @instance\n         */\n        PointObjects.prototype.coordsy = $util.emptyArray;\n\n        /**\n         * PointObjects classId.\n         * @member {Array.<number>}classId\n         * @memberof Tile.PointObjects\n         * @instance\n         */\n        PointObjects.prototype.classId = $util.emptyArray;\n\n        /**\n         * PointObjects zOrder.\n         * @member {Array.<number>}zOrder\n         * @memberof Tile.PointObjects\n         * @instance\n         */\n        PointObjects.prototype.zOrder = $util.emptyArray;\n\n        /**\n         * Decodes a PointObjects message from the specified reader or buffer.\n         * @function decode\n         * @memberof Tile.PointObjects\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Tile.PointObjects} PointObjects\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PointObjects.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tile.PointObjects();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.coordsx && message.coordsx.length))\n                        message.coordsx = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.coordsx.push(reader.sint32());\n                    } else\n                        message.coordsx.push(reader.sint32());\n                    break;\n                case 2:\n                    if (!(message.coordsy && message.coordsy.length))\n                        message.coordsy = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.coordsy.push(reader.sint32());\n                    } else\n                        message.coordsy.push(reader.sint32());\n                    break;\n                case 3:\n                    if (!(message.classId && message.classId.length))\n                        message.classId = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.classId.push(reader.uint32());\n                    } else\n                        message.classId.push(reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.zOrder && message.zOrder.length))\n                        message.zOrder = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.zOrder.push(reader.sint32());\n                    } else\n                        message.zOrder.push(reader.sint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return PointObjects;\n    })();\n\n    Tile.PolylineObjects = (function() {\n\n        /**\n         * Properties of a PolylineObjects.\n         * @memberof Tile\n         * @interface IPolylineObjects\n         * @property {Array.<number>} [coordsx] PolylineObjects coordsx\n         * @property {Array.<number>} [coordsy] PolylineObjects coordsy\n         * @property {Array.<number>} [lineSize] PolylineObjects lineSize\n         * @property {Array.<number|Long>} [distance] PolylineObjects distance\n         * @property {Array.<number>} [classId] PolylineObjects classId\n         * @property {Array.<number>} [pointVisibility] PolylineObjects pointVisibility\n         * @property {Array.<number>} [zOrderBegin] PolylineObjects zOrderBegin\n         * @property {Array.<number>} [zOrderEnd] PolylineObjects zOrderEnd\n         */\n\n        /**\n         * Constructs a new PolylineObjects.\n         * @memberof Tile\n         * @classdesc Represents a PolylineObjects.\n         * @constructor\n         * @param {Tile.IPolylineObjects=} [properties] Properties to set\n         */\n        function PolylineObjects(properties) {\n            this.coordsx = [];\n            this.coordsy = [];\n            this.lineSize = [];\n            this.distance = [];\n            this.classId = [];\n            this.pointVisibility = [];\n            this.zOrderBegin = [];\n            this.zOrderEnd = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * PolylineObjects coordsx.\n         * @member {Array.<number>}coordsx\n         * @memberof Tile.PolylineObjects\n         * @instance\n         */\n        PolylineObjects.prototype.coordsx = $util.emptyArray;\n\n        /**\n         * PolylineObjects coordsy.\n         * @member {Array.<number>}coordsy\n         * @memberof Tile.PolylineObjects\n         * @instance\n         */\n        PolylineObjects.prototype.coordsy = $util.emptyArray;\n\n        /**\n         * PolylineObjects lineSize.\n         * @member {Array.<number>}lineSize\n         * @memberof Tile.PolylineObjects\n         * @instance\n         */\n        PolylineObjects.prototype.lineSize = $util.emptyArray;\n\n        /**\n         * PolylineObjects distance.\n         * @member {Array.<number|Long>}distance\n         * @memberof Tile.PolylineObjects\n         * @instance\n         */\n        PolylineObjects.prototype.distance = $util.emptyArray;\n\n        /**\n         * PolylineObjects classId.\n         * @member {Array.<number>}classId\n         * @memberof Tile.PolylineObjects\n         * @instance\n         */\n        PolylineObjects.prototype.classId = $util.emptyArray;\n\n        /**\n         * PolylineObjects pointVisibility.\n         * @member {Array.<number>}pointVisibility\n         * @memberof Tile.PolylineObjects\n         * @instance\n         */\n        PolylineObjects.prototype.pointVisibility = $util.emptyArray;\n\n        /**\n         * PolylineObjects zOrderBegin.\n         * @member {Array.<number>}zOrderBegin\n         * @memberof Tile.PolylineObjects\n         * @instance\n         */\n        PolylineObjects.prototype.zOrderBegin = $util.emptyArray;\n\n        /**\n         * PolylineObjects zOrderEnd.\n         * @member {Array.<number>}zOrderEnd\n         * @memberof Tile.PolylineObjects\n         * @instance\n         */\n        PolylineObjects.prototype.zOrderEnd = $util.emptyArray;\n\n        /**\n         * Decodes a PolylineObjects message from the specified reader or buffer.\n         * @function decode\n         * @memberof Tile.PolylineObjects\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Tile.PolylineObjects} PolylineObjects\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PolylineObjects.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tile.PolylineObjects();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.coordsx && message.coordsx.length))\n                        message.coordsx = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.coordsx.push(reader.sint32());\n                    } else\n                        message.coordsx.push(reader.sint32());\n                    break;\n                case 2:\n                    if (!(message.coordsy && message.coordsy.length))\n                        message.coordsy = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.coordsy.push(reader.sint32());\n                    } else\n                        message.coordsy.push(reader.sint32());\n                    break;\n                case 3:\n                    if (!(message.lineSize && message.lineSize.length))\n                        message.lineSize = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.lineSize.push(reader.uint32());\n                    } else\n                        message.lineSize.push(reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.distance && message.distance.length))\n                        message.distance = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.distance.push(reader.uint64());\n                    } else\n                        message.distance.push(reader.uint64());\n                    break;\n                case 5:\n                    if (!(message.classId && message.classId.length))\n                        message.classId = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.classId.push(reader.uint32());\n                    } else\n                        message.classId.push(reader.uint32());\n                    break;\n                case 6:\n                    if (!(message.pointVisibility && message.pointVisibility.length))\n                        message.pointVisibility = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.pointVisibility.push(reader.uint32());\n                    } else\n                        message.pointVisibility.push(reader.uint32());\n                    break;\n                case 7:\n                    if (!(message.zOrderBegin && message.zOrderBegin.length))\n                        message.zOrderBegin = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.zOrderBegin.push(reader.sint32());\n                    } else\n                        message.zOrderBegin.push(reader.sint32());\n                    break;\n                case 8:\n                    if (!(message.zOrderEnd && message.zOrderEnd.length))\n                        message.zOrderEnd = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.zOrderEnd.push(reader.sint32());\n                    } else\n                        message.zOrderEnd.push(reader.sint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return PolylineObjects;\n    })();\n\n    Tile.PolygonObjects = (function() {\n\n        /**\n         * Properties of a PolygonObjects.\n         * @memberof Tile\n         * @interface IPolygonObjects\n         * @property {Array.<number>} [coordsx] PolygonObjects coordsx\n         * @property {Array.<number>} [coordsy] PolygonObjects coordsy\n         * @property {Array.<number>} [classId] PolygonObjects classId\n         * @property {Array.<number>} [ringCount] PolygonObjects ringCount\n         * @property {Array.<number>} [ringSize] PolygonObjects ringSize\n         * @property {Array.<number>} [contourIndex] PolygonObjects contourIndex\n         * @property {Array.<number>} [contourCount] PolygonObjects contourCount\n         * @property {Array.<number>} [pointVisibility] PolygonObjects pointVisibility\n         * @property {Array.<number>} [height] PolygonObjects height\n         * @property {Array.<number>} [zOrder] PolygonObjects zOrder\n         * @property {Array.<Tile.PolygonObjects.Mesh>} [mesh] PolygonObjects mesh\n         */\n\n        /**\n         * Constructs a new PolygonObjects.\n         * @memberof Tile\n         * @classdesc Represents a PolygonObjects.\n         * @constructor\n         * @param {Tile.IPolygonObjects=} [properties] Properties to set\n         */\n        function PolygonObjects(properties) {\n            this.coordsx = [];\n            this.coordsy = [];\n            this.classId = [];\n            this.ringCount = [];\n            this.ringSize = [];\n            this.contourIndex = [];\n            this.contourCount = [];\n            this.pointVisibility = [];\n            this.height = [];\n            this.zOrder = [];\n            this.mesh = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * PolygonObjects coordsx.\n         * @member {Array.<number>}coordsx\n         * @memberof Tile.PolygonObjects\n         * @instance\n         */\n        PolygonObjects.prototype.coordsx = $util.emptyArray;\n\n        /**\n         * PolygonObjects coordsy.\n         * @member {Array.<number>}coordsy\n         * @memberof Tile.PolygonObjects\n         * @instance\n         */\n        PolygonObjects.prototype.coordsy = $util.emptyArray;\n\n        /**\n         * PolygonObjects classId.\n         * @member {Array.<number>}classId\n         * @memberof Tile.PolygonObjects\n         * @instance\n         */\n        PolygonObjects.prototype.classId = $util.emptyArray;\n\n        /**\n         * PolygonObjects ringCount.\n         * @member {Array.<number>}ringCount\n         * @memberof Tile.PolygonObjects\n         * @instance\n         */\n        PolygonObjects.prototype.ringCount = $util.emptyArray;\n\n        /**\n         * PolygonObjects ringSize.\n         * @member {Array.<number>}ringSize\n         * @memberof Tile.PolygonObjects\n         * @instance\n         */\n        PolygonObjects.prototype.ringSize = $util.emptyArray;\n\n        /**\n         * PolygonObjects contourIndex.\n         * @member {Array.<number>}contourIndex\n         * @memberof Tile.PolygonObjects\n         * @instance\n         */\n        PolygonObjects.prototype.contourIndex = $util.emptyArray;\n\n        /**\n         * PolygonObjects contourCount.\n         * @member {Array.<number>}contourCount\n         * @memberof Tile.PolygonObjects\n         * @instance\n         */\n        PolygonObjects.prototype.contourCount = $util.emptyArray;\n\n        /**\n         * PolygonObjects pointVisibility.\n         * @member {Array.<number>}pointVisibility\n         * @memberof Tile.PolygonObjects\n         * @instance\n         */\n        PolygonObjects.prototype.pointVisibility = $util.emptyArray;\n\n        /**\n         * PolygonObjects height.\n         * @member {Array.<number>}height\n         * @memberof Tile.PolygonObjects\n         * @instance\n         */\n        PolygonObjects.prototype.height = $util.emptyArray;\n\n        /**\n         * PolygonObjects zOrder.\n         * @member {Array.<number>}zOrder\n         * @memberof Tile.PolygonObjects\n         * @instance\n         */\n        PolygonObjects.prototype.zOrder = $util.emptyArray;\n\n        /**\n         * PolygonObjects mesh.\n         * @member {Array.<Tile.PolygonObjects.Mesh>}mesh\n         * @memberof Tile.PolygonObjects\n         * @instance\n         */\n        PolygonObjects.prototype.mesh = $util.emptyArray;\n\n        /**\n         * Decodes a PolygonObjects message from the specified reader or buffer.\n         * @function decode\n         * @memberof Tile.PolygonObjects\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Tile.PolygonObjects} PolygonObjects\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PolygonObjects.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tile.PolygonObjects();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.coordsx && message.coordsx.length))\n                        message.coordsx = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.coordsx.push(reader.sint32());\n                    } else\n                        message.coordsx.push(reader.sint32());\n                    break;\n                case 2:\n                    if (!(message.coordsy && message.coordsy.length))\n                        message.coordsy = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.coordsy.push(reader.sint32());\n                    } else\n                        message.coordsy.push(reader.sint32());\n                    break;\n                case 3:\n                    if (!(message.classId && message.classId.length))\n                        message.classId = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.classId.push(reader.uint32());\n                    } else\n                        message.classId.push(reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.ringCount && message.ringCount.length))\n                        message.ringCount = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.ringCount.push(reader.uint32());\n                    } else\n                        message.ringCount.push(reader.uint32());\n                    break;\n                case 5:\n                    if (!(message.ringSize && message.ringSize.length))\n                        message.ringSize = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.ringSize.push(reader.uint32());\n                    } else\n                        message.ringSize.push(reader.uint32());\n                    break;\n                case 6:\n                    if (!(message.contourIndex && message.contourIndex.length))\n                        message.contourIndex = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.contourIndex.push(reader.sint32());\n                    } else\n                        message.contourIndex.push(reader.sint32());\n                    break;\n                case 7:\n                    if (!(message.contourCount && message.contourCount.length))\n                        message.contourCount = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.contourCount.push(reader.sint32());\n                    } else\n                        message.contourCount.push(reader.sint32());\n                    break;\n                case 8:\n                    if (!(message.pointVisibility && message.pointVisibility.length))\n                        message.pointVisibility = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.pointVisibility.push(reader.uint32());\n                    } else\n                        message.pointVisibility.push(reader.uint32());\n                    break;\n                case 9:\n                    if (!(message.height && message.height.length))\n                        message.height = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.height.push(reader.sint32());\n                    } else\n                        message.height.push(reader.sint32());\n                    break;\n                case 10:\n                    if (!(message.zOrder && message.zOrder.length))\n                        message.zOrder = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.zOrder.push(reader.sint32());\n                    } else\n                        message.zOrder.push(reader.sint32());\n                    break;\n                case 11:\n                    if (!(message.mesh && message.mesh.length))\n                        message.mesh = [];\n                    message.mesh.push($root.Tile.PolygonObjects.Mesh.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        PolygonObjects.BBox = (function() {\n\n            /**\n             * Properties of a BBox.\n             * @memberof Tile.PolygonObjects\n             * @interface IBBox\n             * @property {number} [minX] BBox minX\n             * @property {number} [minY] BBox minY\n             * @property {number} [maxX] BBox maxX\n             * @property {number} [maxY] BBox maxY\n             */\n\n            /**\n             * Constructs a new BBox.\n             * @memberof Tile.PolygonObjects\n             * @classdesc Represents a BBox.\n             * @constructor\n             * @param {Tile.PolygonObjects.IBBox=} [properties] Properties to set\n             */\n            function BBox(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * BBox minX.\n             * @member {number}minX\n             * @memberof Tile.PolygonObjects.BBox\n             * @instance\n             */\n            BBox.prototype.minX = 0;\n\n            /**\n             * BBox minY.\n             * @member {number}minY\n             * @memberof Tile.PolygonObjects.BBox\n             * @instance\n             */\n            BBox.prototype.minY = 0;\n\n            /**\n             * BBox maxX.\n             * @member {number}maxX\n             * @memberof Tile.PolygonObjects.BBox\n             * @instance\n             */\n            BBox.prototype.maxX = 0;\n\n            /**\n             * BBox maxY.\n             * @member {number}maxY\n             * @memberof Tile.PolygonObjects.BBox\n             * @instance\n             */\n            BBox.prototype.maxY = 0;\n\n            /**\n             * Decodes a BBox message from the specified reader or buffer.\n             * @function decode\n             * @memberof Tile.PolygonObjects.BBox\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Tile.PolygonObjects.BBox} BBox\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            BBox.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tile.PolygonObjects.BBox();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.minX = reader.sint32();\n                        break;\n                    case 2:\n                        message.minY = reader.sint32();\n                        break;\n                    case 3:\n                        message.maxX = reader.sint32();\n                        break;\n                    case 4:\n                        message.maxY = reader.sint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            return BBox;\n        })();\n\n        PolygonObjects.Mesh = (function() {\n\n            /**\n             * Properties of a Mesh.\n             * @memberof Tile.PolygonObjects\n             * @interface IMesh\n             * @property {number} [polygonId] Mesh polygonId\n             * @property {string} [meshId] Mesh meshId\n             * @property {Tile.PolygonObjects.BBox} [bbox] Mesh bbox\n             * @property {string} [objectId] Mesh objectId\n             */\n\n            /**\n             * Constructs a new Mesh.\n             * @memberof Tile.PolygonObjects\n             * @classdesc Represents a Mesh.\n             * @constructor\n             * @param {Tile.PolygonObjects.IMesh=} [properties] Properties to set\n             */\n            function Mesh(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Mesh polygonId.\n             * @member {number}polygonId\n             * @memberof Tile.PolygonObjects.Mesh\n             * @instance\n             */\n            Mesh.prototype.polygonId = 0;\n\n            /**\n             * Mesh meshId.\n             * @member {string}meshId\n             * @memberof Tile.PolygonObjects.Mesh\n             * @instance\n             */\n            Mesh.prototype.meshId = \"\";\n\n            /**\n             * Mesh bbox.\n             * @member {(Tile.PolygonObjects.BBox|null|undefined)}bbox\n             * @memberof Tile.PolygonObjects.Mesh\n             * @instance\n             */\n            Mesh.prototype.bbox = null;\n\n            /**\n             * Mesh objectId.\n             * @member {string}objectId\n             * @memberof Tile.PolygonObjects.Mesh\n             * @instance\n             */\n            Mesh.prototype.objectId = \"\";\n\n            /**\n             * Decodes a Mesh message from the specified reader or buffer.\n             * @function decode\n             * @memberof Tile.PolygonObjects.Mesh\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Tile.PolygonObjects.Mesh} Mesh\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Mesh.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tile.PolygonObjects.Mesh();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.polygonId = reader.uint32();\n                        break;\n                    case 2:\n                        message.meshId = reader.string();\n                        break;\n                    case 3:\n                        message.bbox = $root.Tile.PolygonObjects.BBox.decode(reader, reader.uint32());\n                        break;\n                    case 4:\n                        message.objectId = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            return Mesh;\n        })();\n\n        return PolygonObjects;\n    })();\n\n    Tile.ShapedString = (function() {\n\n        /**\n         * Properties of a ShapedString.\n         * @memberof Tile\n         * @interface IShapedString\n         * @property {Array.<number>} [glyphs] ShapedString glyphs\n         */\n\n        /**\n         * Constructs a new ShapedString.\n         * @memberof Tile\n         * @classdesc Represents a ShapedString.\n         * @constructor\n         * @param {Tile.IShapedString=} [properties] Properties to set\n         */\n        function ShapedString(properties) {\n            this.glyphs = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ShapedString glyphs.\n         * @member {Array.<number>}glyphs\n         * @memberof Tile.ShapedString\n         * @instance\n         */\n        ShapedString.prototype.glyphs = $util.emptyArray;\n\n        /**\n         * Decodes a ShapedString message from the specified reader or buffer.\n         * @function decode\n         * @memberof Tile.ShapedString\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Tile.ShapedString} ShapedString\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ShapedString.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tile.ShapedString();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.glyphs && message.glyphs.length))\n                        message.glyphs = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.glyphs.push(reader.uint32());\n                    } else\n                        message.glyphs.push(reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ShapedString;\n    })();\n\n    Tile.ShapedText = (function() {\n\n        /**\n         * Properties of a ShapedText.\n         * @memberof Tile\n         * @interface IShapedText\n         * @property {Array.<Tile.ShapedString>} [strings] ShapedText strings\n         */\n\n        /**\n         * Constructs a new ShapedText.\n         * @memberof Tile\n         * @classdesc Represents a ShapedText.\n         * @constructor\n         * @param {Tile.IShapedText=} [properties] Properties to set\n         */\n        function ShapedText(properties) {\n            this.strings = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ShapedText strings.\n         * @member {Array.<Tile.ShapedString>}strings\n         * @memberof Tile.ShapedText\n         * @instance\n         */\n        ShapedText.prototype.strings = $util.emptyArray;\n\n        /**\n         * Decodes a ShapedText message from the specified reader or buffer.\n         * @function decode\n         * @memberof Tile.ShapedText\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Tile.ShapedText} ShapedText\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ShapedText.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tile.ShapedText();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.strings && message.strings.length))\n                        message.strings = [];\n                    message.strings.push($root.Tile.ShapedString.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ShapedText;\n    })();\n\n    Tile.StraightLabels = (function() {\n\n        /**\n         * Properties of a StraightLabels.\n         * @memberof Tile\n         * @interface IStraightLabels\n         * @property {Array.<number>} [classId] StraightLabels classId\n         * @property {Array.<number>} [centerX] StraightLabels centerX\n         * @property {Array.<number>} [centerY] StraightLabels centerY\n         * @property {Array.<number>} [offsetX] StraightLabels offsetX\n         * @property {Array.<number>} [offsetY] StraightLabels offsetY\n         * @property {Array.<Tile.ShapedText>} [text] StraightLabels text\n         * @property {Array.<Tile.ShapedText>} [textAlt] StraightLabels textAlt\n         * @property {Array.<number>} [priority] StraightLabels priority\n         * @property {Array.<Tile.StraightLabels.AlignType>} [align] StraightLabels align\n         */\n\n        /**\n         * Constructs a new StraightLabels.\n         * @memberof Tile\n         * @classdesc Represents a StraightLabels.\n         * @constructor\n         * @param {Tile.IStraightLabels=} [properties] Properties to set\n         */\n        function StraightLabels(properties) {\n            this.classId = [];\n            this.centerX = [];\n            this.centerY = [];\n            this.offsetX = [];\n            this.offsetY = [];\n            this.text = [];\n            this.textAlt = [];\n            this.priority = [];\n            this.align = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * StraightLabels classId.\n         * @member {Array.<number>}classId\n         * @memberof Tile.StraightLabels\n         * @instance\n         */\n        StraightLabels.prototype.classId = $util.emptyArray;\n\n        /**\n         * StraightLabels centerX.\n         * @member {Array.<number>}centerX\n         * @memberof Tile.StraightLabels\n         * @instance\n         */\n        StraightLabels.prototype.centerX = $util.emptyArray;\n\n        /**\n         * StraightLabels centerY.\n         * @member {Array.<number>}centerY\n         * @memberof Tile.StraightLabels\n         * @instance\n         */\n        StraightLabels.prototype.centerY = $util.emptyArray;\n\n        /**\n         * StraightLabels offsetX.\n         * @member {Array.<number>}offsetX\n         * @memberof Tile.StraightLabels\n         * @instance\n         */\n        StraightLabels.prototype.offsetX = $util.emptyArray;\n\n        /**\n         * StraightLabels offsetY.\n         * @member {Array.<number>}offsetY\n         * @memberof Tile.StraightLabels\n         * @instance\n         */\n        StraightLabels.prototype.offsetY = $util.emptyArray;\n\n        /**\n         * StraightLabels text.\n         * @member {Array.<Tile.ShapedText>}text\n         * @memberof Tile.StraightLabels\n         * @instance\n         */\n        StraightLabels.prototype.text = $util.emptyArray;\n\n        /**\n         * StraightLabels textAlt.\n         * @member {Array.<Tile.ShapedText>}textAlt\n         * @memberof Tile.StraightLabels\n         * @instance\n         */\n        StraightLabels.prototype.textAlt = $util.emptyArray;\n\n        /**\n         * StraightLabels priority.\n         * @member {Array.<number>}priority\n         * @memberof Tile.StraightLabels\n         * @instance\n         */\n        StraightLabels.prototype.priority = $util.emptyArray;\n\n        /**\n         * StraightLabels align.\n         * @member {Array.<Tile.StraightLabels.AlignType>}align\n         * @memberof Tile.StraightLabels\n         * @instance\n         */\n        StraightLabels.prototype.align = $util.emptyArray;\n\n        /**\n         * Decodes a StraightLabels message from the specified reader or buffer.\n         * @function decode\n         * @memberof Tile.StraightLabels\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Tile.StraightLabels} StraightLabels\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        StraightLabels.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tile.StraightLabels();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.classId && message.classId.length))\n                        message.classId = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.classId.push(reader.uint32());\n                    } else\n                        message.classId.push(reader.uint32());\n                    break;\n                case 2:\n                    if (!(message.centerX && message.centerX.length))\n                        message.centerX = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.centerX.push(reader.sint32());\n                    } else\n                        message.centerX.push(reader.sint32());\n                    break;\n                case 3:\n                    if (!(message.centerY && message.centerY.length))\n                        message.centerY = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.centerY.push(reader.sint32());\n                    } else\n                        message.centerY.push(reader.sint32());\n                    break;\n                case 4:\n                    if (!(message.offsetX && message.offsetX.length))\n                        message.offsetX = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.offsetX.push(reader.sint32());\n                    } else\n                        message.offsetX.push(reader.sint32());\n                    break;\n                case 5:\n                    if (!(message.offsetY && message.offsetY.length))\n                        message.offsetY = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.offsetY.push(reader.sint32());\n                    } else\n                        message.offsetY.push(reader.sint32());\n                    break;\n                case 6:\n                    if (!(message.text && message.text.length))\n                        message.text = [];\n                    message.text.push($root.Tile.ShapedText.decode(reader, reader.uint32()));\n                    break;\n                case 7:\n                    if (!(message.textAlt && message.textAlt.length))\n                        message.textAlt = [];\n                    message.textAlt.push($root.Tile.ShapedText.decode(reader, reader.uint32()));\n                    break;\n                case 8:\n                    if (!(message.priority && message.priority.length))\n                        message.priority = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.priority.push(reader.sint32());\n                    } else\n                        message.priority.push(reader.sint32());\n                    break;\n                case 9:\n                    if (!(message.align && message.align.length))\n                        message.align = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.align.push(reader.int32());\n                    } else\n                        message.align.push(reader.int32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * AlignType enum.\n         * @enum {string}\n         * @property {number} Left=0 Left value\n         * @property {number} Center=1 Center value\n         * @property {number} Right=2 Right value\n         */\n        StraightLabels.AlignType = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"Left\"] = 0;\n            values[valuesById[1] = \"Center\"] = 1;\n            values[valuesById[2] = \"Right\"] = 2;\n            return values;\n        })();\n\n        return StraightLabels;\n    })();\n\n    Tile.CurvedLabels = (function() {\n\n        /**\n         * Properties of a CurvedLabels.\n         * @memberof Tile\n         * @interface ICurvedLabels\n         * @property {Array.<number>} [classId] CurvedLabels classId\n         * @property {Array.<Tile.ShapedString>} [text] CurvedLabels text\n         * @property {Array.<Tile.ShapedString>} [textAlt] CurvedLabels textAlt\n         * @property {Array.<number>} [priority] CurvedLabels priority\n         * @property {Array.<number>} [verticesCount] CurvedLabels verticesCount\n         * @property {Array.<number>} [vertexX] CurvedLabels vertexX\n         * @property {Array.<number>} [vertexY] CurvedLabels vertexY\n         */\n\n        /**\n         * Constructs a new CurvedLabels.\n         * @memberof Tile\n         * @classdesc Represents a CurvedLabels.\n         * @constructor\n         * @param {Tile.ICurvedLabels=} [properties] Properties to set\n         */\n        function CurvedLabels(properties) {\n            this.classId = [];\n            this.text = [];\n            this.textAlt = [];\n            this.priority = [];\n            this.verticesCount = [];\n            this.vertexX = [];\n            this.vertexY = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CurvedLabels classId.\n         * @member {Array.<number>}classId\n         * @memberof Tile.CurvedLabels\n         * @instance\n         */\n        CurvedLabels.prototype.classId = $util.emptyArray;\n\n        /**\n         * CurvedLabels text.\n         * @member {Array.<Tile.ShapedString>}text\n         * @memberof Tile.CurvedLabels\n         * @instance\n         */\n        CurvedLabels.prototype.text = $util.emptyArray;\n\n        /**\n         * CurvedLabels textAlt.\n         * @member {Array.<Tile.ShapedString>}textAlt\n         * @memberof Tile.CurvedLabels\n         * @instance\n         */\n        CurvedLabels.prototype.textAlt = $util.emptyArray;\n\n        /**\n         * CurvedLabels priority.\n         * @member {Array.<number>}priority\n         * @memberof Tile.CurvedLabels\n         * @instance\n         */\n        CurvedLabels.prototype.priority = $util.emptyArray;\n\n        /**\n         * CurvedLabels verticesCount.\n         * @member {Array.<number>}verticesCount\n         * @memberof Tile.CurvedLabels\n         * @instance\n         */\n        CurvedLabels.prototype.verticesCount = $util.emptyArray;\n\n        /**\n         * CurvedLabels vertexX.\n         * @member {Array.<number>}vertexX\n         * @memberof Tile.CurvedLabels\n         * @instance\n         */\n        CurvedLabels.prototype.vertexX = $util.emptyArray;\n\n        /**\n         * CurvedLabels vertexY.\n         * @member {Array.<number>}vertexY\n         * @memberof Tile.CurvedLabels\n         * @instance\n         */\n        CurvedLabels.prototype.vertexY = $util.emptyArray;\n\n        /**\n         * Decodes a CurvedLabels message from the specified reader or buffer.\n         * @function decode\n         * @memberof Tile.CurvedLabels\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Tile.CurvedLabels} CurvedLabels\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CurvedLabels.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tile.CurvedLabels();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.classId && message.classId.length))\n                        message.classId = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.classId.push(reader.uint32());\n                    } else\n                        message.classId.push(reader.uint32());\n                    break;\n                case 2:\n                    if (!(message.text && message.text.length))\n                        message.text = [];\n                    message.text.push($root.Tile.ShapedString.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    if (!(message.textAlt && message.textAlt.length))\n                        message.textAlt = [];\n                    message.textAlt.push($root.Tile.ShapedString.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    if (!(message.priority && message.priority.length))\n                        message.priority = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.priority.push(reader.sint32());\n                    } else\n                        message.priority.push(reader.sint32());\n                    break;\n                case 5:\n                    if (!(message.verticesCount && message.verticesCount.length))\n                        message.verticesCount = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.verticesCount.push(reader.uint32());\n                    } else\n                        message.verticesCount.push(reader.uint32());\n                    break;\n                case 6:\n                    if (!(message.vertexX && message.vertexX.length))\n                        message.vertexX = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.vertexX.push(reader.sint32());\n                    } else\n                        message.vertexX.push(reader.sint32());\n                    break;\n                case 7:\n                    if (!(message.vertexY && message.vertexY.length))\n                        message.vertexY = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.vertexY.push(reader.sint32());\n                    } else\n                        message.vertexY.push(reader.sint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return CurvedLabels;\n    })();\n\n    Tile.Layer = (function() {\n\n        /**\n         * Properties of a Layer.\n         * @memberof Tile\n         * @interface ILayer\n         * @property {string} [name] Layer name\n         * @property {Array.<string>} [ids] Layer ids\n         * @property {Array.<number>} [objectIndices] Layer objectIndices\n         * @property {Array.<string>} [keys] Layer keys\n         * @property {Array.<string>} [values] Layer values\n         */\n\n        /**\n         * Constructs a new Layer.\n         * @memberof Tile\n         * @classdesc Represents a Layer.\n         * @constructor\n         * @param {Tile.ILayer=} [properties] Properties to set\n         */\n        function Layer(properties) {\n            this.ids = [];\n            this.objectIndices = [];\n            this.keys = [];\n            this.values = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Layer name.\n         * @member {string}name\n         * @memberof Tile.Layer\n         * @instance\n         */\n        Layer.prototype.name = \"\";\n\n        /**\n         * Layer ids.\n         * @member {Array.<string>}ids\n         * @memberof Tile.Layer\n         * @instance\n         */\n        Layer.prototype.ids = $util.emptyArray;\n\n        /**\n         * Layer objectIndices.\n         * @member {Array.<number>}objectIndices\n         * @memberof Tile.Layer\n         * @instance\n         */\n        Layer.prototype.objectIndices = $util.emptyArray;\n\n        /**\n         * Layer keys.\n         * @member {Array.<string>}keys\n         * @memberof Tile.Layer\n         * @instance\n         */\n        Layer.prototype.keys = $util.emptyArray;\n\n        /**\n         * Layer values.\n         * @member {Array.<string>}values\n         * @memberof Tile.Layer\n         * @instance\n         */\n        Layer.prototype.values = $util.emptyArray;\n\n        /**\n         * Decodes a Layer message from the specified reader or buffer.\n         * @function decode\n         * @memberof Tile.Layer\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Tile.Layer} Layer\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Layer.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tile.Layer();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    if (!(message.ids && message.ids.length))\n                        message.ids = [];\n                    message.ids.push(reader.string());\n                    break;\n                case 3:\n                    if (!(message.objectIndices && message.objectIndices.length))\n                        message.objectIndices = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.objectIndices.push(reader.uint32());\n                    } else\n                        message.objectIndices.push(reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.keys && message.keys.length))\n                        message.keys = [];\n                    message.keys.push(reader.string());\n                    break;\n                case 5:\n                    if (!(message.values && message.values.length))\n                        message.values = [];\n                    message.values.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return Layer;\n    })();\n\n    return Tile;\n})();\n\n$root.Glyph = (function() {\n\n    /**\n     * Properties of a Glyph.\n     * @exports IGlyph\n     * @interface IGlyph\n     * @property {number} id Glyph id\n     * @property {Uint8Array} bitmap Glyph bitmap\n     * @property {number} width Glyph width\n     * @property {number} height Glyph height\n     * @property {number} bearingX Glyph bearingX\n     * @property {number} bearingY Glyph bearingY\n     * @property {number} advance Glyph advance\n     */\n\n    /**\n     * Constructs a new Glyph.\n     * @exports Glyph\n     * @classdesc Represents a Glyph.\n     * @constructor\n     * @param {IGlyph=} [properties] Properties to set\n     */\n    function Glyph(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Glyph id.\n     * @member {number}id\n     * @memberof Glyph\n     * @instance\n     */\n    Glyph.prototype.id = 0;\n\n    /**\n     * Glyph bitmap.\n     * @member {Uint8Array}bitmap\n     * @memberof Glyph\n     * @instance\n     */\n    Glyph.prototype.bitmap = $util.newBuffer([]);\n\n    /**\n     * Glyph width.\n     * @member {number}width\n     * @memberof Glyph\n     * @instance\n     */\n    Glyph.prototype.width = 0;\n\n    /**\n     * Glyph height.\n     * @member {number}height\n     * @memberof Glyph\n     * @instance\n     */\n    Glyph.prototype.height = 0;\n\n    /**\n     * Glyph bearingX.\n     * @member {number}bearingX\n     * @memberof Glyph\n     * @instance\n     */\n    Glyph.prototype.bearingX = 0;\n\n    /**\n     * Glyph bearingY.\n     * @member {number}bearingY\n     * @memberof Glyph\n     * @instance\n     */\n    Glyph.prototype.bearingY = 0;\n\n    /**\n     * Glyph advance.\n     * @member {number}advance\n     * @memberof Glyph\n     * @instance\n     */\n    Glyph.prototype.advance = 0;\n\n    /**\n     * Decodes a Glyph message from the specified reader or buffer.\n     * @function decode\n     * @memberof Glyph\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Glyph} Glyph\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Glyph.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Glyph();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.id = reader.uint32();\n                break;\n            case 2:\n                message.bitmap = reader.bytes();\n                break;\n            case 3:\n                message.width = reader.uint32();\n                break;\n            case 4:\n                message.height = reader.uint32();\n                break;\n            case 5:\n                message.bearingX = reader.sint32();\n                break;\n            case 6:\n                message.bearingY = reader.sint32();\n                break;\n            case 7:\n                message.advance = reader.uint32();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"id\"))\n            throw $util.ProtocolError(\"missing required 'id'\", { instance: message });\n        if (!message.hasOwnProperty(\"bitmap\"))\n            throw $util.ProtocolError(\"missing required 'bitmap'\", { instance: message });\n        if (!message.hasOwnProperty(\"width\"))\n            throw $util.ProtocolError(\"missing required 'width'\", { instance: message });\n        if (!message.hasOwnProperty(\"height\"))\n            throw $util.ProtocolError(\"missing required 'height'\", { instance: message });\n        if (!message.hasOwnProperty(\"bearingX\"))\n            throw $util.ProtocolError(\"missing required 'bearingX'\", { instance: message });\n        if (!message.hasOwnProperty(\"bearingY\"))\n            throw $util.ProtocolError(\"missing required 'bearingY'\", { instance: message });\n        if (!message.hasOwnProperty(\"advance\"))\n            throw $util.ProtocolError(\"missing required 'advance'\", { instance: message });\n        return message;\n    };\n\n    return Glyph;\n})();\n\n$root.FontDescription = (function() {\n\n    /**\n     * Properties of a FontDescription.\n     * @exports IFontDescription\n     * @interface IFontDescription\n     * @property {string} fontId FontDescription fontId\n     * @property {number} xheight FontDescription xheight\n     * @property {number} margin FontDescription margin\n     */\n\n    /**\n     * Constructs a new FontDescription.\n     * @exports FontDescription\n     * @classdesc Represents a FontDescription.\n     * @constructor\n     * @param {IFontDescription=} [properties] Properties to set\n     */\n    function FontDescription(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * FontDescription fontId.\n     * @member {string}fontId\n     * @memberof FontDescription\n     * @instance\n     */\n    FontDescription.prototype.fontId = \"\";\n\n    /**\n     * FontDescription xheight.\n     * @member {number}xheight\n     * @memberof FontDescription\n     * @instance\n     */\n    FontDescription.prototype.xheight = 0;\n\n    /**\n     * FontDescription margin.\n     * @member {number}margin\n     * @memberof FontDescription\n     * @instance\n     */\n    FontDescription.prototype.margin = 3;\n\n    /**\n     * Decodes a FontDescription message from the specified reader or buffer.\n     * @function decode\n     * @memberof FontDescription\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {FontDescription} FontDescription\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FontDescription.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FontDescription();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.fontId = reader.string();\n                break;\n            case 2:\n                message.xheight = reader.uint32();\n                break;\n            case 3:\n                message.margin = reader.sint32();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"fontId\"))\n            throw $util.ProtocolError(\"missing required 'fontId'\", { instance: message });\n        if (!message.hasOwnProperty(\"xheight\"))\n            throw $util.ProtocolError(\"missing required 'xheight'\", { instance: message });\n        if (!message.hasOwnProperty(\"margin\"))\n            throw $util.ProtocolError(\"missing required 'margin'\", { instance: message });\n        return message;\n    };\n\n    return FontDescription;\n})();\n\n$root.GlyphList = (function() {\n\n    /**\n     * Properties of a GlyphList.\n     * @exports IGlyphList\n     * @interface IGlyphList\n     * @property {FontDescription} font GlyphList font\n     * @property {Array.<Glyph>} [glyphs] GlyphList glyphs\n     */\n\n    /**\n     * Constructs a new GlyphList.\n     * @exports GlyphList\n     * @classdesc Represents a GlyphList.\n     * @constructor\n     * @param {IGlyphList=} [properties] Properties to set\n     */\n    function GlyphList(properties) {\n        this.glyphs = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * GlyphList font.\n     * @member {FontDescription}font\n     * @memberof GlyphList\n     * @instance\n     */\n    GlyphList.prototype.font = null;\n\n    /**\n     * GlyphList glyphs.\n     * @member {Array.<Glyph>}glyphs\n     * @memberof GlyphList\n     * @instance\n     */\n    GlyphList.prototype.glyphs = $util.emptyArray;\n\n    /**\n     * Decodes a GlyphList message from the specified reader or buffer.\n     * @function decode\n     * @memberof GlyphList\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {GlyphList} GlyphList\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    GlyphList.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GlyphList();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.font = $root.FontDescription.decode(reader, reader.uint32());\n                break;\n            case 2:\n                if (!(message.glyphs && message.glyphs.length))\n                    message.glyphs = [];\n                message.glyphs.push($root.Glyph.decode(reader, reader.uint32()));\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"font\"))\n            throw $util.ProtocolError(\"missing required 'font'\", { instance: message });\n        return message;\n    };\n\n    return GlyphList;\n})();\n\n$root.Presentation = (function() {\n\n    /**\n     * Properties of a Presentation.\n     * @exports IPresentation\n     * @interface IPresentation\n     * @property {Array.<Presentation.Class>} [classes] Presentation classes\n     * @property {string} [name] Presentation name\n     */\n\n    /**\n     * Constructs a new Presentation.\n     * @exports Presentation\n     * @classdesc Represents a Presentation.\n     * @constructor\n     * @param {IPresentation=} [properties] Properties to set\n     */\n    function Presentation(properties) {\n        this.classes = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Presentation classes.\n     * @member {Array.<Presentation.Class>}classes\n     * @memberof Presentation\n     * @instance\n     */\n    Presentation.prototype.classes = $util.emptyArray;\n\n    /**\n     * Presentation name.\n     * @member {string}name\n     * @memberof Presentation\n     * @instance\n     */\n    Presentation.prototype.name = \"\";\n\n    /**\n     * Decodes a Presentation message from the specified reader or buffer.\n     * @function decode\n     * @memberof Presentation\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Presentation} Presentation\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Presentation.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.classes && message.classes.length))\n                    message.classes = [];\n                message.classes.push($root.Presentation.Class.decode(reader, reader.uint32()));\n                break;\n            case 2:\n                message.name = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    Presentation.Class = (function() {\n\n        /**\n         * Properties of a Class.\n         * @memberof Presentation\n         * @interface IClass\n         * @property {number} [id] Class id\n         * @property {string} [name] Class name\n         * @property {Array.<Presentation.Class.ZoomSlice>} [slices] Class slices\n         */\n\n        /**\n         * Constructs a new Class.\n         * @memberof Presentation\n         * @classdesc Represents a Class.\n         * @constructor\n         * @param {Presentation.IClass=} [properties] Properties to set\n         */\n        function Class(properties) {\n            this.slices = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Class id.\n         * @member {number}id\n         * @memberof Presentation.Class\n         * @instance\n         */\n        Class.prototype.id = 0;\n\n        /**\n         * Class name.\n         * @member {string}name\n         * @memberof Presentation.Class\n         * @instance\n         */\n        Class.prototype.name = \"\";\n\n        /**\n         * Class slices.\n         * @member {Array.<Presentation.Class.ZoomSlice>}slices\n         * @memberof Presentation.Class\n         * @instance\n         */\n        Class.prototype.slices = $util.emptyArray;\n\n        /**\n         * Decodes a Class message from the specified reader or buffer.\n         * @function decode\n         * @memberof Presentation.Class\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Presentation.Class} Class\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Class.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.uint32();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                case 3:\n                    if (!(message.slices && message.slices.length))\n                        message.slices = [];\n                    message.slices.push($root.Presentation.Class.ZoomSlice.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        Class.ZoomRange = (function() {\n\n            /**\n             * Properties of a ZoomRange.\n             * @memberof Presentation.Class\n             * @interface IZoomRange\n             * @property {number} [min] ZoomRange min\n             * @property {number} [max] ZoomRange max\n             */\n\n            /**\n             * Constructs a new ZoomRange.\n             * @memberof Presentation.Class\n             * @classdesc Represents a ZoomRange.\n             * @constructor\n             * @param {Presentation.Class.IZoomRange=} [properties] Properties to set\n             */\n            function ZoomRange(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * ZoomRange min.\n             * @member {number}min\n             * @memberof Presentation.Class.ZoomRange\n             * @instance\n             */\n            ZoomRange.prototype.min = 0;\n\n            /**\n             * ZoomRange max.\n             * @member {number}max\n             * @memberof Presentation.Class.ZoomRange\n             * @instance\n             */\n            ZoomRange.prototype.max = 0;\n\n            /**\n             * Decodes a ZoomRange message from the specified reader or buffer.\n             * @function decode\n             * @memberof Presentation.Class.ZoomRange\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Presentation.Class.ZoomRange} ZoomRange\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ZoomRange.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.ZoomRange();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.min = reader.sint32();\n                        break;\n                    case 2:\n                        message.max = reader.sint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            return ZoomRange;\n        })();\n\n        Class.Image = (function() {\n\n            /**\n             * Properties of an Image.\n             * @memberof Presentation.Class\n             * @interface IImage\n             * @property {string} [id] Image id\n             * @property {number} [width] Image width\n             */\n\n            /**\n             * Constructs a new Image.\n             * @memberof Presentation.Class\n             * @classdesc Represents an Image.\n             * @constructor\n             * @param {Presentation.Class.IImage=} [properties] Properties to set\n             */\n            function Image(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Image id.\n             * @member {string}id\n             * @memberof Presentation.Class.Image\n             * @instance\n             */\n            Image.prototype.id = \"\";\n\n            /**\n             * Image width.\n             * @member {number}width\n             * @memberof Presentation.Class.Image\n             * @instance\n             */\n            Image.prototype.width = 0;\n\n            /**\n             * Decodes an Image message from the specified reader or buffer.\n             * @function decode\n             * @memberof Presentation.Class.Image\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Presentation.Class.Image} Image\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Image.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.Image();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.id = reader.string();\n                        break;\n                    case 2:\n                        message.width = reader.float();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            return Image;\n        })();\n\n        Class.PointStyle = (function() {\n\n            /**\n             * Properties of a PointStyle.\n             * @memberof Presentation.Class\n             * @interface IPointStyle\n             * @property {Presentation.Class.Image} [icon] PointStyle icon\n             * @property {number} [anchorX] PointStyle anchorX\n             * @property {number} [anchorY] PointStyle anchorY\n             */\n\n            /**\n             * Constructs a new PointStyle.\n             * @memberof Presentation.Class\n             * @classdesc Represents a PointStyle.\n             * @constructor\n             * @param {Presentation.Class.IPointStyle=} [properties] Properties to set\n             */\n            function PointStyle(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * PointStyle icon.\n             * @member {(Presentation.Class.Image|null|undefined)}icon\n             * @memberof Presentation.Class.PointStyle\n             * @instance\n             */\n            PointStyle.prototype.icon = null;\n\n            /**\n             * PointStyle anchorX.\n             * @member {number}anchorX\n             * @memberof Presentation.Class.PointStyle\n             * @instance\n             */\n            PointStyle.prototype.anchorX = 0;\n\n            /**\n             * PointStyle anchorY.\n             * @member {number}anchorY\n             * @memberof Presentation.Class.PointStyle\n             * @instance\n             */\n            PointStyle.prototype.anchorY = 0;\n\n            /**\n             * Decodes a PointStyle message from the specified reader or buffer.\n             * @function decode\n             * @memberof Presentation.Class.PointStyle\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Presentation.Class.PointStyle} PointStyle\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PointStyle.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.PointStyle();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.icon = $root.Presentation.Class.Image.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.anchorX = reader.float();\n                        break;\n                    case 3:\n                        message.anchorY = reader.float();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            return PointStyle;\n        })();\n\n        Class.DashItem = (function() {\n\n            /**\n             * Properties of a DashItem.\n             * @memberof Presentation.Class\n             * @interface IDashItem\n             * @property {number} [fill] DashItem fill\n             * @property {number} [gap] DashItem gap\n             */\n\n            /**\n             * Constructs a new DashItem.\n             * @memberof Presentation.Class\n             * @classdesc Represents a DashItem.\n             * @constructor\n             * @param {Presentation.Class.IDashItem=} [properties] Properties to set\n             */\n            function DashItem(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * DashItem fill.\n             * @member {number}fill\n             * @memberof Presentation.Class.DashItem\n             * @instance\n             */\n            DashItem.prototype.fill = 0;\n\n            /**\n             * DashItem gap.\n             * @member {number}gap\n             * @memberof Presentation.Class.DashItem\n             * @instance\n             */\n            DashItem.prototype.gap = 0;\n\n            /**\n             * Decodes a DashItem message from the specified reader or buffer.\n             * @function decode\n             * @memberof Presentation.Class.DashItem\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Presentation.Class.DashItem} DashItem\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            DashItem.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.DashItem();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.fill = reader.float();\n                        break;\n                    case 2:\n                        message.gap = reader.float();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            return DashItem;\n        })();\n\n        Class.DashStyle = (function() {\n\n            /**\n             * Properties of a DashStyle.\n             * @memberof Presentation.Class\n             * @interface IDashStyle\n             * @property {Array.<Presentation.Class.DashItem>} [dashes] DashStyle dashes\n             */\n\n            /**\n             * Constructs a new DashStyle.\n             * @memberof Presentation.Class\n             * @classdesc Represents a DashStyle.\n             * @constructor\n             * @param {Presentation.Class.IDashStyle=} [properties] Properties to set\n             */\n            function DashStyle(properties) {\n                this.dashes = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * DashStyle dashes.\n             * @member {Array.<Presentation.Class.DashItem>}dashes\n             * @memberof Presentation.Class.DashStyle\n             * @instance\n             */\n            DashStyle.prototype.dashes = $util.emptyArray;\n\n            /**\n             * Decodes a DashStyle message from the specified reader or buffer.\n             * @function decode\n             * @memberof Presentation.Class.DashStyle\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Presentation.Class.DashStyle} DashStyle\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            DashStyle.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.DashStyle();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.dashes && message.dashes.length))\n                            message.dashes = [];\n                        message.dashes.push($root.Presentation.Class.DashItem.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            return DashStyle;\n        })();\n\n        Class.LineStyle = (function() {\n\n            /**\n             * Properties of a LineStyle.\n             * @memberof Presentation.Class\n             * @interface ILineStyle\n             * @property {number} [color] LineStyle color\n             * @property {number} [width] LineStyle width\n             * @property {Presentation.Class.LineStyle.CapStyle} [caps] LineStyle caps\n             * @property {Presentation.Class.LineStyle.JoinStyle} [joins] LineStyle joins\n             * @property {Presentation.Class.DashStyle} [dash] LineStyle dash\n             * @property {Presentation.Class.Image} [pattern] LineStyle pattern\n             */\n\n            /**\n             * Constructs a new LineStyle.\n             * @memberof Presentation.Class\n             * @classdesc Represents a LineStyle.\n             * @constructor\n             * @param {Presentation.Class.ILineStyle=} [properties] Properties to set\n             */\n            function LineStyle(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * LineStyle color.\n             * @member {number}color\n             * @memberof Presentation.Class.LineStyle\n             * @instance\n             */\n            LineStyle.prototype.color = 0;\n\n            /**\n             * LineStyle width.\n             * @member {number}width\n             * @memberof Presentation.Class.LineStyle\n             * @instance\n             */\n            LineStyle.prototype.width = 0;\n\n            /**\n             * LineStyle caps.\n             * @member {Presentation.Class.LineStyle.CapStyle}caps\n             * @memberof Presentation.Class.LineStyle\n             * @instance\n             */\n            LineStyle.prototype.caps = 0;\n\n            /**\n             * LineStyle joins.\n             * @member {Presentation.Class.LineStyle.JoinStyle}joins\n             * @memberof Presentation.Class.LineStyle\n             * @instance\n             */\n            LineStyle.prototype.joins = 0;\n\n            /**\n             * LineStyle dash.\n             * @member {(Presentation.Class.DashStyle|null|undefined)}dash\n             * @memberof Presentation.Class.LineStyle\n             * @instance\n             */\n            LineStyle.prototype.dash = null;\n\n            /**\n             * LineStyle pattern.\n             * @member {(Presentation.Class.Image|null|undefined)}pattern\n             * @memberof Presentation.Class.LineStyle\n             * @instance\n             */\n            LineStyle.prototype.pattern = null;\n\n            /**\n             * Decodes a LineStyle message from the specified reader or buffer.\n             * @function decode\n             * @memberof Presentation.Class.LineStyle\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Presentation.Class.LineStyle} LineStyle\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            LineStyle.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.LineStyle();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.color = reader.fixed32();\n                        break;\n                    case 2:\n                        message.width = reader.float();\n                        break;\n                    case 3:\n                        message.caps = reader.int32();\n                        break;\n                    case 4:\n                        message.joins = reader.int32();\n                        break;\n                    case 5:\n                        message.dash = $root.Presentation.Class.DashStyle.decode(reader, reader.uint32());\n                        break;\n                    case 6:\n                        message.pattern = $root.Presentation.Class.Image.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * CapStyle enum.\n             * @enum {string}\n             * @property {number} CapRound=0 CapRound value\n             * @property {number} CapBevel=1 CapBevel value\n             * @property {number} CapSquare=2 CapSquare value\n             */\n            LineStyle.CapStyle = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"CapRound\"] = 0;\n                values[valuesById[1] = \"CapBevel\"] = 1;\n                values[valuesById[2] = \"CapSquare\"] = 2;\n                return values;\n            })();\n\n            /**\n             * JoinStyle enum.\n             * @enum {string}\n             * @property {number} JoinMiter=0 JoinMiter value\n             * @property {number} JoinRound=1 JoinRound value\n             * @property {number} JoinBevel=2 JoinBevel value\n             */\n            LineStyle.JoinStyle = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"JoinMiter\"] = 0;\n                values[valuesById[1] = \"JoinRound\"] = 1;\n                values[valuesById[2] = \"JoinBevel\"] = 2;\n                return values;\n            })();\n\n            return LineStyle;\n        })();\n\n        Class.PolylineStyle = (function() {\n\n            /**\n             * Properties of a PolylineStyle.\n             * @memberof Presentation.Class\n             * @interface IPolylineStyle\n             * @property {Presentation.Class.LineStyle} [line] PolylineStyle line\n             * @property {Presentation.Class.LineStyle} [outline] PolylineStyle outline\n             */\n\n            /**\n             * Constructs a new PolylineStyle.\n             * @memberof Presentation.Class\n             * @classdesc Represents a PolylineStyle.\n             * @constructor\n             * @param {Presentation.Class.IPolylineStyle=} [properties] Properties to set\n             */\n            function PolylineStyle(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * PolylineStyle line.\n             * @member {(Presentation.Class.LineStyle|null|undefined)}line\n             * @memberof Presentation.Class.PolylineStyle\n             * @instance\n             */\n            PolylineStyle.prototype.line = null;\n\n            /**\n             * PolylineStyle outline.\n             * @member {(Presentation.Class.LineStyle|null|undefined)}outline\n             * @memberof Presentation.Class.PolylineStyle\n             * @instance\n             */\n            PolylineStyle.prototype.outline = null;\n\n            /**\n             * Decodes a PolylineStyle message from the specified reader or buffer.\n             * @function decode\n             * @memberof Presentation.Class.PolylineStyle\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Presentation.Class.PolylineStyle} PolylineStyle\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PolylineStyle.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.PolylineStyle();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.line = $root.Presentation.Class.LineStyle.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.outline = $root.Presentation.Class.LineStyle.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            return PolylineStyle;\n        })();\n\n        Class.PolygonStyle = (function() {\n\n            /**\n             * Properties of a PolygonStyle.\n             * @memberof Presentation.Class\n             * @interface IPolygonStyle\n             * @property {Presentation.Class.Image} [pattern] PolygonStyle pattern\n             * @property {number} [color] PolygonStyle color\n             * @property {Presentation.Class.PolygonStyle.Extrusion} [extrusion] PolygonStyle extrusion\n             * @property {Presentation.Class.LineStyle} [contour] PolygonStyle contour\n             */\n\n            /**\n             * Constructs a new PolygonStyle.\n             * @memberof Presentation.Class\n             * @classdesc Represents a PolygonStyle.\n             * @constructor\n             * @param {Presentation.Class.IPolygonStyle=} [properties] Properties to set\n             */\n            function PolygonStyle(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * PolygonStyle pattern.\n             * @member {(Presentation.Class.Image|null|undefined)}pattern\n             * @memberof Presentation.Class.PolygonStyle\n             * @instance\n             */\n            PolygonStyle.prototype.pattern = null;\n\n            /**\n             * PolygonStyle color.\n             * @member {number}color\n             * @memberof Presentation.Class.PolygonStyle\n             * @instance\n             */\n            PolygonStyle.prototype.color = 0;\n\n            /**\n             * PolygonStyle extrusion.\n             * @member {(Presentation.Class.PolygonStyle.Extrusion|null|undefined)}extrusion\n             * @memberof Presentation.Class.PolygonStyle\n             * @instance\n             */\n            PolygonStyle.prototype.extrusion = null;\n\n            /**\n             * PolygonStyle contour.\n             * @member {(Presentation.Class.LineStyle|null|undefined)}contour\n             * @memberof Presentation.Class.PolygonStyle\n             * @instance\n             */\n            PolygonStyle.prototype.contour = null;\n\n            /**\n             * Decodes a PolygonStyle message from the specified reader or buffer.\n             * @function decode\n             * @memberof Presentation.Class.PolygonStyle\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Presentation.Class.PolygonStyle} PolygonStyle\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PolygonStyle.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.PolygonStyle();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.pattern = $root.Presentation.Class.Image.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.color = reader.fixed32();\n                        break;\n                    case 3:\n                        message.extrusion = $root.Presentation.Class.PolygonStyle.Extrusion.decode(reader, reader.uint32());\n                        break;\n                    case 4:\n                        message.contour = $root.Presentation.Class.LineStyle.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            PolygonStyle.Extrusion = (function() {\n\n                /**\n                 * Properties of an Extrusion.\n                 * @memberof Presentation.Class.PolygonStyle\n                 * @interface IExtrusion\n                 * @property {boolean} [enabled] Extrusion enabled\n                 * @property {number} [height] Extrusion height\n                 */\n\n                /**\n                 * Constructs a new Extrusion.\n                 * @memberof Presentation.Class.PolygonStyle\n                 * @classdesc Represents an Extrusion.\n                 * @constructor\n                 * @param {Presentation.Class.PolygonStyle.IExtrusion=} [properties] Properties to set\n                 */\n                function Extrusion(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Extrusion enabled.\n                 * @member {boolean}enabled\n                 * @memberof Presentation.Class.PolygonStyle.Extrusion\n                 * @instance\n                 */\n                Extrusion.prototype.enabled = false;\n\n                /**\n                 * Extrusion height.\n                 * @member {number}height\n                 * @memberof Presentation.Class.PolygonStyle.Extrusion\n                 * @instance\n                 */\n                Extrusion.prototype.height = 0;\n\n                /**\n                 * Decodes an Extrusion message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof Presentation.Class.PolygonStyle.Extrusion\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {Presentation.Class.PolygonStyle.Extrusion} Extrusion\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Extrusion.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.PolygonStyle.Extrusion();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.enabled = reader.bool();\n                            break;\n                        case 3:\n                            message.height = reader.float();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                return Extrusion;\n            })();\n\n            return PolygonStyle;\n        })();\n\n        Class.TextStyle = (function() {\n\n            /**\n             * Properties of a TextStyle.\n             * @memberof Presentation.Class\n             * @interface ITextStyle\n             * @property {number} [color] TextStyle color\n             * @property {string} [fontId] TextStyle fontId\n             * @property {number} [fontSize] TextStyle fontSize\n             * @property {number} [outlineColor] TextStyle outlineColor\n             */\n\n            /**\n             * Constructs a new TextStyle.\n             * @memberof Presentation.Class\n             * @classdesc Represents a TextStyle.\n             * @constructor\n             * @param {Presentation.Class.ITextStyle=} [properties] Properties to set\n             */\n            function TextStyle(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * TextStyle color.\n             * @member {number}color\n             * @memberof Presentation.Class.TextStyle\n             * @instance\n             */\n            TextStyle.prototype.color = 0;\n\n            /**\n             * TextStyle fontId.\n             * @member {string}fontId\n             * @memberof Presentation.Class.TextStyle\n             * @instance\n             */\n            TextStyle.prototype.fontId = \"\";\n\n            /**\n             * TextStyle fontSize.\n             * @member {number}fontSize\n             * @memberof Presentation.Class.TextStyle\n             * @instance\n             */\n            TextStyle.prototype.fontSize = 0;\n\n            /**\n             * TextStyle outlineColor.\n             * @member {number}outlineColor\n             * @memberof Presentation.Class.TextStyle\n             * @instance\n             */\n            TextStyle.prototype.outlineColor = 0;\n\n            /**\n             * Decodes a TextStyle message from the specified reader or buffer.\n             * @function decode\n             * @memberof Presentation.Class.TextStyle\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Presentation.Class.TextStyle} TextStyle\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            TextStyle.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.TextStyle();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.color = reader.fixed32();\n                        break;\n                    case 2:\n                        message.fontId = reader.string();\n                        break;\n                    case 3:\n                        message.fontSize = reader.float();\n                        break;\n                    case 4:\n                        message.outlineColor = reader.fixed32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            return TextStyle;\n        })();\n\n        Class.LabelStyle = (function() {\n\n            /**\n             * Properties of a LabelStyle.\n             * @memberof Presentation.Class\n             * @interface ILabelStyle\n             * @property {Presentation.Class.TextStyle} [text] LabelStyle text\n             * @property {Presentation.Class.TextStyle} [textAlt] LabelStyle textAlt\n             * @property {number} [hdistance] LabelStyle hdistance\n             * @property {number} [vdistance] LabelStyle vdistance\n             * @property {Presentation.Class.LabelBackgroundStyle} [background] LabelStyle background\n             */\n\n            /**\n             * Constructs a new LabelStyle.\n             * @memberof Presentation.Class\n             * @classdesc Represents a LabelStyle.\n             * @constructor\n             * @param {Presentation.Class.ILabelStyle=} [properties] Properties to set\n             */\n            function LabelStyle(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * LabelStyle text.\n             * @member {(Presentation.Class.TextStyle|null|undefined)}text\n             * @memberof Presentation.Class.LabelStyle\n             * @instance\n             */\n            LabelStyle.prototype.text = null;\n\n            /**\n             * LabelStyle textAlt.\n             * @member {(Presentation.Class.TextStyle|null|undefined)}textAlt\n             * @memberof Presentation.Class.LabelStyle\n             * @instance\n             */\n            LabelStyle.prototype.textAlt = null;\n\n            /**\n             * LabelStyle hdistance.\n             * @member {number}hdistance\n             * @memberof Presentation.Class.LabelStyle\n             * @instance\n             */\n            LabelStyle.prototype.hdistance = 0;\n\n            /**\n             * LabelStyle vdistance.\n             * @member {number}vdistance\n             * @memberof Presentation.Class.LabelStyle\n             * @instance\n             */\n            LabelStyle.prototype.vdistance = 0;\n\n            /**\n             * LabelStyle background.\n             * @member {(Presentation.Class.LabelBackgroundStyle|null|undefined)}background\n             * @memberof Presentation.Class.LabelStyle\n             * @instance\n             */\n            LabelStyle.prototype.background = null;\n\n            /**\n             * Decodes a LabelStyle message from the specified reader or buffer.\n             * @function decode\n             * @memberof Presentation.Class.LabelStyle\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Presentation.Class.LabelStyle} LabelStyle\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            LabelStyle.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.LabelStyle();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.text = $root.Presentation.Class.TextStyle.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.textAlt = $root.Presentation.Class.TextStyle.decode(reader, reader.uint32());\n                        break;\n                    case 3:\n                        message.hdistance = reader.float();\n                        break;\n                    case 4:\n                        message.vdistance = reader.float();\n                        break;\n                    case 5:\n                        message.background = $root.Presentation.Class.LabelBackgroundStyle.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            return LabelStyle;\n        })();\n\n        Class.LabelBackgroundStyle = (function() {\n\n            /**\n             * Properties of a LabelBackgroundStyle.\n             * @memberof Presentation.Class\n             * @interface ILabelBackgroundStyle\n             * @property {number} [hPadding] LabelBackgroundStyle hPadding\n             * @property {number} [vPadding] LabelBackgroundStyle vPadding\n             * @property {number} [color] LabelBackgroundStyle color\n             * @property {Presentation.Class.LineStyle} [outline] LabelBackgroundStyle outline\n             */\n\n            /**\n             * Constructs a new LabelBackgroundStyle.\n             * @memberof Presentation.Class\n             * @classdesc Represents a LabelBackgroundStyle.\n             * @constructor\n             * @param {Presentation.Class.ILabelBackgroundStyle=} [properties] Properties to set\n             */\n            function LabelBackgroundStyle(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * LabelBackgroundStyle hPadding.\n             * @member {number}hPadding\n             * @memberof Presentation.Class.LabelBackgroundStyle\n             * @instance\n             */\n            LabelBackgroundStyle.prototype.hPadding = 0;\n\n            /**\n             * LabelBackgroundStyle vPadding.\n             * @member {number}vPadding\n             * @memberof Presentation.Class.LabelBackgroundStyle\n             * @instance\n             */\n            LabelBackgroundStyle.prototype.vPadding = 0;\n\n            /**\n             * LabelBackgroundStyle color.\n             * @member {number}color\n             * @memberof Presentation.Class.LabelBackgroundStyle\n             * @instance\n             */\n            LabelBackgroundStyle.prototype.color = 0;\n\n            /**\n             * LabelBackgroundStyle outline.\n             * @member {(Presentation.Class.LineStyle|null|undefined)}outline\n             * @memberof Presentation.Class.LabelBackgroundStyle\n             * @instance\n             */\n            LabelBackgroundStyle.prototype.outline = null;\n\n            /**\n             * Decodes a LabelBackgroundStyle message from the specified reader or buffer.\n             * @function decode\n             * @memberof Presentation.Class.LabelBackgroundStyle\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Presentation.Class.LabelBackgroundStyle} LabelBackgroundStyle\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            LabelBackgroundStyle.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.LabelBackgroundStyle();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.hPadding = reader.float();\n                        break;\n                    case 2:\n                        message.vPadding = reader.float();\n                        break;\n                    case 3:\n                        message.color = reader.fixed32();\n                        break;\n                    case 4:\n                        message.outline = $root.Presentation.Class.LineStyle.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            return LabelBackgroundStyle;\n        })();\n\n        Class.ZoomSlice = (function() {\n\n            /**\n             * Properties of a ZoomSlice.\n             * @memberof Presentation.Class\n             * @interface IZoomSlice\n             * @property {number} [zIndex] ZoomSlice zIndex\n             * @property {Presentation.Class.ZoomRange} [visibility] ZoomSlice visibility\n             * @property {Presentation.Class.PolylineStyle} [line] ZoomSlice line\n             * @property {Presentation.Class.PolygonStyle} [poly] ZoomSlice poly\n             * @property {Presentation.Class.PointStyle} [point] ZoomSlice point\n             * @property {Presentation.Class.LabelStyle} [label] ZoomSlice label\n             */\n\n            /**\n             * Constructs a new ZoomSlice.\n             * @memberof Presentation.Class\n             * @classdesc Represents a ZoomSlice.\n             * @constructor\n             * @param {Presentation.Class.IZoomSlice=} [properties] Properties to set\n             */\n            function ZoomSlice(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * ZoomSlice zIndex.\n             * @member {number}zIndex\n             * @memberof Presentation.Class.ZoomSlice\n             * @instance\n             */\n            ZoomSlice.prototype.zIndex = 0;\n\n            /**\n             * ZoomSlice visibility.\n             * @member {(Presentation.Class.ZoomRange|null|undefined)}visibility\n             * @memberof Presentation.Class.ZoomSlice\n             * @instance\n             */\n            ZoomSlice.prototype.visibility = null;\n\n            /**\n             * ZoomSlice line.\n             * @member {(Presentation.Class.PolylineStyle|null|undefined)}line\n             * @memberof Presentation.Class.ZoomSlice\n             * @instance\n             */\n            ZoomSlice.prototype.line = null;\n\n            /**\n             * ZoomSlice poly.\n             * @member {(Presentation.Class.PolygonStyle|null|undefined)}poly\n             * @memberof Presentation.Class.ZoomSlice\n             * @instance\n             */\n            ZoomSlice.prototype.poly = null;\n\n            /**\n             * ZoomSlice point.\n             * @member {(Presentation.Class.PointStyle|null|undefined)}point\n             * @memberof Presentation.Class.ZoomSlice\n             * @instance\n             */\n            ZoomSlice.prototype.point = null;\n\n            /**\n             * ZoomSlice label.\n             * @member {(Presentation.Class.LabelStyle|null|undefined)}label\n             * @memberof Presentation.Class.ZoomSlice\n             * @instance\n             */\n            ZoomSlice.prototype.label = null;\n\n            /**\n             * Decodes a ZoomSlice message from the specified reader or buffer.\n             * @function decode\n             * @memberof Presentation.Class.ZoomSlice\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Presentation.Class.ZoomSlice} ZoomSlice\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ZoomSlice.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presentation.Class.ZoomSlice();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.zIndex = reader.sint32();\n                        break;\n                    case 2:\n                        message.visibility = $root.Presentation.Class.ZoomRange.decode(reader, reader.uint32());\n                        break;\n                    case 3:\n                        message.line = $root.Presentation.Class.PolylineStyle.decode(reader, reader.uint32());\n                        break;\n                    case 4:\n                        message.poly = $root.Presentation.Class.PolygonStyle.decode(reader, reader.uint32());\n                        break;\n                    case 5:\n                        message.point = $root.Presentation.Class.PointStyle.decode(reader, reader.uint32());\n                        break;\n                    case 6:\n                        message.label = $root.Presentation.Class.LabelStyle.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            return ZoomSlice;\n        })();\n\n        return Class;\n    })();\n\n    return Presentation;\n})();\n\nmodule.exports = $root;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = clamp;\n/* unused harmony export cycleRestrict */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = mix;\n/* unused harmony export smoothStep */\n/**\n * Clamps a value to a given range.\n *\n * @param x The value.\n * @param min Start of the range.\n * @param max End of the range.\n * @returns Clamped value.\n */\nfunction clamp(x, min, max) {\n    return min < x ? x < max ? x : max : min;\n}\n/**\n * Restricts a value to a given cycled range, i.e. ends of the range are\n * equivalent. E.g. like angles can be restricted to any range of size `2 * PI`.\n *\n * @param x The value.\n * @param min Start of the range.\n * @param max End of the range.\n * @returns Restricted value.\n */\nfunction cycleRestrict(x, min, max) {\n    const d = max - min;\n    const s = (x - min) / (max - min);\n    return min + d * (s - Math.floor(s));\n}\n/**\n * Linear interpolation.\n *\n * @param min Value that correspond to 0% progress.\n * @param max Value that correspond to 100% progress.\n * @param progress In 0..1.0 range that maps to 0..100% progress. It is allowed to pass a value\n *      outside of this range, that means progress greater then 100% or negative progress.\n */\nfunction mix(min, max, progress) {\n    return (1 - progress) * min + progress * max;\n}\n/**\n * A step function with a smooth transition between given edges. Completely\n * analogous to `smoothstep` in GLSL (GLSL ES 1.0 §8.3).\n *\n * @param edge1 The smaller edge.\n * @param edge2\n * @param x `0` if `x < edge1`, `1` if `x > edge2` and an interpolated value for\n *      `edge1 < x < edge2`.\n */\nfunction smoothStep(edge1, edge2, x) {\n    const factor = clamp((x - edge1) / (edge2 - edge1), 0, 1);\n    return factor * factor * (3 - 2 * factor);\n}\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = swap;\n/* unused harmony export reverse */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = rotate;\n/* unused harmony export copy */\n/* unused harmony export shuffle */\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = zip;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = compare;\n/**\n * Swaps two values in an array.\n *\n * @param array The array.\n * @param i Index of a value to be swapped.\n * @param j Index of a value to be swapped.\n */\nfunction swap(array, i, j) {\n    const t = array[i];\n    array[i] = array[j];\n    array[j] = t;\n}\n/**\n * Reverses order of elements in a range in an array.\n *\n * @param array The array.\n * @param start The start of the range.\n * @param end The end of the range.\n */\nfunction reverse(array, start = 0, end = array.length) {\n    for (let i = start, j = end - 1; i < j; ++i, --j) {\n        swap(array, i, j);\n    }\n}\n/**\n * Rotates a range of elements in an array by given amount.\n *\n * @param array The array.\n * @param amount The amount.\n * @param start The start of the range.\n * @param end The end of the range.\n */\nfunction rotate(array, amount = 1, start = 0, end = array.length) {\n    reverse(array, start, end);\n    reverse(array, start, start + amount);\n    reverse(array, start + amount, end);\n}\n/**\n * Copies a range of elements from a source array to a range in a destination\n * array.\n *\n * @param src The source array.\n * @param dst The destination array.\n * @param srcStart The start of the source range.\n * @param srcStart The start of the source range.\n * @param dstStart The start of the destination range.\n */\nfunction copy(src, dst, srcStart = 0, srcEnd = src.length, dstStart = 0) {\n    for (let i = srcStart, j = dstStart; i < srcEnd; ++i, ++j) {\n        dst[j] = src[i];\n    }\n}\n/**\n * Shuffles randomly a range of elements in an array.\n *\n * @param array The array.\n * @param start The start of the range.\n * @param end The end of the range.\n */\nfunction shuffle(array, start = 0, end = array.length) {\n    for (let i = start, j = i + 1; i < end; ++i, ++j) {\n        swap(array, i, j + (Math.random() * (end - j) | 0));\n    }\n}\nfunction zip(ts, us, zipper = (t, u) => [t, u]) {\n    const l = Math.min(ts.length, us.length);\n    const vs = new Array(l);\n    for (let i = 0; i < l; ++i) {\n        vs[i] = zipper(ts[i], us[i]);\n    }\n    return vs;\n}\n/**\n * Compares two arrays lexicographically. The order is specified be the comparator parameter.\n *\n * @param comparator Elements comparator with standard signature.\n * @param a The first array to compare.\n * @param b The second array to compare.\n * @returns 0 if all elements and lengths are equal,\n *      negative number if the first element is less then the second (lexicographically),\n *      positive number if the first element is greater then the second,\n *      if all the elements are equal the lengths are being compared.\n */\nfunction compare(comparator, a, b) {\n    const length = Math.min(a.length, b.length);\n    for (let i = 0; i < length; i++) {\n        const result = comparator(a[i], b[i]);\n        if (result) {\n            return result;\n        }\n    }\n    return a.length - b.length;\n}\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = areFuzzyEqual;\nconst DEFAULT_TOLERANCE = 1e-6;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = DEFAULT_TOLERANCE;\n\n/**\n * Checks if two floating point number are within a tolerance from each other.\n *\n * @param a The first number.\n * @param b The second number.\n * @param tolerance The tolerance.\n * @returns `true` if the number are within the tolerance and `false` otherwise.\n */\nfunction areFuzzyEqual(a, b, tolerance = DEFAULT_TOLERANCE) {\n    const d = a - b;\n    return -tolerance < d && d < tolerance;\n}\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = dashPolyline;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = splitPolyline;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__fuzzy_equal__ = __webpack_require__(15);\n\n\n\n/**\n * Splits polyline into a set of dashes of specified length and gaps between them.\n *\n * @param polyline Polyline to be dashed\n * @param fill Length of dash.\n * @param gap Interval between dashes.\n */\nfunction* dashPolyline(polyline, fill, gap) {\n    let dash = [];\n    let currentGap = 0; // to manage unclosed gaps (from previous segments)\n    let currentFill = fill; // to manage unclosed fills (from previous segments)\n    for (let i = 1; i < polyline.length; i++) {\n        let current = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"e\" /* copy */](polyline[i - 1]);\n        const segment = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"p\" /* sub */](polyline[i], current);\n        const direction = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"m\" /* normalize */](segment);\n        const directionGap = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"l\" /* muln */](direction, currentGap);\n        // the staring point can be shifted by the previous segment's unclosed gap\n        __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"c\" /* add */](current, directionGap, current);\n        let remainingLength = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"j\" /* length */](segment) - currentGap;\n        // check if we can put the starting point into the remaining segment\n        if (remainingLength > 0 && dash.length == 0) {\n            dash.push(current);\n        }\n        while (remainingLength >= currentFill) {\n            const directionFill = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"l\" /* muln */](direction, currentFill);\n            const directionPeriod = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"l\" /* muln */](direction, currentFill + gap);\n            dash.push(__WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"c\" /* add */](current, directionFill));\n            // the next dash staring point\n            current = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"c\" /* add */](current, directionPeriod);\n            remainingLength -= currentFill + gap;\n            currentFill = fill;\n            yield dash;\n            dash = remainingLength > 0 ? [current] : [];\n        }\n        if (remainingLength > 0) {\n            // continue the dash on the next segment\n            dash.push(polyline[i]);\n            currentGap = 0;\n            currentFill = currentFill - remainingLength;\n            // finish the last segment dash\n            if (i == polyline.length - 1) {\n                yield dash;\n            }\n        }\n        else {\n            // adjust the next segment dash starting point\n            currentGap = Math.abs(remainingLength);\n            currentFill = fill;\n        }\n    }\n}\n/**\n * Spilts a polyline in two parts: two polylines covering the input polyline with a coincident spilt point.\n *\n * @param polyline Polyline to be separated.\n * @param proportion Length of the first part as percentage (0..1) of the length of the polyline.\n * @returns Two polylines.\n */\nfunction splitPolyline(polyline, proportion = 0.5) {\n    const subLengths = new Array(polyline.length);\n    subLengths[0] = 0;\n    for (let i = 1; i < polyline.length; ++i) {\n        subLengths[i] = subLengths[i - 1] + __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"h\" /* distance */](polyline[i - 1], polyline[i]);\n    }\n    const splitLength = proportion * subLengths[polyline.length - 1];\n    const splitIndex = subLengths.findIndex((length) => length >= splitLength) || 1; // \"|| 1\" to handle 0-length case\n    const splitPoint = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"k\" /* mix */](polyline[splitIndex - 1], polyline[splitIndex], \n    // \"|| 1\" to handle 0-length case\n    (splitLength - subLengths[splitIndex - 1]) / ((subLengths[splitIndex] - subLengths[splitIndex - 1]) || 1));\n    const leftPartLength = splitIndex + 1;\n    const leftPart = new Array(leftPartLength);\n    for (let i = 0; i < splitIndex; ++i) {\n        leftPart[i] = polyline[i];\n    }\n    leftPart[splitIndex] = splitPoint;\n    const isSplitExistingPoint = Object(__WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"d\" /* areFuzzyEqual */])(polyline[splitIndex], splitPoint, splitLength * __WEBPACK_IMPORTED_MODULE_1__fuzzy_equal__[\"a\" /* DEFAULT_TOLERANCE */]);\n    const rightPartLength = polyline.length - splitIndex;\n    const rightPart = new Array(rightPartLength + (isSplitExistingPoint ? 0 : 1));\n    let rightPartIndex = 0;\n    // don't include splitPoint if splitting has happened at a polyline's point\n    if (!isSplitExistingPoint) {\n        rightPart[rightPartIndex++] = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"e\" /* copy */](splitPoint);\n    }\n    for (let i = 0; i < rightPartLength; i++) {\n        rightPart[rightPartIndex++] = polyline[splitIndex + i];\n    }\n    return [leftPart, rightPart];\n}\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = triangulate;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_earcut__ = __webpack_require__(73);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_earcut__);\n\n/**\n * Triangulates complex 2D polygons with holes.\n *\n * @param polygon Polygon with holes encoded as a set of rings, with the first ring representing\n *      the outer contour and others - the holes.\n * @returns Triangle indices that correspond to vertices of all the rings as if they\n *      were flattened into a single array.\n */\nfunction triangulate(polygon) {\n    const earcutVertices = [];\n    const earcutHoles = [];\n    let ringCoordsOffset = 0;\n    for (const ring of polygon) {\n        // skip the first ring that is not a hole\n        if (ringCoordsOffset !== 0) {\n            earcutHoles.push(ringCoordsOffset);\n        }\n        for (const vertex of ring) {\n            earcutVertices.push(vertex.x, vertex.y);\n            ringCoordsOffset++;\n        }\n    }\n    return __WEBPACK_IMPORTED_MODULE_0_earcut___default()(earcutVertices, earcutHoles);\n}\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = cyclicNextIndex;\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = cyclicPrevIndex;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = cyclicNext;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = cyclicPrev;\n/* harmony export (immutable) */ __webpack_exports__[\"e\"] = zigZagUnpack;\n/**\n * @returns The next index of specified array or \"0\" if the index points to te last element.\n */\nfunction cyclicNextIndex(list, index) {\n    return (index + 1) % list.length;\n}\n/**\n * @returns The prev index of specified array or \"list.length-1\" if the index points to te first element.\n */\nfunction cyclicPrevIndex(list, index) {\n    return (index || list.length) - 1;\n}\n/**\n * @returns The next to specified by index element or the first element if the index points to te last.\n */\nfunction cyclicNext(list, index) {\n    return list[cyclicNextIndex(list, index)];\n}\n/**\n * @returns The prev to specified by index element or the last element if the index points to te first.\n */\nfunction cyclicPrev(list, index) {\n    return list[cyclicPrevIndex(list, index)];\n}\n/**\n * The same idea as described here https://en.wikipedia.org/wiki/Variable-length_quantity#Zigzag_encoding/.\n *\n * @returns Decoded number.\n */\nfunction zigZagUnpack(v) {\n    return (v >> 1) ^ (-(v & 1));\n}\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// String encode/decode helpers\n\n\n\nvar utils = __webpack_require__(2);\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // use fallback for big arrays to avoid stack overflow\n  if (len < 65537) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__font__ = __webpack_require__(46);\n\nconst UNKNOWN_GLYPH = {\n    id: -1,\n    width: 0,\n    height: 0,\n    bearingX: 0,\n    bearingY: 0,\n    advance: 18\n};\n/**\n * Font whose glyphs are specified in distance field bitmaps. It's \"margin\" metric specifies glyph bitmap inner padding,\n * that is required to fit a \"blurred\" glyph image. This margin should be considered during layouting to draw glyphs of\n * proper sizes.\n */\nclass DfFont extends __WEBPACK_IMPORTED_MODULE_0__font__[\"a\" /* default */] {\n    constructor(id, xheight, margin) {\n        super(id, xheight, UNKNOWN_GLYPH);\n        this.margin = margin;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = DfFont;\n\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nmodule.exports = Writer;\r\n\r\nvar util      = __webpack_require__(4);\r\n\r\nvar BufferWriter; // cyclic\r\n\r\nvar LongBits  = util.LongBits,\r\n    base64    = util.base64,\r\n    utf8      = util.utf8;\r\n\r\n/**\r\n * Constructs a new writer operation instance.\r\n * @classdesc Scheduled writer operation.\r\n * @constructor\r\n * @param {function(*, Uint8Array, number)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {*} val Value to write\r\n * @ignore\r\n */\r\nfunction Op(fn, len, val) {\r\n\r\n    /**\r\n     * Function to call.\r\n     * @type {function(Uint8Array, number, *)}\r\n     */\r\n    this.fn = fn;\r\n\r\n    /**\r\n     * Value byte length.\r\n     * @type {number}\r\n     */\r\n    this.len = len;\r\n\r\n    /**\r\n     * Next operation.\r\n     * @type {Writer.Op|undefined}\r\n     */\r\n    this.next = undefined;\r\n\r\n    /**\r\n     * Value to write.\r\n     * @type {*}\r\n     */\r\n    this.val = val; // type varies\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction noop() {} // eslint-disable-line no-empty-function\r\n\r\n/**\r\n * Constructs a new writer state instance.\r\n * @classdesc Copied writer state.\r\n * @memberof Writer\r\n * @constructor\r\n * @param {Writer} writer Writer to copy state from\r\n * @ignore\r\n */\r\nfunction State(writer) {\r\n\r\n    /**\r\n     * Current head.\r\n     * @type {Writer.Op}\r\n     */\r\n    this.head = writer.head;\r\n\r\n    /**\r\n     * Current tail.\r\n     * @type {Writer.Op}\r\n     */\r\n    this.tail = writer.tail;\r\n\r\n    /**\r\n     * Current buffer length.\r\n     * @type {number}\r\n     */\r\n    this.len = writer.len;\r\n\r\n    /**\r\n     * Next state.\r\n     * @type {State|null}\r\n     */\r\n    this.next = writer.states;\r\n}\r\n\r\n/**\r\n * Constructs a new writer instance.\r\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\r\n * @constructor\r\n */\r\nfunction Writer() {\r\n\r\n    /**\r\n     * Current length.\r\n     * @type {number}\r\n     */\r\n    this.len = 0;\r\n\r\n    /**\r\n     * Operations head.\r\n     * @type {Object}\r\n     */\r\n    this.head = new Op(noop, 0, 0);\r\n\r\n    /**\r\n     * Operations tail\r\n     * @type {Object}\r\n     */\r\n    this.tail = this.head;\r\n\r\n    /**\r\n     * Linked forked states.\r\n     * @type {Object|null}\r\n     */\r\n    this.states = null;\r\n\r\n    // When a value is written, the writer calculates its byte length and puts it into a linked\r\n    // list of operations to perform when finish() is called. This both allows us to allocate\r\n    // buffers of the exact required size and reduces the amount of work we have to do compared\r\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\r\n    // part is just a linked list walk calling operations with already prepared values.\r\n}\r\n\r\n/**\r\n * Creates a new writer.\r\n * @function\r\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\r\n */\r\nWriter.create = util.Buffer\r\n    ? function create_buffer_setup() {\r\n        return (Writer.create = function create_buffer() {\r\n            return new BufferWriter();\r\n        })();\r\n    }\r\n    /* istanbul ignore next */\r\n    : function create_array() {\r\n        return new Writer();\r\n    };\r\n\r\n/**\r\n * Allocates a buffer of the specified size.\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\nWriter.alloc = function alloc(size) {\r\n    return new util.Array(size);\r\n};\r\n\r\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\r\n/* istanbul ignore else */\r\nif (util.Array !== Array)\r\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\r\n\r\n/**\r\n * Pushes a new operation to the queue.\r\n * @param {function(Uint8Array, number, *)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @returns {Writer} `this`\r\n * @private\r\n */\r\nWriter.prototype._push = function push(fn, len, val) {\r\n    this.tail = this.tail.next = new Op(fn, len, val);\r\n    this.len += len;\r\n    return this;\r\n};\r\n\r\nfunction writeByte(val, buf, pos) {\r\n    buf[pos] = val & 255;\r\n}\r\n\r\nfunction writeVarint32(val, buf, pos) {\r\n    while (val > 127) {\r\n        buf[pos++] = val & 127 | 128;\r\n        val >>>= 7;\r\n    }\r\n    buf[pos] = val;\r\n}\r\n\r\n/**\r\n * Constructs a new varint writer operation instance.\r\n * @classdesc Scheduled varint writer operation.\r\n * @extends Op\r\n * @constructor\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @ignore\r\n */\r\nfunction VarintOp(len, val) {\r\n    this.len = len;\r\n    this.next = undefined;\r\n    this.val = val;\r\n}\r\n\r\nVarintOp.prototype = Object.create(Op.prototype);\r\nVarintOp.prototype.fn = writeVarint32;\r\n\r\n/**\r\n * Writes an unsigned 32 bit value as a varint.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.uint32 = function write_uint32(value) {\r\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\r\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\r\n    this.len += (this.tail = this.tail.next = new VarintOp(\r\n        (value = value >>> 0)\r\n                < 128       ? 1\r\n        : value < 16384     ? 2\r\n        : value < 2097152   ? 3\r\n        : value < 268435456 ? 4\r\n        :                     5,\r\n    value)).len;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Writes a signed 32 bit value as a varint.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.int32 = function write_int32(value) {\r\n    return value < 0\r\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\r\n        : this.uint32(value);\r\n};\r\n\r\n/**\r\n * Writes a 32 bit value as a varint, zig-zag encoded.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.sint32 = function write_sint32(value) {\r\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\r\n};\r\n\r\nfunction writeVarint64(val, buf, pos) {\r\n    while (val.hi) {\r\n        buf[pos++] = val.lo & 127 | 128;\r\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\r\n        val.hi >>>= 7;\r\n    }\r\n    while (val.lo > 127) {\r\n        buf[pos++] = val.lo & 127 | 128;\r\n        val.lo = val.lo >>> 7;\r\n    }\r\n    buf[pos++] = val.lo;\r\n}\r\n\r\n/**\r\n * Writes an unsigned 64 bit value as a varint.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.uint64 = function write_uint64(value) {\r\n    var bits = LongBits.from(value);\r\n    return this._push(writeVarint64, bits.length(), bits);\r\n};\r\n\r\n/**\r\n * Writes a signed 64 bit value as a varint.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.int64 = Writer.prototype.uint64;\r\n\r\n/**\r\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.sint64 = function write_sint64(value) {\r\n    var bits = LongBits.from(value).zzEncode();\r\n    return this._push(writeVarint64, bits.length(), bits);\r\n};\r\n\r\n/**\r\n * Writes a boolish value as a varint.\r\n * @param {boolean} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.bool = function write_bool(value) {\r\n    return this._push(writeByte, 1, value ? 1 : 0);\r\n};\r\n\r\nfunction writeFixed32(val, buf, pos) {\r\n    buf[pos    ] =  val         & 255;\r\n    buf[pos + 1] =  val >>> 8   & 255;\r\n    buf[pos + 2] =  val >>> 16  & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\n/**\r\n * Writes an unsigned 32 bit value as fixed 32 bits.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.fixed32 = function write_fixed32(value) {\r\n    return this._push(writeFixed32, 4, value >>> 0);\r\n};\r\n\r\n/**\r\n * Writes a signed 32 bit value as fixed 32 bits.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\r\n\r\n/**\r\n * Writes an unsigned 64 bit value as fixed 64 bits.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.fixed64 = function write_fixed64(value) {\r\n    var bits = LongBits.from(value);\r\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\r\n};\r\n\r\n/**\r\n * Writes a signed 64 bit value as fixed 64 bits.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\r\n\r\n/**\r\n * Writes a float (32 bit).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.float = function write_float(value) {\r\n    return this._push(util.float.writeFloatLE, 4, value);\r\n};\r\n\r\n/**\r\n * Writes a double (64 bit float).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.double = function write_double(value) {\r\n    return this._push(util.float.writeDoubleLE, 8, value);\r\n};\r\n\r\nvar writeBytes = util.Array.prototype.set\r\n    ? function writeBytes_set(val, buf, pos) {\r\n        buf.set(val, pos); // also works for plain array values\r\n    }\r\n    /* istanbul ignore next */\r\n    : function writeBytes_for(val, buf, pos) {\r\n        for (var i = 0; i < val.length; ++i)\r\n            buf[pos + i] = val[i];\r\n    };\r\n\r\n/**\r\n * Writes a sequence of bytes.\r\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.bytes = function write_bytes(value) {\r\n    var len = value.length >>> 0;\r\n    if (!len)\r\n        return this._push(writeByte, 1, 0);\r\n    if (util.isString(value)) {\r\n        var buf = Writer.alloc(len = base64.length(value));\r\n        base64.decode(value, buf, 0);\r\n        value = buf;\r\n    }\r\n    return this.uint32(len)._push(writeBytes, len, value);\r\n};\r\n\r\n/**\r\n * Writes a string.\r\n * @param {string} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.string = function write_string(value) {\r\n    var len = utf8.length(value);\r\n    return len\r\n        ? this.uint32(len)._push(utf8.write, len, value)\r\n        : this._push(writeByte, 1, 0);\r\n};\r\n\r\n/**\r\n * Forks this writer's state by pushing it to a stack.\r\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.fork = function fork() {\r\n    this.states = new State(this);\r\n    this.head = this.tail = new Op(noop, 0, 0);\r\n    this.len = 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Resets this instance to the last state.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.reset = function reset() {\r\n    if (this.states) {\r\n        this.head   = this.states.head;\r\n        this.tail   = this.states.tail;\r\n        this.len    = this.states.len;\r\n        this.states = this.states.next;\r\n    } else {\r\n        this.head = this.tail = new Op(noop, 0, 0);\r\n        this.len  = 0;\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.ldelim = function ldelim() {\r\n    var head = this.head,\r\n        tail = this.tail,\r\n        len  = this.len;\r\n    this.reset().uint32(len);\r\n    if (len) {\r\n        this.tail.next = head.next; // skip noop\r\n        this.tail = tail;\r\n        this.len += len;\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Finishes the write operation.\r\n * @returns {Uint8Array} Finished buffer\r\n */\r\nWriter.prototype.finish = function finish() {\r\n    var head = this.head.next, // skip noop\r\n        buf  = this.constructor.alloc(this.len),\r\n        pos  = 0;\r\n    while (head) {\r\n        head.fn(head.val, buf, pos);\r\n        pos += head.len;\r\n        head = head.next;\r\n    }\r\n    // this.head = this.tail = null;\r\n    return buf;\r\n};\r\n\r\nWriter._configure = function(BufferWriter_) {\r\n    BufferWriter = BufferWriter_;\r\n};\r\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nmodule.exports = Reader;\r\n\r\nvar util      = __webpack_require__(4);\r\n\r\nvar BufferReader; // cyclic\r\n\r\nvar LongBits  = util.LongBits,\r\n    utf8      = util.utf8;\r\n\r\n/* istanbul ignore next */\r\nfunction indexOutOfRange(reader, writeLength) {\r\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\r\n}\r\n\r\n/**\r\n * Constructs a new reader instance using the specified buffer.\r\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\r\n * @constructor\r\n * @param {Uint8Array} buffer Buffer to read from\r\n */\r\nfunction Reader(buffer) {\r\n\r\n    /**\r\n     * Read buffer.\r\n     * @type {Uint8Array}\r\n     */\r\n    this.buf = buffer;\r\n\r\n    /**\r\n     * Read buffer position.\r\n     * @type {number}\r\n     */\r\n    this.pos = 0;\r\n\r\n    /**\r\n     * Read buffer length.\r\n     * @type {number}\r\n     */\r\n    this.len = buffer.length;\r\n}\r\n\r\nvar create_array = typeof Uint8Array !== \"undefined\"\r\n    ? function create_typed_array(buffer) {\r\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\r\n            return new Reader(buffer);\r\n        throw Error(\"illegal buffer\");\r\n    }\r\n    /* istanbul ignore next */\r\n    : function create_array(buffer) {\r\n        if (Array.isArray(buffer))\r\n            return new Reader(buffer);\r\n        throw Error(\"illegal buffer\");\r\n    };\r\n\r\n/**\r\n * Creates a new reader using the specified buffer.\r\n * @function\r\n * @param {Uint8Array|Buffer} buffer Buffer to read from\r\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\r\n * @throws {Error} If `buffer` is not a valid buffer\r\n */\r\nReader.create = util.Buffer\r\n    ? function create_buffer_setup(buffer) {\r\n        return (Reader.create = function create_buffer(buffer) {\r\n            return util.Buffer.isBuffer(buffer)\r\n                ? new BufferReader(buffer)\r\n                /* istanbul ignore next */\r\n                : create_array(buffer);\r\n        })(buffer);\r\n    }\r\n    /* istanbul ignore next */\r\n    : create_array;\r\n\r\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\r\n\r\n/**\r\n * Reads a varint as an unsigned 32 bit value.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.uint32 = (function read_uint32_setup() {\r\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\r\n    return function read_uint32() {\r\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n\r\n        /* istanbul ignore if */\r\n        if ((this.pos += 5) > this.len) {\r\n            this.pos = this.len;\r\n            throw indexOutOfRange(this, 10);\r\n        }\r\n        return value;\r\n    };\r\n})();\r\n\r\n/**\r\n * Reads a varint as a signed 32 bit value.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.int32 = function read_int32() {\r\n    return this.uint32() | 0;\r\n};\r\n\r\n/**\r\n * Reads a zig-zag encoded varint as a signed 32 bit value.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.sint32 = function read_sint32() {\r\n    var value = this.uint32();\r\n    return value >>> 1 ^ -(value & 1) | 0;\r\n};\r\n\r\n/* eslint-disable no-invalid-this */\r\n\r\nfunction readLongVarint() {\r\n    // tends to deopt with local vars for octet etc.\r\n    var bits = new LongBits(0, 0);\r\n    var i = 0;\r\n    if (this.len - this.pos > 4) { // fast route (lo)\r\n        for (; i < 4; ++i) {\r\n            // 1st..4th\r\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n        // 5th\r\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\r\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\r\n        if (this.buf[this.pos++] < 128)\r\n            return bits;\r\n        i = 0;\r\n    } else {\r\n        for (; i < 3; ++i) {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n            // 1st..3th\r\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n        // 4th\r\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\r\n        return bits;\r\n    }\r\n    if (this.len - this.pos > 4) { // fast route (hi)\r\n        for (; i < 5; ++i) {\r\n            // 6th..10th\r\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n    } else {\r\n        for (; i < 5; ++i) {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n            // 6th..10th\r\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n    }\r\n    /* istanbul ignore next */\r\n    throw Error(\"invalid varint encoding\");\r\n}\r\n\r\n/* eslint-enable no-invalid-this */\r\n\r\n/**\r\n * Reads a varint as a signed 64 bit value.\r\n * @name Reader#int64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a varint as an unsigned 64 bit value.\r\n * @name Reader#uint64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a zig-zag encoded varint as a signed 64 bit value.\r\n * @name Reader#sint64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a varint as a boolean.\r\n * @returns {boolean} Value read\r\n */\r\nReader.prototype.bool = function read_bool() {\r\n    return this.uint32() !== 0;\r\n};\r\n\r\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\r\n    return (buf[end - 4]\r\n          | buf[end - 3] << 8\r\n          | buf[end - 2] << 16\r\n          | buf[end - 1] << 24) >>> 0;\r\n}\r\n\r\n/**\r\n * Reads fixed 32 bits as an unsigned 32 bit integer.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.fixed32 = function read_fixed32() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    return readFixed32_end(this.buf, this.pos += 4);\r\n};\r\n\r\n/**\r\n * Reads fixed 32 bits as a signed 32 bit integer.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.sfixed32 = function read_sfixed32() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\r\n};\r\n\r\n/* eslint-disable no-invalid-this */\r\n\r\nfunction readFixed64(/* this: Reader */) {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 8 > this.len)\r\n        throw indexOutOfRange(this, 8);\r\n\r\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\r\n}\r\n\r\n/* eslint-enable no-invalid-this */\r\n\r\n/**\r\n * Reads fixed 64 bits.\r\n * @name Reader#fixed64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads zig-zag encoded fixed 64 bits.\r\n * @name Reader#sfixed64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a float (32 bit) as a number.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.float = function read_float() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    var value = util.float.readFloatLE(this.buf, this.pos);\r\n    this.pos += 4;\r\n    return value;\r\n};\r\n\r\n/**\r\n * Reads a double (64 bit float) as a number.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.double = function read_double() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 8 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    var value = util.float.readDoubleLE(this.buf, this.pos);\r\n    this.pos += 8;\r\n    return value;\r\n};\r\n\r\n/**\r\n * Reads a sequence of bytes preceeded by its length as a varint.\r\n * @returns {Uint8Array} Value read\r\n */\r\nReader.prototype.bytes = function read_bytes() {\r\n    var length = this.uint32(),\r\n        start  = this.pos,\r\n        end    = this.pos + length;\r\n\r\n    /* istanbul ignore if */\r\n    if (end > this.len)\r\n        throw indexOutOfRange(this, length);\r\n\r\n    this.pos += length;\r\n    if (Array.isArray(this.buf)) // plain array\r\n        return this.buf.slice(start, end);\r\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\r\n        ? new this.buf.constructor(0)\r\n        : this._slice.call(this.buf, start, end);\r\n};\r\n\r\n/**\r\n * Reads a string preceeded by its byte length as a varint.\r\n * @returns {string} Value read\r\n */\r\nReader.prototype.string = function read_string() {\r\n    var bytes = this.bytes();\r\n    return utf8.read(bytes, 0, bytes.length);\r\n};\r\n\r\n/**\r\n * Skips the specified number of bytes if specified, otherwise skips a varint.\r\n * @param {number} [length] Length if known, otherwise a varint is assumed\r\n * @returns {Reader} `this`\r\n */\r\nReader.prototype.skip = function skip(length) {\r\n    if (typeof length === \"number\") {\r\n        /* istanbul ignore if */\r\n        if (this.pos + length > this.len)\r\n            throw indexOutOfRange(this, length);\r\n        this.pos += length;\r\n    } else {\r\n        do {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n        } while (this.buf[this.pos++] & 128);\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Skips the next element of the specified wire type.\r\n * @param {number} wireType Wire type received\r\n * @returns {Reader} `this`\r\n */\r\nReader.prototype.skipType = function(wireType) {\r\n    switch (wireType) {\r\n        case 0:\r\n            this.skip();\r\n            break;\r\n        case 1:\r\n            this.skip(8);\r\n            break;\r\n        case 2:\r\n            this.skip(this.uint32());\r\n            break;\r\n        case 3:\r\n            do { // eslint-disable-line no-constant-condition\r\n                if ((wireType = this.uint32() & 7) === 4)\r\n                    break;\r\n                this.skipType(wireType);\r\n            } while (true);\r\n            break;\r\n        case 5:\r\n            this.skip(4);\r\n            break;\r\n\r\n        /* istanbul ignore next */\r\n        default:\r\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\r\n    }\r\n    return this;\r\n};\r\n\r\nReader._configure = function(BufferReader_) {\r\n    BufferReader = BufferReader_;\r\n\r\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\r\n    util.merge(Reader.prototype, {\r\n\r\n        int64: function read_int64() {\r\n            return readLongVarint.call(this)[fn](false);\r\n        },\r\n\r\n        uint64: function read_uint64() {\r\n            return readLongVarint.call(this)[fn](true);\r\n        },\r\n\r\n        sint64: function read_sint64() {\r\n            return readLongVarint.call(this).zzDecode()[fn](false);\r\n        },\r\n\r\n        fixed64: function read_fixed64() {\r\n            return readFixed64.call(this)[fn](true);\r\n        },\r\n\r\n        sfixed64: function read_sfixed64() {\r\n            return readFixed64.call(this)[fn](false);\r\n        }\r\n\r\n    });\r\n};\r\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(5);\n\n\n/**\n * Base class for 3D models buffer writers. It is not supposed to write indices, instead it writes vertices (possibly\n * duplicated) in order that correspond to triangular facets of the mesh.\n */\nclass ModelBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__[\"a\" /* default */] {\n    constructor() {\n        super(ModelBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);\n    }\n    /**\n     * Writes a vertex to the vertex buffer.\n     */\n    _writeVertex(v, colorRgba8) {\n        const vertexIdx = this.getCurrentVertexIdx();\n        this._writeWorldCoordinate(v);\n        this._writeFloat32(v.z);\n        this._writeWord(colorRgba8);\n        return vertexIdx;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ModelBufferWriter;\n\n/**\n * Description of how attributes of vertices are packed into a vertex buffer.\n */\nModelBufferWriter.ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__[\"a\" /* AttributeMapping */]([\n    [\n        0 /* POSITION_HIGH */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        1 /* POSITION_LOW */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        3 /* HEIGHT */,\n        {\n            size: 1,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        7 /* COLOR */,\n        {\n            size: 4,\n            type: 5121 /* UNSIGNED_BYTE */,\n            normalized: true\n        }\n    ]\n]);\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = convertZoomSliceToLabelStyle;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_color__ = __webpack_require__(0);\n\nfunction convertTextStyle(style) {\n    return {\n        color: Object(__WEBPACK_IMPORTED_MODULE_0__util_color__[\"b\" /* decodeAbgr8 */])(style.color),\n        outlineColor: Object(__WEBPACK_IMPORTED_MODULE_0__util_color__[\"b\" /* decodeAbgr8 */])(style.outlineColor),\n        fontId: style.fontId,\n        fontSize: style.fontSize\n    };\n}\n/**\n * Utility method for getting point label specific style details from a zoom slice.\n * To be used as a zoom slice style converter for style extractor.\n */\nfunction convertZoomSliceToLabelStyle(slice, styleBase) {\n    const styles = [];\n    if (slice.label) {\n        if (slice.label.text) {\n            styles.push(convertTextStyle(slice.label.text));\n        }\n        if (slice.label.textAlt) {\n            styles.push(convertTextStyle(slice.label.textAlt));\n        }\n        return Object.assign({}, styleBase, { distance: 0, styles: styles, align: 1 /* CENTER */, background: slice.label.background ?\n                {\n                    color: Object(__WEBPACK_IMPORTED_MODULE_0__util_color__[\"b\" /* decodeAbgr8 */])(slice.label.background.color),\n                    verticalPadding: slice.label.background.vPadding,\n                    horizontalPadding: slice.label.background.hPadding\n                } :\n                undefined });\n    }\n    return undefined;\n}\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nclass CollidingPrimitiveIdManager {\n    /**\n     * @returns Pseudo unique id number from [0x0:0xffff] range, it increments previously returned id and starts from 0\n     *     when the prev one is the max available, that gives acceptable degree of uniqueness for colliding primitives.\n     */\n    static getId() {\n        return this._id = ++this._id % 0xffff;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = CollidingPrimitiveIdManager;\n\nCollidingPrimitiveIdManager._id = 0;\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_pako__ = __webpack_require__(31);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_pako___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_pako__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_worker__ = __webpack_require__(40);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__ = __webpack_require__(42);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__font_df_font_registry__ = __webpack_require__(44);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__font_df_glyph_atlas_allocator__ = __webpack_require__(47);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_http__ = __webpack_require__(49);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__glyph_delivery_manager__ = __webpack_require__(50);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__tile_based_adapter_tile_id__ = __webpack_require__(68);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__util_color__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__parser_extract_points__ = __webpack_require__(69);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__proto__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__proto___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__proto__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__parser_extract_polylines__ = __webpack_require__(71);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__primitive_polygon_polygon_buffer_writer__ = __webpack_require__(72);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__primitive_polygon_textured_polygon_buffer_writer__ = __webpack_require__(76);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__primitive_polyline_polyline_buffer_writer__ = __webpack_require__(78);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__parser_extract_polygons__ = __webpack_require__(81);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__util_extruded_polygon_buffer_writer__ = __webpack_require__(82);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__math_vector2__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__parser_extract_curved_labels__ = __webpack_require__(83);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__parser_extract_point_labels__ = __webpack_require__(84);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__primitive_label_layout_point_label__ = __webpack_require__(85);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__primitive_billboard_rectangle_buffer_writer__ = __webpack_require__(86);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__render_primitive_renderer_colliding_primitive_colliding_primitive_id_manager__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__primitive_label_point_label_buffer_writer__ = __webpack_require__(88);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__primitive_label_curved_label_buffer_writer__ = __webpack_require__(90);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__util_iterable__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__util_label__ = __webpack_require__(93);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__util_trimesh_polygon_buffer_writer__ = __webpack_require__(94);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__render_memory_relative_location__ = __webpack_require__(101);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__util_task_queue__ = __webpack_require__(102);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst BACKGROUND_RADIUS_PX = 2;\nfunction batchPrimitiveDescriptions(primitives) {\n    return Object(__WEBPACK_IMPORTED_MODULE_25__util_iterable__[\"a\" /* mapIterable */])(Object(__WEBPACK_IMPORTED_MODULE_28__render_memory_relative_location__[\"b\" /* batchAllocatedObjects */])(primitives, (primitive) => primitive.bufferLocation, (primitive) => (Object.assign({}, primitive.bufferLocation)), (a, b) => (a.bufferLocation.bufferIndex === b.bufferLocation.bufferIndex)), (bufferLocation) => ({ bufferLocation, styles: [] }));\n}\n/**\n * Batch labels along with their backgrounds. I.e. a label batch must contain batched background locations of those\n * labels in the batch to support LabelPrimitiveDescription interface.\n */\nfunction* batchLabels(labels) {\n    const getLocation = (primitive) => primitive.bufferLocation;\n    const createBatch = (primitive) => {\n        return Object.assign({}, primitive.bufferLocation, { backgroundBatch: primitive.backgroundBufferLocation ? Object.assign({}, primitive.backgroundBufferLocation) : undefined });\n    };\n    const canBatch = (a, b, batch) => {\n        const areLabelsInSameBuffer = a.bufferLocation.bufferIndex === b.bufferLocation.bufferIndex;\n        if (b.backgroundBufferLocation) {\n            // there could be no backgroundBatch if previous labels had no backgrounds,\n            // so background batching starts with the fist label that contains one\n            if (!batch.backgroundBatch) {\n                batch.backgroundBatch = Object.assign({}, b.backgroundBufferLocation);\n            }\n            // label batching breaks if backgrounds can't be batched\n            if (b.backgroundBufferLocation.bufferIndex !== batch.backgroundBatch.bufferIndex ||\n                !areLabelsInSameBuffer ||\n                !Object(__WEBPACK_IMPORTED_MODULE_28__render_memory_relative_location__[\"a\" /* appendToBatch */])(b.backgroundBufferLocation, batch.backgroundBatch)) {\n                return false;\n            }\n        }\n        return areLabelsInSameBuffer;\n    };\n    for (const batch of Object(__WEBPACK_IMPORTED_MODULE_28__render_memory_relative_location__[\"b\" /* batchAllocatedObjects */])(labels, getLocation, createBatch, canBatch)) {\n        const backgroundBufferLocation = batch.backgroundBatch;\n        delete batch.backgroundBatch; // this property is not required in main thread, save some serialization efforts\n        yield {\n            backgroundBufferLocation,\n            bufferLocation: batch,\n            styles: []\n        };\n    }\n}\nconst EMPTY_LABELS_RESPONSE = {\n    type: __WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].LABELS_RESPONSE,\n    tile: { x: 0, y: 0, zoom: 0 },\n    pointLabelPages: [],\n    pointLabelBackgroundPages: [],\n    curvedLabelPages: [],\n    pointLabels: [],\n    curvedLabels: []\n};\n// Tile parsing priority is always non-negative, so to make sure they're processed\n// before anything else, other priorities are less than 0.\nconst MESH_PARSE_PRIORITY = -2;\nclass TileProviderWorker extends __WEBPACK_IMPORTED_MODULE_1__util_worker__[\"a\" /* WebWorkerImplementation */] {\n    constructor(addressee) {\n        super(addressee);\n        this._taskQueue = new __WEBPACK_IMPORTED_MODULE_29__util_task_queue__[\"a\" /* default */]();\n        this._tileUrlTemplate = '';\n        this._fontRegistry = new __WEBPACK_IMPORTED_MODULE_3__font_df_font_registry__[\"a\" /* default */]();\n        this._atlas = new __WEBPACK_IMPORTED_MODULE_4__font_df_glyph_atlas_allocator__[\"a\" /* default */](2048, 2048);\n        this._glyphsDeliveryManager = new __WEBPACK_IMPORTED_MODULE_6__glyph_delivery_manager__[\"a\" /* ApiGlyphsDeliveryManager */](this._fontRegistry, this._atlas);\n        this._tileRequests = new Map();\n        this._meshRequests = new Map();\n        this.on(__WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].INIT, this._onInit.bind(this));\n        this.on(__WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].TILE_REQUEST, this._onTileRequest.bind(this));\n        this.on(__WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].TILE_REQUEST_CANCEL, this._onTileRequestCancel.bind(this));\n        this.on(__WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].MESH_REQUEST, this._onMeshRequest.bind(this));\n        this.on(__WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].MESH_REQUEST_CANCEL, this._onMeshRequestCancel.bind(this));\n        this.setTransferableExtractor(__WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].TILE_RESPONSE, __WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"e\" /* tileTransferableExtractor */]);\n        this.setTransferableExtractor(__WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].GEOMETRY_RESPONSE, __WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"b\" /* geometryTransferableExtractor */]);\n        this.setTransferableExtractor(__WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].MESH_RESPONSE, __WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"d\" /* meshTransferableExtractor */]);\n        this.setTransferableExtractor(__WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].LABELS_RESPONSE, __WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"c\" /* labelTransferableExtractor */]);\n    }\n    _onInit(message) {\n        this._tileUrlTemplate = message.tileUrlTemplate;\n        this._meshUrlTemplate = message.meshUrlTemplate;\n        this._glyphsDeliveryManager.glyphRangeUrlTemplate = message.glyphRangeUrlTemplate;\n    }\n    _onTileRequest(request) {\n        // Request higher priority tiles first\n        request.tiles.sort((a, b) => b.priority - a.priority);\n        for (const tile of request.tiles) {\n            const tileUrl = this._tileUrlTemplate\n                .replace('{{x}}', tile.tile.x.toString())\n                .replace('{{y}}', tile.tile.y.toString())\n                .replace('{{z}}', tile.tile.zoom.toString())\n                .replace('{{zmin}}', tile.tile.zoom.toString())\n                .replace('{{zmax}}', tile.tile.zoom.toString());\n            if (!tileUrl) {\n                return;\n            }\n            const tileId = Object(__WEBPACK_IMPORTED_MODULE_7__tile_based_adapter_tile_id__[\"a\" /* getTileId */])(tile.tile);\n            const tileRequest = new __WEBPACK_IMPORTED_MODULE_5__util_http__[\"a\" /* BinaryHttpRequest */](tileUrl);\n            tileRequest.send().then((buffer) => {\n                this._taskQueue.enqueue({\n                    execute: () => {\n                        // check if tile was not canceled before processing\n                        if (this._tileRequests.has(tileId)) {\n                            const decodedTile = __WEBPACK_IMPORTED_MODULE_10__proto__[\"Tile\"].decode(new Uint8Array(buffer));\n                            const geometryResponse = this._computeGeometryResponse(tile.tile, decodedTile);\n                            this._extractLabels(tile.tile, decodedTile).then((labelsResponse) => {\n                                this.sendMessage(Object.assign({}, (labelsResponse || EMPTY_LABELS_RESPONSE), geometryResponse, { type: __WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].TILE_RESPONSE, tile: tile.tile }));\n                            });\n                            this._tileRequests.delete(tileId);\n                        }\n                    },\n                    priority: tile.priority\n                });\n            }, () => {\n                this._tileRequests.delete(tileId);\n            });\n            this._tileRequests.set(tileId, tileRequest);\n        }\n    }\n    _onTileRequestCancel(message) {\n        const id = Object(__WEBPACK_IMPORTED_MODULE_7__tile_based_adapter_tile_id__[\"a\" /* getTileId */])(message.tile);\n        const tileRequest = this._tileRequests.get(id);\n        if (tileRequest) {\n            tileRequest.cancel();\n            this._tileRequests.delete(id);\n        }\n    }\n    _onMeshRequest(request) {\n        if (!this._meshUrlTemplate) {\n            return;\n        }\n        const mesh = request.mesh;\n        const meshRequest = new __WEBPACK_IMPORTED_MODULE_5__util_http__[\"a\" /* BinaryHttpRequest */](this._meshUrlTemplate.replace('{{id}}', mesh.meshId));\n        this._meshRequests.set(mesh.objectId, meshRequest);\n        meshRequest.send().then((buffer) => {\n            this._taskQueue.enqueue({\n                execute: () => {\n                    // check if mesh was not canceled before processing\n                    if (this._meshRequests.has(mesh.objectId)) {\n                        const writer = new __WEBPACK_IMPORTED_MODULE_27__util_trimesh_polygon_buffer_writer__[\"a\" /* TrimeshPolygonBufferWriter */]();\n                        const location = writer.writeModel(Object(__WEBPACK_IMPORTED_MODULE_0_pako__[\"inflate\"])(new Uint8Array(buffer)).buffer, request.mesh, request.styles[0].color);\n                        this.respond(request, {\n                            type: __WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].MESH_RESPONSE,\n                            pages: writer.getBuffers(),\n                            location\n                        });\n                        this._meshRequests.delete(mesh.objectId);\n                    }\n                },\n                priority: MESH_PARSE_PRIORITY\n            });\n        }, () => {\n            this._meshRequests.delete(mesh.objectId);\n        });\n    }\n    _onMeshRequestCancel(request) {\n        const mesh = request.mesh;\n        const meshRequest = this._meshRequests.get(mesh.objectId);\n        if (meshRequest) {\n            meshRequest.cancel();\n            this._meshRequests.delete(mesh.objectId);\n        }\n    }\n    _computeGeometryResponse(tile, decodedTile) {\n        const minZoom = tile.zoom;\n        const maxZoom = tile.zoom;\n        // Parse polygons from the tile.\n        const worldToPxFactor = 2.0 / (256 * Math.pow(2, tile.zoom));\n        const polygons = [];\n        const transparentPolygons = [];\n        const texturedPolygons = [];\n        const meshes = [];\n        const externalMeshes = [];\n        const polygonWriter = new __WEBPACK_IMPORTED_MODULE_12__primitive_polygon_polygon_buffer_writer__[\"a\" /* default */]();\n        const transparentPolygonWriter = new __WEBPACK_IMPORTED_MODULE_12__primitive_polygon_polygon_buffer_writer__[\"a\" /* default */]();\n        const texturedPolygonWriter = new __WEBPACK_IMPORTED_MODULE_13__primitive_polygon_textured_polygon_buffer_writer__[\"a\" /* default */]();\n        const extrudedPolygonWriter = new __WEBPACK_IMPORTED_MODULE_16__util_extruded_polygon_buffer_writer__[\"a\" /* ExtrudedPolygonBufferWriter */]();\n        for (const polygon of Object(__WEBPACK_IMPORTED_MODULE_15__parser_extract_polygons__[\"a\" /* default */])(tile, decodedTile, minZoom, maxZoom)) {\n            if (polygon.height === 0) {\n                const style = polygon.styles[0];\n                if (style.pattern) {\n                    texturedPolygons.push({\n                        bufferLocation: texturedPolygonWriter.writePolygon(polygon, __WEBPACK_IMPORTED_MODULE_17__math_vector2__[\"a\" /* EMPTY */], style.zIndex),\n                        styles: polygon.styles\n                    });\n                }\n                else if (__WEBPACK_IMPORTED_MODULE_8__util_color__[\"d\" /* isOpaque */](style.color)) {\n                    polygons.push({\n                        bufferLocation: polygonWriter.writePolygon(polygon, style.zIndex, style.color),\n                        styles: polygon.styles\n                    });\n                }\n                else {\n                    transparentPolygons.push({\n                        bufferLocation: transparentPolygonWriter.writePolygon(polygon, style.zIndex, style.color),\n                        styles: polygon.styles\n                    });\n                }\n            }\n            else if (polygon.externalMesh) {\n                externalMeshes.push({\n                    mesh: polygon.externalMesh,\n                    styles: polygon.styles\n                });\n            }\n            else {\n                const style = polygon.styles[0];\n                meshes.push({\n                    bufferLocation: extrudedPolygonWriter.writePolygon(polygon, polygon.height, style.color),\n                    styles: polygon.styles\n                });\n            }\n        }\n        // Parse polylines from the tile.\n        const polylineWriter = new __WEBPACK_IMPORTED_MODULE_14__primitive_polyline_polyline_buffer_writer__[\"a\" /* default */]();\n        const transparentPolylineWriter = new __WEBPACK_IMPORTED_MODULE_14__primitive_polyline_polyline_buffer_writer__[\"a\" /* default */]();\n        const polylines = [];\n        const transparentPolylines = [];\n        const texturedPolylines = [];\n        for (const polyline of Object(__WEBPACK_IMPORTED_MODULE_11__parser_extract_polylines__[\"a\" /* default */])(tile, decodedTile, minZoom, maxZoom)) {\n            const style = polyline.styles[0];\n            if (style.inline && style.inline.pattern) {\n                texturedPolylines.push(polyline);\n            }\n            else if (style.inline && !__WEBPACK_IMPORTED_MODULE_8__util_color__[\"d\" /* isOpaque */](style.inline.strokeColor) ||\n                style.outline && !__WEBPACK_IMPORTED_MODULE_8__util_color__[\"d\" /* isOpaque */](style.outline.strokeColor)) {\n                transparentPolylines.push({\n                    bufferLocation: transparentPolylineWriter.writePolyline(polyline, style.zIndex, worldToPxFactor, style.inline, style.outline),\n                    styles: polyline.styles\n                });\n            }\n            else {\n                polylines.push({\n                    bufferLocation: polylineWriter.writePolyline(polyline, style.zIndex, worldToPxFactor, style.inline, style.outline),\n                    styles: polyline.styles\n                });\n            }\n        }\n        // Parse points from the tile.\n        const points = [...Object(__WEBPACK_IMPORTED_MODULE_9__parser_extract_points__[\"a\" /* default */])(tile, decodedTile, minZoom, maxZoom)];\n        return {\n            type: __WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].GEOMETRY_RESPONSE,\n            tile,\n            polygonPages: polygonWriter.getBuffers(),\n            polygons: [...batchPrimitiveDescriptions(polygons)],\n            transparentPolygonPages: transparentPolygonWriter.getBuffers(),\n            transparentPolygons: [...batchPrimitiveDescriptions(transparentPolygons)],\n            texturedPolygons,\n            texturedPolygonPages: texturedPolygonWriter.getBuffers(),\n            meshPages: extrudedPolygonWriter.getBuffers(),\n            meshes: [...batchPrimitiveDescriptions(meshes)],\n            externalMeshes,\n            polylinePages: polylineWriter.getBuffers(),\n            polylines: [...batchPrimitiveDescriptions(polylines)],\n            transparentPolylinePages: transparentPolylineWriter.getBuffers(),\n            transparentPolylines: [...batchPrimitiveDescriptions(transparentPolylines)],\n            texturedPolylines,\n            points\n        };\n    }\n    _extractLabels(tile, decodedTile) {\n        console.log('_extractLabels', tile);\n        const minZoom = tile.zoom;\n        const maxZoom = tile.zoom;\n        return Promise.all([\n            this._prepareLabels(Object(__WEBPACK_IMPORTED_MODULE_19__parser_extract_point_labels__[\"a\" /* default */])(tile, decodedTile, minZoom, maxZoom)),\n            this._prepareLabels(Object(__WEBPACK_IMPORTED_MODULE_18__parser_extract_curved_labels__[\"a\" /* default */])(tile, decodedTile, minZoom, maxZoom))\n        ]).then(([pointLabels, curvedLabels]) => this._computeLabelsResponse(tile, pointLabels, curvedLabels), (error) => console.log('TODO: _extractLabels respond with error', error));\n    }\n    _prepareLabels(labels) {\n        console.log('_prepareLabels');\n        return Promise.all(Object(__WEBPACK_IMPORTED_MODULE_25__util_iterable__[\"a\" /* mapIterable */])(labels, (label) => {\n            console.log('before _fetchAllGlyphs');\n            // make sure all the glyphs are on hand before forming label GPU data\n            return this._fetchAllGlyphs(label.texts, label.styles).then(() => (label));\n        }));\n    }\n    /**\n     * Fetches all the required by texts glyphs as a single Promise.\n     */\n    _fetchAllGlyphs(texts, styles) {\n        const requests = [];\n        for (const text of texts) {\n            const glyphs = text.textLines.reduce((glyphs, textLine) => {\n                glyphs.push(...textLine.glyphIds);\n                return glyphs;\n            }, []);\n            for (const zoomStyle of styles) {\n                for (const textStyle of zoomStyle.styles) {\n                    requests.push(this._glyphsDeliveryManager.fetchGlyphs(textStyle.fontId, glyphs));\n                }\n            }\n        }\n        return Promise.all(requests);\n    }\n    _computeLabelsResponse(tile, parsedPointLabels = [], parsedCurvedLabels = []) {\n        console.log('_computeLabelsResponse', tile);\n        const pointLabelWriter = new __WEBPACK_IMPORTED_MODULE_23__primitive_label_point_label_buffer_writer__[\"a\" /* default */]();\n        const pointLabelBackgroundWriter = new __WEBPACK_IMPORTED_MODULE_21__primitive_billboard_rectangle_buffer_writer__[\"a\" /* default */]();\n        const pointLabels = Array.from(parsedPointLabels, (label) => {\n            const style = label.styles[0];\n            const layout = Object(__WEBPACK_IMPORTED_MODULE_20__primitive_label_layout_point_label__[\"a\" /* default */])(label, style, this._fontRegistry);\n            const id = __WEBPACK_IMPORTED_MODULE_22__render_primitive_renderer_colliding_primitive_colliding_primitive_id_manager__[\"a\" /* default */].getId();\n            let backgroundBufferLocation;\n            if (style.background) {\n                const bbox = Object(__WEBPACK_IMPORTED_MODULE_26__util_label__[\"a\" /* calculatePointLabelBBox */])(layout, style.background.verticalPadding, style.background.horizontalPadding);\n                backgroundBufferLocation = pointLabelBackgroundWriter.writeRectangle(id, {\n                    position: label.anchorPoint\n                }, {\n                    width: bbox.maxX - bbox.minX,\n                    height: bbox.maxY - bbox.minY,\n                    offset: __WEBPACK_IMPORTED_MODULE_17__math_vector2__[\"f\" /* create */]((bbox.maxX + bbox.minX) / 2, (bbox.maxY + bbox.minY) / 2),\n                    borderRadius: BACKGROUND_RADIUS_PX,\n                    color: style.background.color\n                });\n            }\n            return {\n                backgroundBufferLocation: backgroundBufferLocation,\n                bufferLocation: pointLabelWriter.writePointLabel(id, label, style, layout, this._atlas),\n                styles: label.styles\n            };\n        });\n        const curvedLabelWriter = new __WEBPACK_IMPORTED_MODULE_24__primitive_label_curved_label_buffer_writer__[\"a\" /* default */]();\n        const curvedLabels = Array.from(parsedCurvedLabels, (label) => ({\n            bufferLocation: curvedLabelWriter.writeLabel(label, label.styles[0], this._fontRegistry, this._atlas),\n            styles: label.styles\n        }));\n        const isAtlasDirty = this._atlas.isDirty;\n        this._atlas.isDirty = false;\n        return {\n            type: __WEBPACK_IMPORTED_MODULE_2__tile_provider_worker_messages__[\"a\" /* TileProviderMessageType */].LABELS_RESPONSE,\n            tile,\n            pointLabelPages: pointLabelWriter.getBuffers(),\n            pointLabelBackgroundPages: pointLabelBackgroundWriter.getBuffers(),\n            curvedLabelPages: curvedLabelWriter.getBuffers(),\n            pointLabels: [...batchLabels(pointLabels)],\n            curvedLabels: [...batchPrimitiveDescriptions(curvedLabels)],\n            fontRegistryToUpdate: isAtlasDirty ? this._fontRegistry.getAll().map((font) => {\n                return {\n                    id: font.id,\n                    xheight: font.xheight,\n                    margin: font.margin,\n                    glyphs: font.getAllGlyphs()\n                };\n            }) : undefined,\n            glyphAtlasToUpdate: isAtlasDirty ? {\n                width: this._atlas.width,\n                height: this._atlas.height,\n                glyphLocations: this._atlas.getAllGlyphLocations(),\n                data: this._atlas.data\n            } : undefined\n        };\n    }\n}\nnew TileProviderWorker(self)\n    .run();\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Top level file is just a mixin of submodules & constants\n\n\nvar assign    = __webpack_require__(2).assign;\n\nvar deflate   = __webpack_require__(32);\nvar inflate   = __webpack_require__(35);\nvar constants = __webpack_require__(23);\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\nvar zlib_deflate = __webpack_require__(33);\nvar utils        = __webpack_require__(2);\nvar strings      = __webpack_require__(21);\nvar msg          = __webpack_require__(14);\nvar ZStream      = __webpack_require__(22);\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = __webpack_require__(2);\nvar trees   = __webpack_require__(34);\nvar adler32 = __webpack_require__(19);\nvar crc32   = __webpack_require__(20);\nvar msg     = __webpack_require__(14);\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n                );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(2);\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\nvar zlib_inflate = __webpack_require__(36);\nvar utils        = __webpack_require__(2);\nvar strings      = __webpack_require__(21);\nvar c            = __webpack_require__(23);\nvar msg          = __webpack_require__(14);\nvar ZStream      = __webpack_require__(22);\nvar GZheader     = __webpack_require__(39);\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n  var dict;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      // Convert data if needed\n      if (typeof dictionary === 'string') {\n        dict = strings.string2buf(dictionary);\n      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {\n        dict = new Uint8Array(dictionary);\n      } else {\n        dict = dictionary;\n      }\n\n      status = zlib_inflate.inflateSetDictionary(this.strm, dict);\n\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = __webpack_require__(2);\nvar adler32       = __webpack_require__(19);\nvar crc32         = __webpack_require__(20);\nvar inflate_fast  = __webpack_require__(37);\nvar inflate_table = __webpack_require__(38);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(2);\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export messageIs */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__event_emitter__ = __webpack_require__(41);\n/**\n * Base interface for webworker messages, both incoming and outgoing ones.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Transferable\n */\n\nconst MESSAGE_BATCH_MAX_SIZE = 50;\nconst FLUSH_TIMEOUT = 50;\n// each subsequent message debounces postMessage call, that can lead to infinite delay, this const limits it\nconst MAX_FLUSH_TIMEOUT = 250;\n/**\n * Checks message type with type guarding. It gives a little bit more elegant alternative\n * to tagged type unions providing the same type safety.\n *\n * @param message to be checked\n * @param type the value of the \"type\" property\n * @return {boolean}\n */\nfunction messageIs(message, type) {\n    return message.type === type;\n}\n/**\n * Base class for both sides of a webworker: its implementation (separate js that is run in a worker thread) and\n * a controller for the main thread. They have similar mechanism of sending/receiving messages that is implement here.\n */\nclass WebWorkerCommunicator {\n    constructor(addressee) {\n        this._addressee = addressee;\n        this._events = new __WEBPACK_IMPORTED_MODULE_0__event_emitter__[\"a\" /* EventEmitter */]();\n        this._listeners = new Map();\n        this._transferableExtractors = new Map();\n        this._messages = [];\n        this._transferables = [];\n        this._timeoutHandle = 0;\n        this._flushMessagesBinded = this._flushMessages.bind(this);\n    }\n    setTransferableExtractor(type, extractor) {\n        this._transferableExtractors.set(type, extractor);\n    }\n    /**\n     * Send a message to the opposite side of the web worker communication channel.\n     * Messages are batched by delaying postMessage call to group messages that come during this delay and minimize\n     * the number of interprocess communications that badly affect performance.\n     *\n     * @param message Message to be sent.\n     * @param urgency IMMEDIATE forces message to be sent immediately (synchronous call) with no batching delay,\n     *                DEFAULT debounces sending for another FLUSH_TIMEOUT.\n     */\n    sendMessage(message, urgency = 0 /* DEFAULT */) {\n        const transferableExtractor = this._transferableExtractors.get(message.type);\n        const transferables = transferableExtractor ? transferableExtractor(message) : undefined;\n        const isFirstMessageInBatch = (this._messages.length === 0);\n        if (isFirstMessageInBatch) {\n            this._firstMessageTime = performance.now();\n        }\n        // Send messages asynchronously packing them into one message.\n        // We don't want to abuse the web worker communication channel and\n        // send messages asynchronously in short period of time or many messages synchronously.\n        this._messages.push(message);\n        if (transferables) {\n            this._transferables.concat(transferables);\n        }\n        clearTimeout(this._timeoutHandle);\n        if (this._messages.length > MESSAGE_BATCH_MAX_SIZE ||\n            urgency === 1 /* IMMEDIATE */ ||\n            (!isFirstMessageInBatch && (performance.now() - this._firstMessageTime) > MAX_FLUSH_TIMEOUT)) {\n            this._flushMessages();\n        }\n        else {\n            this._timeoutHandle = setTimeout(this._flushMessagesBinded, FLUSH_TIMEOUT);\n        }\n    }\n    /**\n     * Sends request message to/from worker as promise, the other side can respond and the promise is resolved.\n     * Request/response is synchronized by the requestId field.\n     */\n    request(request, urgency) {\n        return new Promise((resolve) => {\n            request.requestId = (Date.now() << 16) | (0x10000 * Math.random());\n            const listener = (message) => {\n                if (messageIs(message, request.responseType) && message.requestId === request.requestId) {\n                    resolve(message);\n                    this.off(listener);\n                }\n            };\n            this._events.addListener(listener);\n            this.sendMessage(request, urgency);\n        });\n    }\n    /**\n     * Responds to provided request.\n     */\n    respond(request, response, urgency) {\n        response.requestId = request.requestId;\n        this.sendMessage(response, urgency);\n    }\n    /**\n     * Sets a listener to specific type of incoming messages.\n     */\n    on(type, listener) {\n        const typeSafeListener = (message) => {\n            if (messageIs(message, type)) {\n                listener(message);\n            }\n        };\n        this._listeners.set(listener, typeSafeListener);\n        this._events.addListener(typeSafeListener);\n    }\n    /**\n     * Removes incoming messages listener.\n     */\n    off(listener) {\n        const typeSafeListener = this._listeners.get(listener);\n        if (typeSafeListener) {\n            this._events.removeListener(typeSafeListener);\n        }\n    }\n    /**\n     * Starts listening for incoming messages.\n     */\n    listen() {\n        this._addressee.onmessage = ({ data: messages }) => {\n            for (const message of messages) {\n                this.onMessage(message);\n            }\n        };\n    }\n    /**\n     * Handler of incoming messages.\n     */\n    onMessage(message) {\n        this._events.fire(message);\n    }\n    _flushMessages() {\n        this._addressee.postMessage(this._messages, this._transferables);\n        this._messages.length = 0;\n        this._transferables.length = 0;\n    }\n}\n/* unused harmony export WebWorkerCommunicator */\n\n/**\n * Base class for a webworker controller for the main thread code.\n * It also wraps creation of a native Worker.\n */\nclass WebWorkerClient extends WebWorkerCommunicator {\n    /**\n     * @param url URL of webworker's deployed js file\n     */\n    constructor(url) {\n        const worker = new Worker(url);\n        super(worker);\n        this._worker = worker;\n        this.listen();\n    }\n    destroy() {\n        this._worker.terminate();\n    }\n}\n/* unused harmony export WebWorkerClient */\n\n/**\n * Base class for a webworker thread implementation. Concrete class should be the entry point for a webworker js build:\n *     new ConcreteWebWorkerImplementation(<DedicatedWorkerGlobalScope>self).run();\n */\nclass WebWorkerImplementation extends WebWorkerCommunicator {\n    run() {\n        this.listen();\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = WebWorkerImplementation;\n\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Simple pub/sub implementation. The emitter is supposed to emit only one type of event,\n * if someone has to emit events of different types, multiple emitters should be created.\n */\nclass EventEmitter {\n    constructor() {\n        this._listeners = new Set();\n    }\n    /**\n     * Adds listener.\n     */\n    addListener(listener) {\n        this._listeners.add(listener);\n    }\n    /**\n     * Removes listener.\n     */\n    removeListener(listener) {\n        this._listeners.delete(listener);\n    }\n    /**\n     * Calls all the added listeners, the order (e.g. of adding) is not guaranteed.\n     */\n    fire(data) {\n        for (const listener of this._listeners) {\n            listener(data);\n        }\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = EventEmitter;\n\n/**\n * Event emitter with no payload emitted.\n */\nclass VoidEventEmitter extends EventEmitter {\n    fire() {\n        super.fire(undefined);\n    }\n}\n/* unused harmony export VoidEventEmitter */\n\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return TileProviderMessageType; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__ = __webpack_require__(43);\n\nvar TileProviderMessageType;\n(function (TileProviderMessageType) {\n    TileProviderMessageType[TileProviderMessageType[\"INIT\"] = 0] = \"INIT\";\n    TileProviderMessageType[TileProviderMessageType[\"TILE_REQUEST\"] = 1] = \"TILE_REQUEST\";\n    TileProviderMessageType[TileProviderMessageType[\"TILE_REQUEST_CANCEL\"] = 2] = \"TILE_REQUEST_CANCEL\";\n    TileProviderMessageType[TileProviderMessageType[\"TILE_RESPONSE\"] = 3] = \"TILE_RESPONSE\";\n    TileProviderMessageType[TileProviderMessageType[\"GEOMETRY_RESPONSE\"] = 4] = \"GEOMETRY_RESPONSE\";\n    TileProviderMessageType[TileProviderMessageType[\"LABELS_RESPONSE\"] = 5] = \"LABELS_RESPONSE\";\n    TileProviderMessageType[TileProviderMessageType[\"MESH_REQUEST\"] = 6] = \"MESH_REQUEST\";\n    TileProviderMessageType[TileProviderMessageType[\"MESH_REQUEST_CANCEL\"] = 7] = \"MESH_REQUEST_CANCEL\";\n    TileProviderMessageType[TileProviderMessageType[\"MESH_RESPONSE\"] = 8] = \"MESH_RESPONSE\";\n})(TileProviderMessageType || (TileProviderMessageType = {}));\nconst geometryTransferableExtractor = function (message, transferables = []) {\n    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__[\"a\" /* extractTransferables */])(message.polygonPages, transferables);\n    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__[\"a\" /* extractTransferables */])(message.transparentPolygonPages, transferables);\n    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__[\"a\" /* extractTransferables */])(message.texturedPolygonPages, transferables);\n    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__[\"a\" /* extractTransferables */])(message.meshPages, transferables);\n    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__[\"a\" /* extractTransferables */])(message.polylinePages, transferables);\n    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__[\"a\" /* extractTransferables */])(message.transparentPolylinePages, transferables);\n    return transferables;\n};\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = geometryTransferableExtractor;\n\nconst meshTransferableExtractor = function (message) {\n    const transferables = [];\n    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__[\"a\" /* extractTransferables */])(message.pages, transferables);\n    return transferables;\n};\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = meshTransferableExtractor;\n\nconst labelTransferableExtractor = function (message, transferables = []) {\n    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__[\"a\" /* extractTransferables */])(message.pointLabelPages, transferables);\n    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__[\"a\" /* extractTransferables */])(message.pointLabelBackgroundPages, transferables);\n    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__[\"a\" /* extractTransferables */])(message.curvedLabelPages, transferables);\n    return transferables;\n};\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = labelTransferableExtractor;\n\nconst tileTransferableExtractor = function (message) {\n    const transferables = [];\n    geometryTransferableExtractor(message, transferables);\n    labelTransferableExtractor(message, transferables);\n    return transferables;\n};\n/* harmony export (immutable) */ __webpack_exports__[\"e\"] = tileTransferableExtractor;\n\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = extractTransferables;\n/**\n * Extract ArrayBuffers (that are tansferable) from pages.\n */\nfunction extractTransferables(pages, output) {\n    for (const page of pages) {\n        output.push(page.vertexBuffer.buffer, page.indexBuffer.buffer);\n    }\n}\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__font_registry__ = __webpack_require__(45);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__df_font__ = __webpack_require__(24);\n\n\n/**\n * Registry that stores distance field fonts.\n */\nclass DfFontRegistry extends __WEBPACK_IMPORTED_MODULE_0__font_registry__[\"a\" /* default */] {\n    constructor() {\n        super(new __WEBPACK_IMPORTED_MODULE_1__df_font__[\"a\" /* default */]('UNKNOWN_DF_FONT', 14, 0));\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = DfFontRegistry;\n\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * A central storage of all available fonts.\n */\nclass FontRegistry {\n    /**\n     * @param unknownFontInstance An instance of specific font type to be served as a stub when nonexistent font\n     *     is requested. Requesting nonexistent fonts normally should not happen.\n     *     The stub just allows to avoid tedious null checks in registry clients.\n     */\n    constructor(unknownFontInstance) {\n        this._fonts = new Map();\n        this._unknownFontInstance = unknownFontInstance;\n    }\n    /**\n     * @return If a font with specified id is in the registry.\n     */\n    contains(fontId) {\n        return this._fonts.has(fontId);\n    }\n    /**\n     * @return Font with specified id or unknown font instance if it is not found.\n     */\n    get(fontId) {\n        const font = this._fonts.get(fontId);\n        if (font) {\n            return font;\n        }\n        else {\n            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent fonts');\n            return this._unknownFontInstance;\n        }\n    }\n    /**\n     * @return All stored fonts.\n     */\n    getAll() {\n        return [...this._fonts.values()];\n    }\n    /**\n     * Adds new for to the registry.\n     */\n    add(font) {\n        this._fonts.set(font.id, font);\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = FontRegistry;\n\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Font is just a collection of glyph descriptions.\n */\nclass Font {\n    /**\n     * @param id Font id.\n     * @param xheight The height of the \"x\" char in abstract points, in fact is used a the font size.\n     * @param unknownGlyphInstance An instance of glyph to be served as a stub when nonexistent glyph\n     *     is requested. Requesting nonexistent glyphs normally should not happen.\n     *     The stub just allows to avoid tedious null checks in font clients.\n     */\n    constructor(id, xheight, unknownGlyphInstance) {\n        this.id = id;\n        this.xheight = xheight;\n        this._unknownGlyphInstance = unknownGlyphInstance;\n        this._glyphs = new Map();\n    }\n    /**\n     * @return Glyph with specified id or unknown glyph instance.\n     */\n    getGlyph(glyphId) {\n        const glyph = this._glyphs.get(glyphId);\n        if (glyph) {\n            return glyph;\n        }\n        else {\n            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyphs');\n            return this._unknownGlyphInstance;\n        }\n    }\n    /**\n     * @returns All stored glyphs.\n     */\n    getAllGlyphs() {\n        return [...this._glyphs.values()];\n    }\n    /**\n     * Adds glyph description.\n     */\n    addGlyph(glyph) {\n        this._glyphs.set(glyph.id, glyph);\n    }\n    /**\n     * Adds glyph descriptions from the iterable.\n     */\n    addAllGlyphs(glyphs) {\n        for (const glyph of glyphs) {\n            this.addGlyph(glyph);\n        }\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = Font;\n\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__df_glyph_atlas__ = __webpack_require__(48);\n\n/**\n * Glyph bitmap atlas. It manages allocation os separate glyph bitmaps in one big texture.\n */\nclass DfGlyphAtlasAllocator extends __WEBPACK_IMPORTED_MODULE_0__df_glyph_atlas__[\"a\" /* default */] {\n    constructor(width, height) {\n        super(width, height, new Uint8Array(width * height), new Map());\n        this.isDirty = false;\n        this._currentLinePositionX = 0;\n        this._currentLinePositionY = 0;\n        this._currentLineHeight = 0;\n    }\n    /**\n     * Allocates distance field glyph in atlas with specified padding.\n     */\n    allocateGlyph(fontId, glyph, padding) {\n        const width = glyph.width + padding * 2;\n        const height = glyph.height + padding * 2;\n        const maxCurrentLineWidth = this.width - this._currentLinePositionX;\n        const maxCurrentLineHeight = this.height - this._currentLinePositionY;\n        if (width <= maxCurrentLineWidth &&\n            height <= maxCurrentLineHeight) {\n            const location = {\n                minX: this._currentLinePositionX,\n                maxX: this._currentLinePositionX + width,\n                minY: this._currentLinePositionY,\n                maxY: this._currentLinePositionY + height\n            };\n            this._currentLinePositionX += width;\n            this._currentLineHeight = Math.max(this._currentLineHeight, height);\n            this._putGlyphBitmap(fontId, glyph, location);\n            return location;\n        }\n        else {\n            const maxNextLineHeight = this._currentLinePositionY + this._currentLineHeight;\n            if (width <= this.width &&\n                height <= maxNextLineHeight) {\n                this._currentLinePositionX = width;\n                this._currentLinePositionY += this._currentLineHeight;\n                this._currentLineHeight = height;\n                const location = {\n                    minY: this._currentLinePositionY,\n                    maxY: this._currentLinePositionY + height,\n                    minX: 0,\n                    maxX: width\n                };\n                this._putGlyphBitmap(fontId, glyph, location);\n                return location;\n            }\n            else {\n                throw new Error('no room available');\n            }\n        }\n    }\n    /**\n     * Puts glyph's bitmap in specified position.\n     */\n    _putGlyphBitmap(fontId, glyph, location) {\n        for (let atlasY = location.minY, glyphY = 0; atlasY < location.maxY; atlasY++, glyphY++) {\n            const atlasRowOffset = atlasY * this.width;\n            const glyphRowOffset = glyphY * (location.maxX - location.minX);\n            for (let atlasX = location.minX, glyphX = 0; atlasX < location.maxX; atlasX++, glyphX++) {\n                this.data[atlasRowOffset + atlasX] = glyph.bitmap[glyphRowOffset + glyphX];\n            }\n        }\n        this._glyphLocations.set(fontId + glyph.id, location);\n        this.isDirty = true;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = DfGlyphAtlasAllocator;\n\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nconst UNKNOWN_GLYPH_LOCATION = {\n    minX: 0,\n    maxX: 0,\n    minY: 0,\n    maxY: 0\n};\n/**\n * Abstract glyph atlas interface.\n */\nclass DfGlyphAtlas {\n    constructor(width, height, data, glyphLocations) {\n        this.width = width;\n        this.height = height;\n        this.data = data;\n        this._glyphLocations = glyphLocations;\n    }\n    /**\n     * @return Glyph location or fake location pointing to the origin (0, 0).\n     */\n    getGlyphLocation(fontId, glyphId) {\n        const glyphLocation = this._glyphLocations.get(fontId + glyphId);\n        if (glyphLocation) {\n            return glyphLocation;\n        }\n        else {\n            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyph locations');\n            return UNKNOWN_GLYPH_LOCATION;\n        }\n    }\n    /**\n     * @return All glyph locations as [glyph id, glyph location] array. Glyph id is font id concatenated with glyph id.\n     */\n    getAllGlyphLocations() {\n        return [...this._glyphLocations.entries()];\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = DfGlyphAtlas;\n\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Base class for HTTP request wrappers. Its main function is to simplify API for HTTP via reasonable abstraction.\n */\nclass HttpRequest {\n    constructor(url, responseType, method = 'GET') {\n        this._url = url;\n        this._method = method;\n        this._xhr = new XMLHttpRequest();\n        this._xhr.responseType = responseType;\n    }\n    get isCanceled() {\n        return this._xhr.readyState === XMLHttpRequest.DONE && this._xhr.status === 0;\n    }\n    /**\n     * Initiates all the networking activities. Must be called only once.\n     */\n    send() {\n        if (this._xhr.readyState !== XMLHttpRequest.UNSENT) {\n            return Promise.reject(new Error('already sent'));\n        }\n        return new Promise((resolve, reject) => {\n            this._xhr.open(this._method, this._url);\n            this._xhr.onreadystatechange = () => {\n                if (this.isCanceled) {\n                    return;\n                }\n                if (this._xhr.readyState === XMLHttpRequest.DONE) {\n                    if (200 <= this._xhr.status && this._xhr.status < 300) {\n                        resolve(this._prepareResponse(this._xhr.response));\n                    }\n                    else {\n                        reject(new Error(`Failed request: ${this._xhr.status} ${this._xhr.statusText}, ${this._url}`));\n                    }\n                }\n            };\n            this._xhr.send();\n        });\n    }\n    /**\n     * Cancels active request if possible, at least promise callback of the send() methods will not be invoked.\n     */\n    cancel() {\n        if (this._xhr.readyState !== XMLHttpRequest.UNSENT &&\n            !this.isCanceled) {\n            this._xhr.abort();\n        }\n    }\n}\n/**\n * HTTP request that gets its response as an ArrayBuffer.\n */\nclass BinaryHttpRequest extends HttpRequest {\n    constructor(url, method = 'GET') {\n        super(url, 'arraybuffer', method);\n    }\n    _prepareResponse(response) {\n        if (!(response instanceof ArrayBuffer)) {\n            return new ArrayBuffer(0);\n        }\n        return response;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = BinaryHttpRequest;\n\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__proto__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__proto___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__proto__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__font_df_font__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__font_df_glyph_delivery_manager__ = __webpack_require__(67);\n\n\n\n/**\n * Provides glyphs from the API.\n */\nclass ApiGlyphsDeliveryManager extends __WEBPACK_IMPORTED_MODULE_2__font_df_glyph_delivery_manager__[\"a\" /* default */] {\n    constructor(fontRegistry, atlas) {\n        super(fontRegistry, atlas);\n        this.glyphRangeUrlTemplate = '';\n    }\n    _getGlyphRange(fontId, startGlyphId, endGlyphId) {\n        const url = this._getGlyphRangeUrl(fontId, startGlyphId, endGlyphId);\n        if (!url) {\n            return Promise.resolve([]);\n        }\n        return fetch(url)\n            .then((r) => r.arrayBuffer())\n            .then((buffer) => {\n            const response = __WEBPACK_IMPORTED_MODULE_0__proto__[\"GlyphList\"].decode(new Uint8Array(buffer));\n            if (this._fontRegistry.contains(fontId)) {\n                const font = this._fontRegistry.get(fontId);\n                font.xheight = response.font.xheight;\n                font.margin = response.font.margin;\n            }\n            else {\n                this._fontRegistry.add(new __WEBPACK_IMPORTED_MODULE_1__font_df_font__[\"a\" /* default */](fontId, response.font.xheight, response.font.margin));\n            }\n            return response.glyphs;\n        });\n    }\n    _getGlyphRangeUrl(fontId, startGlyphId, endGlyphId) {\n        return this.glyphRangeUrlTemplate\n            .replace('{{fontId}}', fontId)\n            .replace('{{range}}', `${startGlyphId},${endGlyphId}`);\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ApiGlyphsDeliveryManager;\n\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// minimal library entry point.\r\n\r\n\r\nmodule.exports = __webpack_require__(52);\r\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar protobuf = exports;\r\n\r\n/**\r\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\r\n * @name build\r\n * @type {string}\r\n * @const\r\n */\r\nprotobuf.build = \"minimal\";\r\n\r\n// Serialization\r\nprotobuf.Writer       = __webpack_require__(25);\r\nprotobuf.BufferWriter = __webpack_require__(62);\r\nprotobuf.Reader       = __webpack_require__(26);\r\nprotobuf.BufferReader = __webpack_require__(63);\r\n\r\n// Utility\r\nprotobuf.util         = __webpack_require__(4);\r\nprotobuf.rpc          = __webpack_require__(64);\r\nprotobuf.roots        = __webpack_require__(66);\r\nprotobuf.configure    = configure;\r\n\r\n/* istanbul ignore next */\r\n/**\r\n * Reconfigures the library according to the environment.\r\n * @returns {undefined}\r\n */\r\nfunction configure() {\r\n    protobuf.Reader._configure(protobuf.BufferReader);\r\n    protobuf.util._configure();\r\n}\r\n\r\n// Configure serialization\r\nprotobuf.Writer._configure(protobuf.BufferWriter);\r\nconfigure();\r\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === \"object\")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nmodule.exports = LongBits;\r\n\r\nvar util = __webpack_require__(4);\r\n\r\n/**\r\n * Constructs new long bits.\r\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\r\n * @memberof util\r\n * @constructor\r\n * @param {number} lo Low 32 bits, unsigned\r\n * @param {number} hi High 32 bits, unsigned\r\n */\r\nfunction LongBits(lo, hi) {\r\n\r\n    // note that the casts below are theoretically unnecessary as of today, but older statically\r\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\r\n\r\n    /**\r\n     * Low bits.\r\n     * @type {number}\r\n     */\r\n    this.lo = lo >>> 0;\r\n\r\n    /**\r\n     * High bits.\r\n     * @type {number}\r\n     */\r\n    this.hi = hi >>> 0;\r\n}\r\n\r\n/**\r\n * Zero bits.\r\n * @memberof util.LongBits\r\n * @type {util.LongBits}\r\n */\r\nvar zero = LongBits.zero = new LongBits(0, 0);\r\n\r\nzero.toNumber = function() { return 0; };\r\nzero.zzEncode = zero.zzDecode = function() { return this; };\r\nzero.length = function() { return 1; };\r\n\r\n/**\r\n * Zero hash.\r\n * @memberof util.LongBits\r\n * @type {string}\r\n */\r\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\r\n\r\n/**\r\n * Constructs new long bits from the specified number.\r\n * @param {number} value Value\r\n * @returns {util.LongBits} Instance\r\n */\r\nLongBits.fromNumber = function fromNumber(value) {\r\n    if (value === 0)\r\n        return zero;\r\n    var sign = value < 0;\r\n    if (sign)\r\n        value = -value;\r\n    var lo = value >>> 0,\r\n        hi = (value - lo) / 4294967296 >>> 0;\r\n    if (sign) {\r\n        hi = ~hi >>> 0;\r\n        lo = ~lo >>> 0;\r\n        if (++lo > 4294967295) {\r\n            lo = 0;\r\n            if (++hi > 4294967295)\r\n                hi = 0;\r\n        }\r\n    }\r\n    return new LongBits(lo, hi);\r\n};\r\n\r\n/**\r\n * Constructs new long bits from a number, long or string.\r\n * @param {Long|number|string} value Value\r\n * @returns {util.LongBits} Instance\r\n */\r\nLongBits.from = function from(value) {\r\n    if (typeof value === \"number\")\r\n        return LongBits.fromNumber(value);\r\n    if (util.isString(value)) {\r\n        /* istanbul ignore else */\r\n        if (util.Long)\r\n            value = util.Long.fromString(value);\r\n        else\r\n            return LongBits.fromNumber(parseInt(value, 10));\r\n    }\r\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\r\n};\r\n\r\n/**\r\n * Converts this long bits to a possibly unsafe JavaScript number.\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {number} Possibly unsafe number\r\n */\r\nLongBits.prototype.toNumber = function toNumber(unsigned) {\r\n    if (!unsigned && this.hi >>> 31) {\r\n        var lo = ~this.lo + 1 >>> 0,\r\n            hi = ~this.hi     >>> 0;\r\n        if (!lo)\r\n            hi = hi + 1 >>> 0;\r\n        return -(lo + hi * 4294967296);\r\n    }\r\n    return this.lo + this.hi * 4294967296;\r\n};\r\n\r\n/**\r\n * Converts this long bits to a long.\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {Long} Long\r\n */\r\nLongBits.prototype.toLong = function toLong(unsigned) {\r\n    return util.Long\r\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\r\n        /* istanbul ignore next */\r\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\r\n};\r\n\r\nvar charCodeAt = String.prototype.charCodeAt;\r\n\r\n/**\r\n * Constructs new long bits from the specified 8 characters long hash.\r\n * @param {string} hash Hash\r\n * @returns {util.LongBits} Bits\r\n */\r\nLongBits.fromHash = function fromHash(hash) {\r\n    if (hash === zeroHash)\r\n        return zero;\r\n    return new LongBits(\r\n        ( charCodeAt.call(hash, 0)\r\n        | charCodeAt.call(hash, 1) << 8\r\n        | charCodeAt.call(hash, 2) << 16\r\n        | charCodeAt.call(hash, 3) << 24) >>> 0\r\n    ,\r\n        ( charCodeAt.call(hash, 4)\r\n        | charCodeAt.call(hash, 5) << 8\r\n        | charCodeAt.call(hash, 6) << 16\r\n        | charCodeAt.call(hash, 7) << 24) >>> 0\r\n    );\r\n};\r\n\r\n/**\r\n * Converts this long bits to a 8 characters long hash.\r\n * @returns {string} Hash\r\n */\r\nLongBits.prototype.toHash = function toHash() {\r\n    return String.fromCharCode(\r\n        this.lo        & 255,\r\n        this.lo >>> 8  & 255,\r\n        this.lo >>> 16 & 255,\r\n        this.lo >>> 24      ,\r\n        this.hi        & 255,\r\n        this.hi >>> 8  & 255,\r\n        this.hi >>> 16 & 255,\r\n        this.hi >>> 24\r\n    );\r\n};\r\n\r\n/**\r\n * Zig-zag encodes this long bits.\r\n * @returns {util.LongBits} `this`\r\n */\r\nLongBits.prototype.zzEncode = function zzEncode() {\r\n    var mask =   this.hi >> 31;\r\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\r\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Zig-zag decodes this long bits.\r\n * @returns {util.LongBits} `this`\r\n */\r\nLongBits.prototype.zzDecode = function zzDecode() {\r\n    var mask = -(this.lo & 1);\r\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\r\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Calculates the length of this longbits when encoded as a varint.\r\n * @returns {number} Length\r\n */\r\nLongBits.prototype.length = function length() {\r\n    var part0 =  this.lo,\r\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\r\n        part2 =  this.hi >>> 24;\r\n    return part2 === 0\r\n         ? part1 === 0\r\n           ? part0 < 16384\r\n             ? part0 < 128 ? 1 : 2\r\n             : part0 < 2097152 ? 3 : 4\r\n           : part1 < 16384\r\n             ? part1 < 128 ? 5 : 6\r\n             : part1 < 2097152 ? 7 : 8\r\n         : part2 < 128 ? 9 : 10;\r\n};\r\n\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nmodule.exports = BufferWriter;\r\n\r\n// extends Writer\r\nvar Writer = __webpack_require__(25);\r\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\r\n\r\nvar util = __webpack_require__(4);\r\n\r\nvar Buffer = util.Buffer;\r\n\r\n/**\r\n * Constructs a new buffer writer instance.\r\n * @classdesc Wire format writer using node buffers.\r\n * @extends Writer\r\n * @constructor\r\n */\r\nfunction BufferWriter() {\r\n    Writer.call(this);\r\n}\r\n\r\n/**\r\n * Allocates a buffer of the specified size.\r\n * @param {number} size Buffer size\r\n * @returns {Buffer} Buffer\r\n */\r\nBufferWriter.alloc = function alloc_buffer(size) {\r\n    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);\r\n};\r\n\r\nvar writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === \"set\"\r\n    ? function writeBytesBuffer_set(val, buf, pos) {\r\n        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\r\n                           // also works for plain array values\r\n    }\r\n    /* istanbul ignore next */\r\n    : function writeBytesBuffer_copy(val, buf, pos) {\r\n        if (val.copy) // Buffer values\r\n            val.copy(buf, pos, 0, val.length);\r\n        else for (var i = 0; i < val.length;) // plain array values\r\n            buf[pos++] = val[i++];\r\n    };\r\n\r\n/**\r\n * @override\r\n */\r\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\r\n    if (util.isString(value))\r\n        value = util._Buffer_from(value, \"base64\");\r\n    var len = value.length >>> 0;\r\n    this.uint32(len);\r\n    if (len)\r\n        this._push(writeBytesBuffer, len, value);\r\n    return this;\r\n};\r\n\r\nfunction writeStringBuffer(val, buf, pos) {\r\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\r\n        util.utf8.write(val, buf, pos);\r\n    else\r\n        buf.utf8Write(val, pos);\r\n}\r\n\r\n/**\r\n * @override\r\n */\r\nBufferWriter.prototype.string = function write_string_buffer(value) {\r\n    var len = Buffer.byteLength(value);\r\n    this.uint32(len);\r\n    if (len)\r\n        this._push(writeStringBuffer, len, value);\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Finishes the write operation.\r\n * @name BufferWriter#finish\r\n * @function\r\n * @returns {Buffer} Finished buffer\r\n */\r\n\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nmodule.exports = BufferReader;\r\n\r\n// extends Reader\r\nvar Reader = __webpack_require__(26);\r\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\r\n\r\nvar util = __webpack_require__(4);\r\n\r\n/**\r\n * Constructs a new buffer reader instance.\r\n * @classdesc Wire format reader using node buffers.\r\n * @extends Reader\r\n * @constructor\r\n * @param {Buffer} buffer Buffer to read from\r\n */\r\nfunction BufferReader(buffer) {\r\n    Reader.call(this, buffer);\r\n\r\n    /**\r\n     * Read buffer.\r\n     * @name BufferReader#buf\r\n     * @type {Buffer}\r\n     */\r\n}\r\n\r\n/* istanbul ignore else */\r\nif (util.Buffer)\r\n    BufferReader.prototype._slice = util.Buffer.prototype.slice;\r\n\r\n/**\r\n * @override\r\n */\r\nBufferReader.prototype.string = function read_string_buffer() {\r\n    var len = this.uint32(); // modifies pos\r\n    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));\r\n};\r\n\r\n/**\r\n * Reads a sequence of bytes preceeded by its length as a varint.\r\n * @name BufferReader#bytes\r\n * @function\r\n * @returns {Buffer} Value read\r\n */\r\n\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\n/**\r\n * Streaming RPC helpers.\r\n * @namespace\r\n */\r\nvar rpc = exports;\r\n\r\n/**\r\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\r\n * @typedef RPCImpl\r\n * @type {function}\r\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\r\n * @param {Uint8Array} requestData Request data\r\n * @param {RPCImplCallback} callback Callback function\r\n * @returns {undefined}\r\n * @example\r\n * function rpcImpl(method, requestData, callback) {\r\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\r\n *         throw Error(\"no such method\");\r\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\r\n *         callback(err, responseData);\r\n *     });\r\n * }\r\n */\r\n\r\n/**\r\n * Node-style callback as used by {@link RPCImpl}.\r\n * @typedef RPCImplCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any, otherwise `null`\r\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\r\n * @returns {undefined}\r\n */\r\n\r\nrpc.Service = __webpack_require__(65);\r\n\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nmodule.exports = Service;\r\n\r\nvar util = __webpack_require__(4);\r\n\r\n// Extends EventEmitter\r\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\r\n\r\n/**\r\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\r\n *\r\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\r\n * @typedef rpc.ServiceMethodCallback\r\n * @template TRes extends Message<TRes>\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {TRes} [response] Response message\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\r\n * @typedef rpc.ServiceMethod\r\n * @template TReq extends Message<TReq>\r\n * @template TRes extends Message<TRes>\r\n * @type {function}\r\n * @param {TReq|Properties<TReq>} request Request message or plain object\r\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\r\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\r\n */\r\n\r\n/**\r\n * Constructs a new RPC service instance.\r\n * @classdesc An RPC service as returned by {@link Service#create}.\r\n * @exports rpc.Service\r\n * @extends util.EventEmitter\r\n * @constructor\r\n * @param {RPCImpl} rpcImpl RPC implementation\r\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\r\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\r\n */\r\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\r\n\r\n    if (typeof rpcImpl !== \"function\")\r\n        throw TypeError(\"rpcImpl must be a function\");\r\n\r\n    util.EventEmitter.call(this);\r\n\r\n    /**\r\n     * RPC implementation. Becomes `null` once the service is ended.\r\n     * @type {RPCImpl|null}\r\n     */\r\n    this.rpcImpl = rpcImpl;\r\n\r\n    /**\r\n     * Whether requests are length-delimited.\r\n     * @type {boolean}\r\n     */\r\n    this.requestDelimited = Boolean(requestDelimited);\r\n\r\n    /**\r\n     * Whether responses are length-delimited.\r\n     * @type {boolean}\r\n     */\r\n    this.responseDelimited = Boolean(responseDelimited);\r\n}\r\n\r\n/**\r\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\r\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\r\n * @param {Constructor<TReq>} requestCtor Request constructor\r\n * @param {Constructor<TRes>} responseCtor Response constructor\r\n * @param {TReq|Properties<TReq>} request Request message or plain object\r\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\r\n * @returns {undefined}\r\n * @template TReq extends Message<TReq>\r\n * @template TRes extends Message<TRes>\r\n */\r\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\r\n\r\n    if (!request)\r\n        throw TypeError(\"request must be specified\");\r\n\r\n    var self = this;\r\n    if (!callback)\r\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\r\n\r\n    if (!self.rpcImpl) {\r\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\r\n        return undefined;\r\n    }\r\n\r\n    try {\r\n        return self.rpcImpl(\r\n            method,\r\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\r\n            function rpcCallback(err, response) {\r\n\r\n                if (err) {\r\n                    self.emit(\"error\", err, method);\r\n                    return callback(err);\r\n                }\r\n\r\n                if (response === null) {\r\n                    self.end(/* endedByRPC */ true);\r\n                    return undefined;\r\n                }\r\n\r\n                if (!(response instanceof responseCtor)) {\r\n                    try {\r\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\r\n                    } catch (err) {\r\n                        self.emit(\"error\", err, method);\r\n                        return callback(err);\r\n                    }\r\n                }\r\n\r\n                self.emit(\"data\", response, method);\r\n                return callback(null, response);\r\n            }\r\n        );\r\n    } catch (err) {\r\n        self.emit(\"error\", err, method);\r\n        setTimeout(function() { callback(err); }, 0);\r\n        return undefined;\r\n    }\r\n};\r\n\r\n/**\r\n * Ends this service and emits the `end` event.\r\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\r\n * @returns {rpc.Service} `this`\r\n */\r\nService.prototype.end = function end(endedByRPC) {\r\n    if (this.rpcImpl) {\r\n        if (!endedByRPC) // signal end to rpcImpl\r\n            this.rpcImpl(null, null, null);\r\n        this.rpcImpl = null;\r\n        this.emit(\"end\").off();\r\n    }\r\n    return this;\r\n};\r\n\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nmodule.exports = {};\r\n\r\n/**\r\n * Named roots.\r\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\r\n * Can also be used manually to make roots available accross modules.\r\n * @name roots\r\n * @type {Object.<string,Root>}\r\n * @example\r\n * // pbjs -r myroot -o compiled.js ...\r\n *\r\n * // in another module:\r\n * require(\"./compiled.js\");\r\n *\r\n * // in any subsequent module:\r\n * var root = protobuf.roots[\"myroot\"];\r\n */\r\n\n\n/***/ }),\n/* 67 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Magic number, kind of optimal value in \"number of calls/size of call\" dilemma.\n */\nconst RANGE_LENGTH = 256;\n/**\n * This class is responsible for enriching font and the atlas by new glyphs. The glyph source is abstracted and\n * should be specified in concrete descendants by implementing _getGlyphRange(), more likely it will be an http call.\n */\nclass DfGlyphDeliveryManager {\n    constructor(fontRegistry, atlas) {\n        this._fontRegistry = fontRegistry;\n        this._atlas = atlas;\n        this._rangeRequests = new Map();\n    }\n    /**\n     * Requests glyphs via provider and stores them. Glyphs are requested by ranges, that is kind of an optimisation,\n     * as it is more likely that subsequent glyph requests will be in those ranges too.\n     */\n    fetchGlyphs(fontId, glyphIds) {\n        const requests = new Set();\n        for (const glyphId of glyphIds) {\n            const range = glyphId - glyphId % RANGE_LENGTH;\n            const fullRangeName = fontId + range;\n            let request = this._rangeRequests.get(fullRangeName);\n            if (!request) {\n                request = this._getGlyphRange(fontId, range, range + RANGE_LENGTH - 1);\n                request.then(this._onNewRange.bind(this, fontId));\n                this._rangeRequests.set(fullRangeName, request);\n            }\n            requests.add(request);\n        }\n        return Promise.all(requests);\n    }\n    /**\n     * Handles incoming glyph range response. It adds new glyphs to font and atlas.\n     */\n    _onNewRange(fontId, glyphs) {\n        for (const glyph of glyphs) {\n            const font = this._fontRegistry.get(fontId);\n            font.addGlyph(glyph);\n            this._atlas.allocateGlyph(fontId, glyph, font.margin);\n        }\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = DfGlyphDeliveryManager;\n\n\n\n/***/ }),\n/* 68 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export getTileIdByRawValues */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getTileId;\nfunction getTileIdByRawValues(x, y, zoom) {\n    return `${x}:${y}:${zoom}`;\n}\nfunction getTileId(tile) {\n    return getTileIdByRawValues(tile.x, tile.y, tile.zoom);\n}\n\n\n/***/ }),\n/* 69 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = extractPoints;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tile_world_coordinates_converter__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector2__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extract_styles__ = __webpack_require__(8);\n\n\n\n/**\n * Utility method for getting point specific style details from a zoom slice.\n * To be used as a zoom slice style converter for style extractor.\n */\nfunction convertZoomSliceToStyle(slice, styleBase) {\n    const style = slice.point;\n    return style && style.icon ? Object.assign({}, styleBase, { imageId: style.icon.id, offset: __WEBPACK_IMPORTED_MODULE_1__math_vector2__[\"f\" /* create */](-style.anchorX * style.icon.width, -style.anchorY * style.icon.width), width: style.icon.width }) :\n        undefined;\n}\n/**\n * Utility method for getting points from API tile response.\n */\nfunction* extractPoints(tile, decodedApiTile, tileMinZoom, tileMaxZoom) {\n    const points = decodedApiTile.points;\n    if (points) {\n        const converter = new __WEBPACK_IMPORTED_MODULE_0__tile_world_coordinates_converter__[\"a\" /* default */](tile);\n        for (let i = 0; i < points.classId.length; i++) {\n            yield {\n                position: converter.toWorldCoordinates(points.coordsx[i], points.coordsy[i]),\n                styles: [...Object(__WEBPACK_IMPORTED_MODULE_2__extract_styles__[\"a\" /* default */])(decodedApiTile.presentation, points.classId[i], convertZoomSliceToStyle, tileMinZoom, tileMaxZoom)]\n            };\n        }\n    }\n}\n\n\n/***/ }),\n/* 70 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export isParent */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_scalar__ = __webpack_require__(12);\n\n/**\n * @return `true` if the first param overlaps the second in tile hierarchy.\n */\nfunction isParent(potentialParent, possibleChild) {\n    const zoomDiff = possibleChild.zoom - potentialParent.zoom;\n    return zoomDiff > 0 &&\n        possibleChild.x >> zoomDiff == potentialParent.x &&\n        possibleChild.y >> zoomDiff == potentialParent.y;\n}\nclass TileCoordinateSystem {\n    constructor(zoom) {\n        this._zoom = Math.ceil(Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__[\"a\" /* clamp */])(zoom, 0, 31));\n        this._tileSize = 2 / (1 << this._zoom);\n    }\n    getZoom() {\n        return this._zoom;\n    }\n    /**\n     * @return Tile side length in units of the world coordinate system.\n     */\n    getTileSize() {\n        return this._tileSize;\n    }\n    /**\n     * @return Top left corner coordinates of the tile.\n     */\n    getTileOffset(tile) {\n        return {\n            x: this.getTileSize() * tile.x - 1,\n            y: 1 - this.getTileSize() * tile.y\n        };\n    }\n    toTileCoordinates(worldCoordinates) {\n        return {\n            x: (worldCoordinates.x + 1) / this._tileSize,\n            y: (1 - worldCoordinates.y) / this._tileSize\n        };\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = TileCoordinateSystem;\n\n\n\n/***/ }),\n/* 71 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = extractPolylines;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tile_world_coordinates_converter__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extract_styles__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__proto__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__proto___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__proto__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_color__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_polyline__ = __webpack_require__(16);\n\n\n\n\n\n\n\nconst JOINS = {\n    [__WEBPACK_IMPORTED_MODULE_3__proto__[\"Presentation\"].Class.LineStyle.JoinStyle.JoinMiter]: 0 /* MITER */,\n    [__WEBPACK_IMPORTED_MODULE_3__proto__[\"Presentation\"].Class.LineStyle.JoinStyle.JoinRound]: 1 /* ROUND */,\n    [__WEBPACK_IMPORTED_MODULE_3__proto__[\"Presentation\"].Class.LineStyle.JoinStyle.JoinBevel]: 2 /* BEVEL */\n};\nconst CAPS = {\n    [__WEBPACK_IMPORTED_MODULE_3__proto__[\"Presentation\"].Class.LineStyle.CapStyle.CapBevel]: 0 /* BUTT */,\n    [__WEBPACK_IMPORTED_MODULE_3__proto__[\"Presentation\"].Class.LineStyle.CapStyle.CapSquare]: 2 /* SQUARE */,\n    [__WEBPACK_IMPORTED_MODULE_3__proto__[\"Presentation\"].Class.LineStyle.CapStyle.CapRound]: 1 /* ROUND */\n};\nfunction extractPolylineStyle(zoomSlice, styleBase) {\n    let inlineStyle = (zoomSlice.line && zoomSlice.line.line) || (zoomSlice.poly && zoomSlice.poly.contour);\n    let outlineStyle = zoomSlice.line && zoomSlice.line.outline;\n    return inlineStyle || outlineStyle ? Object.assign({}, styleBase, { inline: inlineStyle ? {\n            strokeColor: inlineStyle.pattern ? __WEBPACK_IMPORTED_MODULE_4__util_color__[\"a\" /* TRANSPARENT_BLACK */] : Object(__WEBPACK_IMPORTED_MODULE_4__util_color__[\"b\" /* decodeAbgr8 */])(inlineStyle.color),\n            strokeWidth: inlineStyle.width,\n            join: JOINS[inlineStyle.joins],\n            startCap: CAPS[inlineStyle.caps],\n            endCap: CAPS[inlineStyle.caps],\n            dash: inlineStyle.dash ? {\n                fill: inlineStyle.dash.dashes[0].fill,\n                gap: inlineStyle.dash.dashes[0].gap\n            } : undefined,\n            pattern: inlineStyle.pattern ? {\n                imageId: inlineStyle.pattern.id,\n                width: inlineStyle.pattern.width,\n                height: inlineStyle.width\n            } : undefined\n        } : undefined, outline: outlineStyle ? {\n            strokeColor: outlineStyle.pattern ? __WEBPACK_IMPORTED_MODULE_4__util_color__[\"a\" /* TRANSPARENT_BLACK */] : Object(__WEBPACK_IMPORTED_MODULE_4__util_color__[\"b\" /* decodeAbgr8 */])(outlineStyle.color),\n            strokeWidth: outlineStyle.width,\n            join: JOINS[outlineStyle.joins],\n            startCap: CAPS[outlineStyle.caps],\n            endCap: CAPS[outlineStyle.caps],\n            dash: outlineStyle.dash ? {\n                fill: outlineStyle.dash.dashes[0].fill,\n                gap: outlineStyle.dash.dashes[0].gap\n            } : undefined\n        } : undefined }) : undefined;\n}\nfunction* extractPolylines(tile, decodedApiTile, tileMinZoom, tileMaxZoom) {\n    const polylines = decodedApiTile.polylines;\n    if (!polylines) {\n        return;\n    }\n    const preparePolyline = (vertices, classId, zOrder, forcedStartCap, forcedEndCap) => {\n        const styles = [...Object(__WEBPACK_IMPORTED_MODULE_2__extract_styles__[\"a\" /* default */])(decodedApiTile.presentation, classId, extractPolylineStyle, tileMinZoom, tileMaxZoom)];\n        for (const style of styles) {\n            style.zIndex += zOrder;\n            if (forcedStartCap !== undefined) {\n                if (style.inline) {\n                    style.inline.startCap = forcedStartCap;\n                }\n                if (style.outline) {\n                    style.outline.startCap = forcedStartCap;\n                }\n            }\n            if (forcedEndCap !== undefined && style.inline) {\n                if (style.inline) {\n                    style.inline.endCap = forcedEndCap;\n                }\n                if (style.outline) {\n                    style.outline.endCap = forcedEndCap;\n                }\n            }\n        }\n        return { vertices, styles };\n    };\n    const converter = new __WEBPACK_IMPORTED_MODULE_1__tile_world_coordinates_converter__[\"a\" /* default */](tile);\n    for (let lineIdx = 0, vertexIdx = 0; lineIdx < polylines.lineSize.length; ++lineIdx) {\n        const zOrderBegin = polylines.zOrderBegin[lineIdx] | 0;\n        const zOrderEnd = polylines.zOrderEnd[lineIdx] | 0;\n        const size = polylines.lineSize[lineIdx];\n        const vertices = new Array(size);\n        let forcedStartCap;\n        let forcedEndCap;\n        let x = 0;\n        let y = 0;\n        for (let i = 0; i < size; ++i, ++vertexIdx) {\n            x += polylines.coordsx[vertexIdx];\n            y += polylines.coordsy[vertexIdx];\n            // polylines between tiles that are actually one line on the map overlaps themself at the edge,\n            // to handle this case their caps are forcible removed, it is kind of hack and generally it is incorrect,\n            // but works well enough for the data being come from API.\n            if (i === 0 && Object(__WEBPACK_IMPORTED_MODULE_1__tile_world_coordinates_converter__[\"b\" /* isTileEdgeCoordinates */])(x, y)) {\n                forcedStartCap = 0 /* BUTT */;\n            }\n            if (i === size - 1 && Object(__WEBPACK_IMPORTED_MODULE_1__tile_world_coordinates_converter__[\"b\" /* isTileEdgeCoordinates */])(x, y)) {\n                forcedEndCap = 0 /* BUTT */;\n            }\n            vertices[i] = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"f\" /* create */](converter.toWorldXCoordinate(x), converter.toWorldYCoordinate(y));\n        }\n        if (zOrderBegin !== zOrderEnd) {\n            const verticesSplit = Object(__WEBPACK_IMPORTED_MODULE_5__util_polyline__[\"b\" /* splitPolyline */])(vertices);\n            yield preparePolyline(verticesSplit[0], polylines.classId[lineIdx], zOrderBegin, forcedStartCap, forcedEndCap);\n            yield preparePolyline(verticesSplit[1], polylines.classId[lineIdx], zOrderEnd, forcedStartCap, forcedEndCap);\n        }\n        else {\n            yield preparePolyline(vertices, polylines.classId[lineIdx], zOrderBegin, forcedStartCap, forcedEndCap);\n        }\n    }\n}\n\n\n/***/ }),\n/* 72 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_buffer_writer__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_triangulate__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polygon_attribute_mapping__ = __webpack_require__(74);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_color__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_gputypes__ = __webpack_require__(3);\n\n\n\n\n\n/**\n * Writer of geometry data of labels.\n */\nclass PolygonBufferWriter extends __WEBPACK_IMPORTED_MODULE_0__util_buffer_writer__[\"a\" /* default */] {\n    constructor() {\n        super(__WEBPACK_IMPORTED_MODULE_2__polygon_attribute_mapping__[\"a\" /* POLYGON_ATTRIBUTE_MAPPING */].vertexByteSize);\n    }\n    writePolygon(polygon, zIndex, color) {\n        const zIndexInt24 = Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__[\"c\" /* int24ToFloat */])(zIndex);\n        const colorRgba8 = Object(__WEBPACK_IMPORTED_MODULE_3__util_color__[\"c\" /* encodeRgba8 */])(color);\n        for (const ring of polygon.vertexRings) {\n            for (const vertex of ring) {\n                this._writeWorldCoordinate(vertex);\n                this._writeWord(colorRgba8);\n                this._writeFloat32(zIndexInt24);\n            }\n        }\n        this.writeIndices(Object(__WEBPACK_IMPORTED_MODULE_1__util_triangulate__[\"a\" /* default */])(polygon.vertexRings));\n        return this.endMesh();\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = PolygonBufferWriter;\n\n\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, size;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and size are later used to transform coords into integers for z-order calculation\n        size = Math.max(maxX - minX, maxY - minY);\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, size);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) return null;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, size, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && size) indexCurve(ear, minX, minY, size);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertice leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(ear, triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, size, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, size);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, size) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, size),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, size);\n\n    // first look for points inside the triangle in increasing z-order\n    var p = ear.nextZ;\n\n    while (p && p.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.nextZ;\n    }\n\n    // then look for points in decreasing z-order\n    p = ear.prevZ;\n\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return p;\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, size) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, size);\n                earcutLinked(c, triangles, dim, minX, minY, size);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m.next;\n\n    while (p !== stop) {\n        if (hx >= p.x && p.x >= mx &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    }\n\n    return m;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, size) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize === 0) {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                } else if (qSize === 0 || !q) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else if (p.z <= q.z) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and size of the data bounding box\nfunction zOrder(x, y, minX, minY, size) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) / size;\n    y = 32767 * (y - minY) / size;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&\n           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    if ((equals(p1, q1) && equals(p2, q2)) ||\n        (equals(p1, q2) && equals(p2, q1))) return true;\n    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&\n           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertice index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertice nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n\n/***/ }),\n/* 74 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(6);\n\n/**\n * Description of how attributes of vertices are packed into a vertex buffer.\n */\nconst POLYGON_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__[\"a\" /* AttributeMapping */]([\n    [\n        0 /* POSITION_HIGH */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        1 /* POSITION_LOW */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        7 /* COLOR */,\n        {\n            size: 4,\n            type: 5121 /* UNSIGNED_BYTE */,\n            normalized: true\n        }\n    ],\n    [\n        10 /* Z_INDEX */,\n        {\n            size: 1,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ]\n]);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = POLYGON_ATTRIBUTE_MAPPING;\n\n\n\n/***/ }),\n/* 75 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export isPowOf2 */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = align;\n/**\n * Checks if a number is a power of 2.\n *\n * @param x The number to check.\n * @returns `true` if the number is an integer power of 2 and `false` otherwise.\n */\nfunction isPowOf2(x) {\n    return x > 0 && !(x & (x - 1));\n}\n/**\n * Aligns an offset by an alignment given by a mask.\n *\n * @param offset The offset.\n * @param alignmentMask The alignment mask — a bit field that has `log2(alignment)`\n *      of least significant bits unset and other set, e.g. if `alignment` is 4\n *      then the `alignmentMask` will be `0xffffffc`\n * @returns Aligned offset.\n */\nfunction align(offset, alignmentMask) {\n    return (offset - 1 & alignmentMask) - alignmentMask;\n}\n\n\n/***/ }),\n/* 76 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_buffer_writer__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_triangulate__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__textured_polygon_attribute_mapping__ = __webpack_require__(77);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_gputypes__ = __webpack_require__(3);\n\n\n\n\n/**\n * Writer of geometry data of polygon images.\n */\nclass TexturedPolygonBufferWriter extends __WEBPACK_IMPORTED_MODULE_0__util_buffer_writer__[\"a\" /* default */] {\n    constructor() {\n        super(__WEBPACK_IMPORTED_MODULE_2__textured_polygon_attribute_mapping__[\"a\" /* TEXTURED_POLYGON_ATTRIBUTE_MAPPING */].vertexByteSize);\n    }\n    writePolygon(polygon, imageLocation, zIndex) {\n        for (const ring of polygon.vertexRings) {\n            for (const vertex of ring) {\n                this._writeVertex(vertex, imageLocation, 0, Object(__WEBPACK_IMPORTED_MODULE_3__util_gputypes__[\"c\" /* int24ToFloat */])(zIndex));\n            }\n        }\n        this.writeIndices(Object(__WEBPACK_IMPORTED_MODULE_1__util_triangulate__[\"a\" /* default */])(polygon.vertexRings));\n        return this.endMesh();\n    }\n    /**\n     * @param position World coordinates of the vertex.\n     * @param imageLocation Location of the pateern in atlas.\n     * @param imageScale How world coordinates relate to the image size.\n     * @param zIndex Vertex z-coordinate.\n     */\n    _writeVertex(position, imageLocation, imageScale, zIndex) {\n        this._writeWorldCoordinate(position);\n        this._writeHalfWords(imageLocation.minX, imageLocation.minY);\n        this._writeHalfWords(imageLocation.maxX - imageLocation.minX, imageLocation.maxY - imageLocation.minY);\n        this._writeFloat32(imageScale);\n        this._writeFloat32(zIndex);\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = TexturedPolygonBufferWriter;\n\n\n\n/***/ }),\n/* 77 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(6);\n\n/**\n * Description of how attributes of vertices are packed into a vertex buffer.\n */\nconst TEXTURED_POLYGON_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__[\"a\" /* AttributeMapping */]([\n    [\n        0 /* POSITION_HIGH */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        1 /* POSITION_LOW */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        4 /* UV */,\n        {\n            size: 4,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: false\n        }\n    ],\n    [\n        11 /* AUX */,\n        {\n            size: 1,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        10 /* Z_INDEX */,\n        {\n            size: 1,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ]\n]);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = TEXTURED_POLYGON_ATTRIBUTE_MAPPING;\n\n\n\n/***/ }),\n/* 78 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_color__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_gputypes__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_polyline__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polyline_geometry__ = __webpack_require__(79);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polyline_attribute_mapping__ = __webpack_require__(80);\n\n\n\n\n\n\n/**\n * Writer of geometry data of polyline hulls.\n */\nclass PolylineBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__[\"a\" /* default */] {\n    constructor() {\n        super(__WEBPACK_IMPORTED_MODULE_5__polyline_attribute_mapping__[\"a\" /* POLYLINE_ATTRIBUTE_MAPPING */].vertexByteSize);\n    }\n    /**\n     * Generates a hull for a polyline and writes it to the writer.\n     *\n     * @param polyline The polyline to be written.\n     * @param zIndex Order of overlapping among all polylines.\n     * @param worldToPxFactor Ratio of world coordinates to pixels.\n     * @param inlineStyle Style of the main central part of the polyline.\n     * @param outlineStyle Style of the outline, rendered as an independent solid polyline with reduced zIndex.\n     */\n    writePolyline(polyline, zIndex, worldToPxFactor, inlineStyle, outlineStyle) {\n        if (outlineStyle) {\n            this._writePolyline(polyline, Object(__WEBPACK_IMPORTED_MODULE_2__util_gputypes__[\"c\" /* int24ToFloat */])(zIndex), worldToPxFactor, outlineStyle);\n        }\n        if (inlineStyle) {\n            this._writePolyline(polyline, Object(__WEBPACK_IMPORTED_MODULE_2__util_gputypes__[\"c\" /* int24ToFloat */])(zIndex + 1), worldToPxFactor, inlineStyle);\n        }\n        return this.endMesh();\n    }\n    _writePolyline(polyline, zIndex, worldToPxFactor, style) {\n        const colorRgba8 = Object(__WEBPACK_IMPORTED_MODULE_0__util_color__[\"c\" /* encodeRgba8 */])(style.strokeColor);\n        if (style.dash) {\n            const worldFill = style.dash.fill * worldToPxFactor;\n            const worldGap = style.dash.gap * worldToPxFactor;\n            const dashes = [...Object(__WEBPACK_IMPORTED_MODULE_3__util_polyline__[\"a\" /* dashPolyline */])(polyline.vertices, worldFill, worldGap)];\n            for (let i = 0; i < dashes.length; i++) {\n                const startCap = (i == 0) ? style.startCap : 0 /* BUTT */;\n                const endCap = (i == dashes.length - 1) ? style.endCap : 0 /* BUTT */;\n                Object(__WEBPACK_IMPORTED_MODULE_4__polyline_geometry__[\"a\" /* default */])(this, dashes[i], startCap, endCap, style.join, style.strokeWidth, colorRgba8, zIndex);\n            }\n        }\n        else {\n            Object(__WEBPACK_IMPORTED_MODULE_4__polyline_geometry__[\"a\" /* default */])(this, polyline.vertices, style.startCap, style.endCap, style.join, style.strokeWidth, colorRgba8, zIndex);\n        }\n    }\n    /**\n     * Writes a vertex to the vertex buffer.\n     *\n     * @param position Position of the vertex in world coordinates.\n     * @param displacement Displacement vector, in most cases must be normalized, the width is considered in shaders.\n     * @param width Thickness of the polyline.\n     * @param colorRgba8 Color of the polyline encoded as RGBA8.\n     * @param zIndex Order of overlapping among all polylines.\n     * @return Index of the written vertex.\n     */\n    writeVertex(position, displacement, width, colorRgba8, zIndex) {\n        const vertexIdx = this.getCurrentVertexIdx();\n        this._writeWorldCoordinate(position);\n        this._writeFloat32(zIndex);\n        this._writeFloat32(displacement.x);\n        this._writeFloat32(displacement.y);\n        this._writeWord(colorRgba8);\n        this._writeFloat32(width);\n        return vertexIdx;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = PolylineBufferWriter;\n\n\n\n/***/ }),\n/* 79 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = writePolylineGeometry;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);\n\nconst tmpVector = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"f\" /* create */](0, 0);\n/**\n * Generates vectors arranged in circle arc formed by two vectors.\n * TODO: ambiguous results were obtained in performance tests, get back to them to find the best approach\n *\n * @param from Start edge of the segment.\n * @param to End edge of the segment.\n */\nfunction* generateRoundVectors(from, to) {\n    for (let i = 0, n = Math.ceil(8 * Math.acos(__WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"i\" /* dot */](from, to)) / Math.PI), v = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"e\" /* copy */](from); i <= n; __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"n\" /* rotate */](v, Math.PI / 8, v), ++i) {\n        yield v;\n    }\n}\n/**\n * Writes cap geometry into the buffer.\n *\n * @param writer Output buffer writer.\n * @param type Type of cap.\n * @param halfWidth Half of polyline's width.\n * @param colorRgba8 Color of the polyline encoded as RGBA8.\n * @param z Z-coordinate of all vertices that are to be written.\n * @param direction Vector (normalized) of the segment, the cap is to be drawn at the end of positive direction.\n * @param normal Normal vector to direction.\n * @param normalInverted Vector with opposite to normal direction.\n * @param endPoint World coordinates of the end of the segment.\n * @param leftPointIndex Index of the left (relative to direction) point to reuse it in cap's geometry.\n * @param rightPointIndex Index of the right (relative to direction) point to reuse it in cap's geometry.\n */\nfunction writeCap(writer, type, halfWidth, colorRgba8, z, direction, normal, normalInverted, endPoint, leftPointIndex, rightPointIndex) {\n    switch (type) {\n        case (2 /* SQUARE */):\n            __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"c\" /* add */](direction, normal, tmpVector);\n            const capLeftPointIndex = writer.writeVertex(endPoint, tmpVector, halfWidth, colorRgba8, z);\n            __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"c\" /* add */](direction, normalInverted, tmpVector);\n            const capRightPointIndex = writer.writeVertex(endPoint, tmpVector, halfWidth, colorRgba8, z);\n            writer.writeIndices([\n                leftPointIndex, capRightPointIndex, rightPointIndex,\n                leftPointIndex, capLeftPointIndex, capRightPointIndex\n            ]);\n            break;\n        case (1 /* ROUND */):\n            const pointIndex = writer.writeVertex(endPoint, __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"b\" /* ZERO */], halfWidth, colorRgba8, z);\n            const indices = [pointIndex];\n            indices.push(rightPointIndex);\n            for (const vector of generateRoundVectors(normalInverted, normal)) {\n                indices.push(writer.writeVertex(endPoint, vector, halfWidth, colorRgba8, z));\n            }\n            indices.push(leftPointIndex);\n            writer.writeIndicesForFan(indices);\n            break;\n        case (0 /* BUTT */):\n            // just skip it\n            break;\n    }\n}\n/**\n * Writes lines join geometry into the buffer.\n *\n * @param writer Output buffer writer.\n * @param type Type of join.\n * @param halfWidth Half of polyline's width.\n * @param colorRgba8 Color of the polyline.\n * @param z Z-coordinate of all vertices that are to be written.\n * @param leftNormal Normal of the segment that is left to the fracture.\n * @param rightNormal Normal of the segment that is right to the fracture.\n * @param joinPoint World coordinates of point between both segments.\n * @param leftPointIndex Index of the left (relative to \"left + right\" normal) point to reuse it in join's geometry.\n * @param rightPointIndex Index of the right (relative to \"left + right\" normal) point to reuse it in join's geometry.\n */\nfunction writeJoin(writer, type, halfWidth, colorRgba8, z, leftNormal, rightNormal, joinPoint, leftPointIndex, rightPointIndex) {\n    switch (type) {\n        case (2 /* BEVEL */):\n        // TODO: implement BEVEL, currently fallback to MITER\n        case (0 /* MITER */):\n            const joinPointIndex = writer.writeVertex(joinPoint, __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"b\" /* ZERO */], halfWidth, colorRgba8, z);\n            writer.writeIndices([\n                joinPointIndex, leftPointIndex, rightPointIndex\n            ]);\n            break;\n        case (1 /* ROUND */):\n            const pointIndex = writer.writeVertex(joinPoint, __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"b\" /* ZERO */], halfWidth, colorRgba8, z);\n            const indices = [pointIndex];\n            indices.push(rightPointIndex);\n            for (const vector of generateRoundVectors(rightNormal, leftNormal)) {\n                indices.push(writer.writeVertex(joinPoint, vector, halfWidth, colorRgba8, z));\n            }\n            indices.push(leftPointIndex);\n            writer.writeIndicesForFan(indices);\n            break;\n    }\n}\n/**\n * Writes polyline geometry (set of triangles that draw up a solid thick polyline) into a buffer writer.\n *\n * @param writer Output buffer writer.\n * @param polyline Polyline to be written.\n * @param cap Type of cap of the polyline.\n * @param join Type of join of the polyline.\n * @param width Thickness of the polyline.\n * @param colorRgba8 Color of the polyline encoded as RGBA8.\n * @param z Z-coordinate of all vertices that are to be written.\n */\nfunction writePolylineGeometry(writer, polyline, startCap, endCap, join, width, colorRgba8, z) {\n    const hWidth = width / 2;\n    const dir = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"f\" /* create */](0, 0);\n    const dirInv = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"f\" /* create */](0, 0);\n    const norm = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"f\" /* create */](0, 0);\n    const normInv = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"f\" /* create */](0, 0);\n    const prevDir = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"f\" /* create */](0, 0);\n    const prevNorm = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"f\" /* create */](0, 0);\n    let prevTopRight = -1;\n    let prevBottomRight = -1;\n    for (let i = 1; i < polyline.length; i++) {\n        __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"p\" /* sub */](polyline[i], polyline[i - 1], dir);\n        __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"m\" /* normalize */](dir, dir);\n        __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"l\" /* muln */](dir, -1, dirInv);\n        __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"o\" /* rotate90 */](dir, norm);\n        __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"l\" /* muln */](norm, -1, normInv);\n        // \"body\" of a segment is written as a rectangle (two triangles)\n        const topLeft = writer.writeVertex(polyline[i - 1], norm, hWidth, colorRgba8, z);\n        const topRight = writer.writeVertex(polyline[i], norm, hWidth, colorRgba8, z);\n        const bottomRight = writer.writeVertex(polyline[i], normInv, hWidth, colorRgba8, z);\n        const bottomLeft = writer.writeVertex(polyline[i - 1], normInv, hWidth, colorRgba8, z);\n        writer.writeIndices([\n            topLeft, topRight, bottomLeft,\n            topRight, bottomRight, bottomLeft\n        ]);\n        // start cap\n        if (i === 1) {\n            writeCap(writer, startCap, hWidth, colorRgba8, z, dirInv, normInv, norm, polyline[0], bottomLeft, topLeft);\n        }\n        // end cap\n        if (i === polyline.length - 1) {\n            writeCap(writer, endCap, hWidth, colorRgba8, z, dir, norm, normInv, polyline[i], topRight, bottomRight);\n        }\n        // line join\n        if (i > 1) {\n            // find out where the fracture of segments is located to create correct join with minimum overdraw\n            const turnLeft = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"g\" /* crossZ */](prevDir, dir) > 0;\n            if (turnLeft) {\n                writeJoin(writer, join, hWidth, colorRgba8, z, prevNorm, norm, polyline[i - 1], bottomLeft, prevBottomRight);\n            }\n            else {\n                writeJoin(writer, join, hWidth, colorRgba8, z, norm, prevNorm, polyline[i - 1], prevTopRight, topLeft);\n            }\n        }\n        __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"e\" /* copy */](dir, prevDir);\n        __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"e\" /* copy */](norm, prevNorm);\n        prevTopRight = topRight;\n        prevBottomRight = bottomRight;\n    }\n}\n\n\n/***/ }),\n/* 80 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(6);\n\n/**\n * Description of how attributes of vertices are packed into a vertex buffer.\n */\nconst POLYLINE_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__[\"a\" /* AttributeMapping */]([\n    [\n        0 /* POSITION_HIGH */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        1 /* POSITION_LOW */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        9 /* PRIORITY */,\n        {\n            size: 1,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        6 /* DISPLACEMENT */,\n        {\n            size: 2,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        7 /* COLOR */,\n        {\n            size: 4,\n            type: 5121 /* UNSIGNED_BYTE */,\n            normalized: true\n        }\n    ],\n    [\n        11 /* AUX */,\n        {\n            size: 1,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ]\n]);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = POLYLINE_ATTRIBUTE_MAPPING;\n\n\n\n/***/ }),\n/* 81 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = extractPolygons;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tile_world_coordinates_converter__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_color__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extract_styles__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_iterable__ = __webpack_require__(9);\n\n\n\n\n/**\n * Utility method for getting polygon ring vertices from API tile response.\n */\nfunction* extractVertices(polygons, coordsOffset, ringSize, converter) {\n    // coordinates are stored in deltas relatively to the first values in ring\n    // so we need to accumulate x and y to determine subsequent coordinates\n    let x = 0;\n    let y = 0;\n    for (let j = 0; j < ringSize; j++) {\n        x += polygons.coordsx[coordsOffset];\n        y += polygons.coordsy[coordsOffset];\n        yield converter.toWorldCoordinates(x, y);\n        coordsOffset++;\n    }\n}\n/**\n * Utility method for getting polygon rings from API tile response.\n */\nfunction* extractRings(polygons, coordsOffset, ringSizeOffset, ringSizeLength, converter) {\n    for (let i = 0; i < ringSizeLength; i++) {\n        const ringSize = polygons.ringSize[ringSizeOffset + i];\n        yield extractVertices(polygons, coordsOffset, ringSize, converter);\n        coordsOffset += ringSize;\n    }\n}\nfunction convertMeshDescription(height, converter, mesh) {\n    if (mesh && mesh.bbox) {\n        return {\n            objectId: mesh.objectId,\n            meshId: mesh.meshId,\n            bbox: {\n                minX: converter.toWorldXCoordinate(mesh.bbox.minX),\n                maxX: converter.toWorldXCoordinate(mesh.bbox.maxX),\n                minY: converter.toWorldYCoordinate(mesh.bbox.maxY),\n                maxY: converter.toWorldYCoordinate(mesh.bbox.minY),\n                minZ: height,\n                maxZ: 0\n            }\n        };\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Utility method for getting polygon specific style details from a zoom slice.\n * To be used as a zoom slice style converter for style extractor.\n */\nfunction convertZoomSliceToStyle(slice, styleBase) {\n    if (slice.poly) {\n        const extruded = !!slice.poly.extrusion && slice.poly.extrusion.enabled;\n        return Object.assign({}, styleBase, { color: Object(__WEBPACK_IMPORTED_MODULE_1__util_color__[\"b\" /* decodeAbgr8 */])(slice.poly.color), pattern: slice.poly.pattern ? {\n                imageId: slice.poly.pattern.id,\n                width: slice.poly.pattern.width\n            } : undefined, extruded, height: extruded ? slice.poly.extrusion.height : 0 });\n    }\n    return undefined;\n}\n/**\n * Utility method for getting point labels from API tile response.\n */\nfunction* extractPolygons(tile, decodedApiTile, tileMinZoom, tileMaxZoom) {\n    const polygons = decodedApiTile.polygons;\n    if (polygons) {\n        const converter = new __WEBPACK_IMPORTED_MODULE_0__tile_world_coordinates_converter__[\"a\" /* default */](tile);\n        let ringCountOffset = 0;\n        let ringSizeOffset = 0;\n        let coordsOffset = 0;\n        const meshes = polygons.mesh.reduce((meshes, mesh) => (meshes.set(mesh.polygonId, mesh), meshes), new Map());\n        while (ringCountOffset < polygons.ringCount.length) {\n            const polygonRingSizeLength = polygons.ringCount[ringCountOffset];\n            const polygonRingSizeOffset = ringSizeOffset;\n            const polygonCoordsOffset = coordsOffset;\n            const classId = polygons.classId[ringCountOffset];\n            const styles = [...Object(__WEBPACK_IMPORTED_MODULE_2__extract_styles__[\"a\" /* default */])(decodedApiTile.presentation, classId, convertZoomSliceToStyle, tileMinZoom, tileMaxZoom)];\n            const isExtruded = styles[0] && styles[0].extruded;\n            const height = isExtruded ? converter.toWorldZCoordinate(polygons.height[ringCountOffset] || styles[0].height || 0) : 0;\n            const externalMesh = isExtruded ? convertMeshDescription(height, converter, meshes.get(ringCountOffset)) : undefined;\n            let coordsLength = 0;\n            for (let i = 0; i < polygonRingSizeLength; i++) {\n                coordsLength += polygons.ringSize[ringSizeOffset + i];\n            }\n            yield {\n                vertexRings: [...Object(__WEBPACK_IMPORTED_MODULE_3__util_iterable__[\"a\" /* mapIterable */])(extractRings(polygons, polygonCoordsOffset, polygonRingSizeOffset, polygonRingSizeLength, converter), (ringIterable) => [...ringIterable])],\n                height,\n                externalMesh,\n                styles\n            };\n            ringSizeOffset += polygonRingSizeLength;\n            coordsOffset += coordsLength;\n            ringCountOffset++;\n        }\n    }\n}\n\n\n/***/ }),\n/* 82 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_triangulate__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__primitive_model_model_buffer_writer__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_color__ = __webpack_require__(0);\n\n\n\n/**\n * Buffer writer that writes extruded polygons as 3D meshes.\n * It just moves a polygon up to the height and adds the \"walls\" around.\n */\nclass ExtrudedPolygonBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__primitive_model_model_buffer_writer__[\"a\" /* default */] {\n    /**\n     * Writes a polygon as a prism with specified height and with only one upper base.\n     *\n     * @param polygon The form of the prism's base.\n     * @param height The height of the prism, world z-coordinate.\n     * @returns The location of the mesh in a buffer.\n     */\n    writePolygon(polygon, height, color) {\n        const encodedColor = Object(__WEBPACK_IMPORTED_MODULE_2__util_color__[\"c\" /* encodeRgba8 */])(color);\n        const vertices = polygon.vertexRings.reduce((vertices, ring) => (vertices.push(...ring), vertices), []);\n        for (const vertex of vertices) {\n            this._writeVertex(Object.assign({}, vertex, { z: height }), encodedColor);\n        }\n        for (const vertex of vertices) {\n            this._writeVertex(Object.assign({}, vertex, { z: 0 }), encodedColor);\n        }\n        this.writeIndices(Object(__WEBPACK_IMPORTED_MODULE_0__util_triangulate__[\"a\" /* default */])(polygon.vertexRings));\n        this._buildWall(polygon.vertexRings, vertices.length);\n        return this.endMesh();\n    }\n    _buildWall(vertexRings, verticesCount) {\n        let offset = 0;\n        for (const ring of vertexRings) {\n            for (let i = 0; i < ring.length; i++) {\n                const from = offset + i;\n                const to = offset + (i + 1) % ring.length;\n                this.writeIndices([\n                    from + verticesCount,\n                    to,\n                    from,\n                    from + verticesCount,\n                    to + verticesCount,\n                    to,\n                ]);\n            }\n            offset += ring.length;\n        }\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ExtrudedPolygonBufferWriter;\n\n\n\n/***/ }),\n/* 83 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = extractCurvedLabels;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tile_world_coordinates_converter__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extract_styles__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extract_labels__ = __webpack_require__(28);\n\n\n\n/**\n * Utility method for getting label polyline from API tile response.\n *\n * @param curvedLabels API tile response.\n * @param polylineOffset Offset of polyline in vertex arrays.\n * @param polylineLength Number of points in polyline.\n * @param converter Vertex coordinates are stored in tile coordinates, output should be converted.\n */\nfunction* extractPolyline(curvedLabels, polylineOffset, polylineLength, converter) {\n    // the first vertex is in absolute tile coordinates,\n    // others - in deltas that should be added to the previous (accumulated) value\n    let x = 0;\n    let y = 0;\n    for (let i = 0; i < polylineLength; i++) {\n        yield converter.toWorldCoordinates(x += curvedLabels.vertexX[polylineOffset + i], y += curvedLabels.vertexY[polylineOffset + i]);\n    }\n}\n/**\n * Utility method for getting texts (text and altText) from API tile response. These texts are both optional and\n * returned iterable may contains from 0 to 2 texts.\n *\n * @param curvedLabels API tile response.\n * @param index Label position in curvedLabels's text/textAlt arrays.\n */\nfunction* extractTexts(curvedLabels, index) {\n    if (curvedLabels.text[index]) {\n        yield {\n            textLines: [{ glyphIds: curvedLabels.text[index].glyphs }]\n        };\n    }\n    if (curvedLabels.textAlt[index] && curvedLabels.textAlt[index].glyphs.length > 0) {\n        yield {\n            textLines: [{ glyphIds: curvedLabels.textAlt[index].glyphs }]\n        };\n    }\n}\n/**\n * Overridden style converter, takes care of vertical distance extraction.\n */\nfunction convertZoomSliceToCurvedLabelStyle(slice, styleBase) {\n    const style = Object(__WEBPACK_IMPORTED_MODULE_2__extract_labels__[\"a\" /* convertZoomSliceToLabelStyle */])(slice, styleBase);\n    if (style && slice.label && slice.label.hdistance) {\n        style.distance = slice.label.hdistance;\n    }\n    return style;\n}\n/**\n * Utility method for getting curved labels from API tile response.\n */\nfunction* extractCurvedLabels(tile, decodedApiTile, tileMinZoom, tileMaxZoom) {\n    const labels = decodedApiTile.polylineLabels;\n    if (labels) {\n        const converter = new __WEBPACK_IMPORTED_MODULE_0__tile_world_coordinates_converter__[\"a\" /* default */](tile);\n        let offset = 0;\n        for (let i = 0; i < labels.text.length; i++) {\n            const classId = labels.classId[i];\n            const vertexCount = labels.verticesCount[i];\n            yield {\n                polyline: [...extractPolyline(labels, offset, vertexCount, converter)],\n                priority: labels.priority[i],\n                texts: [...extractTexts(labels, i)],\n                styles: [...Object(__WEBPACK_IMPORTED_MODULE_1__extract_styles__[\"a\" /* default */])(decodedApiTile.presentation, classId, convertZoomSliceToCurvedLabelStyle, tileMinZoom, tileMaxZoom)]\n            };\n            offset += vertexCount;\n        }\n    }\n}\n\n\n/***/ }),\n/* 84 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = extractPointLabel;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__proto__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__proto___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__proto__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tile_world_coordinates_converter__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extract_styles__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__extract_labels__ = __webpack_require__(28);\n\n\n\n\n\nconst ALIGNMENT = {\n    [__WEBPACK_IMPORTED_MODULE_0__proto__[\"Tile\"].StraightLabels.AlignType.Left]: 0 /* LEFT */,\n    [__WEBPACK_IMPORTED_MODULE_0__proto__[\"Tile\"].StraightLabels.AlignType.Right]: 2 /* RIGHT */,\n    [__WEBPACK_IMPORTED_MODULE_0__proto__[\"Tile\"].StraightLabels.AlignType.Center]: 1 /* CENTER */\n};\n/**\n * Utility method for getting texts (text and altText) from API tile response. These texts are both optional and\n * returned iterable may contains from 0 to 2 texts.\n *\n * @param pointLabels API tile response.\n * @param index Label position in pointLabel's text/textAlt arrays.\n */\nfunction* extractTexts(pointLabels, index) {\n    if (pointLabels.text[index]) {\n        yield {\n            textLines: pointLabels.text[index].strings.map((str) => ({ glyphIds: str.glyphs }))\n        };\n    }\n    if (pointLabels.textAlt[index] && pointLabels.textAlt[index].strings.length > 0) {\n        yield {\n            textLines: pointLabels.textAlt[index].strings.map((str) => ({ glyphIds: str.glyphs }))\n        };\n    }\n}\n/**\n * Overridden style converter, takes care of vertical distance extraction.\n */\nfunction convertZoomSliceToStraightLabelStyle(slice, styleBase) {\n    const style = Object(__WEBPACK_IMPORTED_MODULE_4__extract_labels__[\"a\" /* convertZoomSliceToLabelStyle */])(slice, styleBase);\n    if (style && slice.label) {\n        style.distance = slice.label.vdistance;\n    }\n    return style;\n}\n/**\n * Utility method for getting point labels from API tile response.\n */\nfunction* extractPointLabel(tile, decodedApiTile, tileMinZoom, tileMaxZoom) {\n    const pointLabels = decodedApiTile.pointLabels;\n    if (pointLabels) {\n        const converter = new __WEBPACK_IMPORTED_MODULE_1__tile_world_coordinates_converter__[\"a\" /* default */](tile);\n        for (let i = 0; i < pointLabels.text.length; i++) {\n            const classId = pointLabels.classId[i];\n            const styles = [...Object(__WEBPACK_IMPORTED_MODULE_3__extract_styles__[\"a\" /* default */])(decodedApiTile.presentation, classId, convertZoomSliceToStraightLabelStyle, tileMinZoom, tileMaxZoom)];\n            for (const style of styles) {\n                style.align = ALIGNMENT[pointLabels.align[i]];\n            }\n            yield {\n                anchorPoint: converter.toWorldCoordinates(pointLabels.centerX[i], pointLabels.centerY[i]),\n                offset: __WEBPACK_IMPORTED_MODULE_2__math_vector2__[\"f\" /* create */](pointLabels.offsetX[i], pointLabels.offsetY[i]),\n                priority: pointLabels.priority[i],\n                texts: [...extractTexts(pointLabels, i)],\n                styles: styles\n            };\n        }\n    }\n}\n\n\n/***/ }),\n/* 85 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = layoutPointLabel;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);\n\n/**\n * @returns Full width of all line glyphs using glyph's advance metric (it doesn't take into account the font size).\n */\nfunction calculateLineWidth(font, line) {\n    return line.glyphIds.reduce((width, glyphId) => {\n        return width + font.getGlyph(glyphId).advance;\n    }, 0);\n}\n/**\n * @returns Real max height of the line looking through all the glyphs and their bearingY and height metrics.\n */\nfunction calculateLineHeight(font, line) {\n    let maxHeightAboveBaseline = 0;\n    let maxHeightBelowBaseline = 0;\n    for (const glyphId of line.glyphIds) {\n        const glyph = font.getGlyph(glyphId);\n        maxHeightAboveBaseline = Math.max(maxHeightAboveBaseline, glyph.bearingY);\n        maxHeightBelowBaseline = Math.max(maxHeightBelowBaseline, glyph.height - glyph.bearingY);\n    }\n    return maxHeightAboveBaseline + maxHeightBelowBaseline;\n}\n/**\n * Layout one straight line in absolute (to the whole label) coordinates using the origin point as an offset vector.\n */\nfunction* layoutLine(textLine, xOrigin, yOrigin, font, scale) {\n    const glyphIds = textLine.glyphIds;\n    const length = glyphIds.length;\n    for (let i = 0; i < length; i++) {\n        const glyph = font.getGlyph(glyphIds[i]);\n        const left = xOrigin + (glyph.bearingX - font.margin) * scale;\n        const right = xOrigin + (glyph.bearingX + glyph.width + font.margin) * scale;\n        const top = yOrigin + (glyph.bearingY + font.margin) * scale;\n        const bottom = yOrigin + (glyph.bearingY - glyph.height - font.margin) * scale;\n        const topLeft = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"f\" /* create */](left, top);\n        const topRight = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"f\" /* create */](right, top);\n        const bottomRight = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"f\" /* create */](right, bottom);\n        const bottomLeft = __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"f\" /* create */](left, bottom);\n        yield {\n            fontId: font.id,\n            glyphId: glyph.id,\n            scale,\n            topLeft,\n            topRight,\n            bottomRight,\n            bottomLeft\n        };\n        xOrigin += glyph.advance * scale;\n    }\n}\n/**\n * How bigger the line height to the font size.\n */\nconst LINE_HEIGHT_FACTOR = 1.5;\n/**\n * Creates layout of glyphs in abstract points, that are roughly correspond to CSS pixels and should be rendered\n * accordingly. Text's textLines all start from new lines, a text is just a set of lines with common styles.\n * The origin (0, 0) depending on the alignment is located at:\n *  * the first line's baseline leftmost point for LEFT\n *  * the first line's baseline center point for CENTER\n *  * the first line's baseline rightmost point for RIGHT\n */\nfunction layoutPointLabel(label, labelStyle, fontRegistry) {\n    const layout = [];\n    const textLineDetails = label.texts.map((text, i) => {\n        const textStyle = labelStyle.styles[i];\n        const font = fontRegistry.get(textStyle.fontId);\n        const scale = textStyle.fontSize / font.xheight;\n        const height = textStyle.fontSize * LINE_HEIGHT_FACTOR;\n        return text.textLines.map((line) => {\n            const width = calculateLineWidth(font, line) * scale;\n            const maxHeight = calculateLineHeight(font, line) * scale;\n            return { line, font, scale, width, height, maxHeight };\n        });\n    });\n    const bboxSize = textLineDetails.reduce((bboxSize, lineSizes) => {\n        return lineSizes.reduce((bboxSize, lineSize) => {\n            bboxSize.width = Math.max(bboxSize.width, lineSize.width);\n            bboxSize.height += lineSize.maxHeight;\n            return bboxSize;\n        }, bboxSize);\n    }, {\n        width: 0,\n        height: labelStyle.distance * (textLineDetails.length - 1)\n    });\n    let xOrigin = label.offset.x - bboxSize.width / 2;\n    let yOrigin = label.offset.y + bboxSize.height / 2;\n    for (const textLines of textLineDetails) {\n        const textLayout = [];\n        for (const line of textLines) {\n            const lineYOrigin = (yOrigin -= line.height);\n            const lineXOrigin = xOrigin + ((labelStyle.align === 0 /* LEFT */) ? 0 :\n                (labelStyle.align === 1 /* CENTER */) ? (bboxSize.width - line.width) / 2 :\n                    (labelStyle.align === 2 /* RIGHT */) ? (bboxSize.width - line.width) : 0);\n            for (const glyphLayout of layoutLine(line.line, lineXOrigin, lineYOrigin, line.font, line.scale)) {\n                textLayout.push(glyphLayout);\n            }\n        }\n        yOrigin -= labelStyle.distance;\n        layout.push(textLayout);\n    }\n    return layout;\n}\n\n\n/***/ }),\n/* 86 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_buffer_writer__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector2__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_color__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__attribute_mapping__ = __webpack_require__(87);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_gputypes__ = __webpack_require__(3);\n\n\n\n\n\nconst BOTTOM_LEFT_UV_INT16 = __WEBPACK_IMPORTED_MODULE_1__math_vector2__[\"f\" /* create */](-0x8000, -0x8000);\nconst TOP_LEFT_UV_INT16 = __WEBPACK_IMPORTED_MODULE_1__math_vector2__[\"f\" /* create */](-0x8000, 0x7fff);\nconst BOTTOM_RIGHT_UV_INT16 = __WEBPACK_IMPORTED_MODULE_1__math_vector2__[\"f\" /* create */](0x7fff, -0x8000);\nconst TOP_RIGHT_UV_INT16 = __WEBPACK_IMPORTED_MODULE_1__math_vector2__[\"f\" /* create */](0x7fff, 0x7fff);\n/**\n * Writer of geometry data of rectangles.\n */\nclass BillboardRectangleBufferWriter extends __WEBPACK_IMPORTED_MODULE_0__util_buffer_writer__[\"a\" /* default */] {\n    constructor() {\n        super(__WEBPACK_IMPORTED_MODULE_3__attribute_mapping__[\"a\" /* BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING */].vertexByteSize);\n    }\n    /**\n     * Writes a rectangle to buffers.\n     *\n     * @returns Location of the image data in buffers.\n     */\n    writeRectangle(id, rectangle, style) {\n        const idHigh = id >> 8;\n        const idLow = id & 0xff;\n        const { borderRadius, offset, width, height } = style;\n        const halfWidth = width / 2;\n        const halfHeight = height / 2;\n        const colorRgba8 = Object(__WEBPACK_IMPORTED_MODULE_2__util_color__[\"c\" /* encodeRgba8 */])(style.color);\n        const borderRadiusX = borderRadius / halfWidth;\n        const borderRadiusY = borderRadius / halfHeight;\n        this._writeVertex(idHigh, idLow, rectangle.position, -halfWidth, -halfHeight, offset, BOTTOM_LEFT_UV_INT16, colorRgba8, borderRadiusX, borderRadiusY);\n        this._writeVertex(idHigh, idLow, rectangle.position, -halfWidth, halfHeight, offset, TOP_LEFT_UV_INT16, colorRgba8, borderRadiusX, borderRadiusY);\n        this._writeVertex(idHigh, idLow, rectangle.position, halfWidth, -halfHeight, offset, BOTTOM_RIGHT_UV_INT16, colorRgba8, borderRadiusX, borderRadiusY);\n        this._writeVertex(idHigh, idLow, rectangle.position, halfWidth, halfHeight, offset, TOP_RIGHT_UV_INT16, colorRgba8, borderRadiusX, borderRadiusY);\n        this.writeIndicesForContinuousStrip(4);\n        return this.endMesh();\n    }\n    /**\n     * Writes a vertex to the vertex buffer.\n     *\n     * @param idHigh Most significant 8 bits of rectangle id.\n     * @param idLow Least significant 8 bits of rectangle id.\n     * @param position World coordinate of rectangle.\n     * @param displacementX X coordinate displacement in pixels of concrete vertex.\n     * @param displacementY Y coordinate displacement in pixels of concrete vertex.\n     * @param offset Additional displacement for all vertices specified in style.\n     * @param uv UV coordinated of the vertex of the rectangle.\n     * @param color Background color encoded into RGBA8\n     * @param borderRadiusX Radius of corner rounding along X axis (i.e., horizontal\n     *      axis of rounding ellipse).\n     * @param borderRadiusY Radius of corner rounding along Y axis (i.e., vertical\n     *      axis of rounding ellipse).\n     * @returns Index of the written vertex.\n     */\n    _writeVertex(idHigh, idLow, position, displacementX, displacementY, offset, uv, colorRgba8, borderRadiusX, borderRadiusY) {\n        const vertexIdx = this.getCurrentVertexIdx();\n        this._writeBytes(idHigh, idLow, 0, 0);\n        this._writeWorldCoordinate(position);\n        this._writeFloat32(displacementX + offset.x);\n        this._writeFloat32(displacementY + offset.y);\n        this._writeHalfWords(uv.x, uv.y);\n        this._writeWord(colorRgba8);\n        this._writeHalfWords(Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__[\"a\" /* floatToUint16 */])(borderRadiusX), Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__[\"a\" /* floatToUint16 */])(borderRadiusY));\n        return vertexIdx;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = BillboardRectangleBufferWriter;\n\n\n\n/***/ }),\n/* 87 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(6);\n\n/** Description of how a writer stores vertex data. */\nconst BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__[\"a\" /* AttributeMapping */]([\n    [\n        2 /* ID */,\n        {\n            size: 4,\n            type: 5121 /* UNSIGNED_BYTE */,\n            normalized: true\n        }\n    ],\n    [\n        0 /* POSITION_HIGH */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        1 /* POSITION_LOW */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        6 /* DISPLACEMENT */,\n        {\n            size: 2,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        4 /* UV */,\n        {\n            size: 2,\n            type: 5122 /* SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        7 /* COLOR */,\n        {\n            size: 4,\n            type: 5121 /* UNSIGNED_BYTE */,\n            normalized: true\n        }\n    ],\n    [\n        11 /* AUX */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ]\n]);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING;\n\n\n\n/***/ }),\n/* 88 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_buffer_writer__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_iterable__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_color__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_gputypes__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__point_label_attribute_mapping__ = __webpack_require__(89);\n\n\n\n\n\n/**\n * Writer of geometry data of point labels.\n */\nclass PointLabelBufferWriter extends __WEBPACK_IMPORTED_MODULE_0__util_buffer_writer__[\"a\" /* default */] {\n    constructor() {\n        super(__WEBPACK_IMPORTED_MODULE_4__point_label_attribute_mapping__[\"a\" /* POINT_LABEL_ATTRIBUTE_MAPPING */].vertexByteSize);\n    }\n    /**\n     * Writes point label to buffers.\n     *\n     * @param id Label id.\n     * @param label Label to be written to buffers.\n     * @param style Style of the label, that directly affects written data.\n     * @param fontRegistry Registry of all system fonts, it should contain fonts used in this label styles.\n     * @param glyphAtlas Atlas of all system glyphs, it should contain glyphs used in this label.\n     *\n     * @returns Location of the data in buffers.\n     */\n    writePointLabel(id, label, style, layout, glyphAtlas) {\n        const idHigh = id >> 8;\n        const idLow = id & 0xff;\n        const position = label.anchorPoint;\n        const priority = Object(__WEBPACK_IMPORTED_MODULE_3__util_gputypes__[\"c\" /* int24ToFloat */])(label.priority);\n        for (const [textLayout, textStyle] of Object(__WEBPACK_IMPORTED_MODULE_1__util_iterable__[\"b\" /* zipIterables */])(layout, style.styles)) {\n            const textColorRgba8 = Object(__WEBPACK_IMPORTED_MODULE_2__util_color__[\"c\" /* encodeRgba8 */])(textStyle.color);\n            const outlineColorRgba8 = Object(__WEBPACK_IMPORTED_MODULE_2__util_color__[\"c\" /* encodeRgba8 */])(textStyle.outlineColor);\n            for (const glyph of textLayout) {\n                const allocatedGlyph = glyphAtlas.getGlyphLocation(glyph.fontId, glyph.glyphId);\n                const v1 = this._writeVertex(idHigh, idLow, position, glyph.topLeft, {\n                    x: allocatedGlyph.minX,\n                    y: allocatedGlyph.minY\n                }, textColorRgba8, outlineColorRgba8, priority, glyph.scale);\n                const v2 = this._writeVertex(idHigh, idLow, position, glyph.topRight, {\n                    x: allocatedGlyph.maxX,\n                    y: allocatedGlyph.minY\n                }, textColorRgba8, outlineColorRgba8, priority, glyph.scale);\n                const v3 = this._writeVertex(idHigh, idLow, position, glyph.bottomRight, {\n                    x: allocatedGlyph.maxX,\n                    y: allocatedGlyph.maxY\n                }, textColorRgba8, outlineColorRgba8, priority, glyph.scale);\n                const v4 = this._writeVertex(idHigh, idLow, position, glyph.bottomLeft, {\n                    x: allocatedGlyph.minX,\n                    y: allocatedGlyph.maxY\n                }, textColorRgba8, outlineColorRgba8, priority, glyph.scale);\n                this.writeIndices([v1, v2, v3, v1, v3, v4]);\n            }\n        }\n        return this.endMesh();\n    }\n    /**\n     * Writes a vertex to the vertex buffer. See attribute descriptions in the ATTRIBUTE_MAPPING property.\n     */\n    _writeVertex(idHigh, idLow, position, displacement, uv, colorRgba8, outlineColorRgba8, priority, scale) {\n        const vertexIdx = this.getCurrentVertexIdx();\n        this._writeBytes(idHigh, idLow, 0, 0);\n        this._writeWorldCoordinate(position);\n        this._writeFloat32(displacement.x);\n        this._writeFloat32(displacement.y);\n        this._writeHalfWords(uv.x, uv.y);\n        this._writeWord(colorRgba8);\n        this._writeWord(outlineColorRgba8);\n        this._writeFloat32(priority);\n        this._writeFloat32(scale);\n        return vertexIdx;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = PointLabelBufferWriter;\n\n\n\n/***/ }),\n/* 89 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(6);\n\n/** Description of how a writer stores vertex data. */\nconst POINT_LABEL_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__[\"a\" /* AttributeMapping */]([\n    [\n        2 /* ID */,\n        {\n            size: 4,\n            type: 5121 /* UNSIGNED_BYTE */,\n            normalized: true\n        }\n    ],\n    [\n        0 /* POSITION_HIGH */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        1 /* POSITION_LOW */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        6 /* DISPLACEMENT */,\n        {\n            size: 2,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        4 /* UV */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: false\n        }\n    ],\n    [\n        7 /* COLOR */,\n        {\n            size: 4,\n            type: 5121 /* UNSIGNED_BYTE */,\n            normalized: true\n        }\n    ],\n    [\n        8 /* OUTLINE_COLOR */,\n        {\n            size: 4,\n            type: 5121 /* UNSIGNED_BYTE */,\n            normalized: true\n        }\n    ],\n    [\n        9 /* PRIORITY */,\n        {\n            size: 1,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        11 /* AUX */,\n        {\n            size: 1,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ]\n]);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = POINT_LABEL_ATTRIBUTE_MAPPING;\n\n\n\n/***/ }),\n/* 90 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_gputypes__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_iterable__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_color__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__layout_curved_label__ = __webpack_require__(91);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__render_primitive_renderer_colliding_primitive_colliding_primitive_id_manager__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__util_polyline__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__curved_label_attribute_mapping__ = __webpack_require__(92);\n\n\n\n\n\n\n\n\n\nconst POLYLINE_SIDE_LENGTH = 2;\n/**\n * Writer of geometry data of curved labels.\n */\nclass CurvedLabelBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__[\"a\" /* default */] {\n    constructor() {\n        super(__WEBPACK_IMPORTED_MODULE_8__curved_label_attribute_mapping__[\"a\" /* CURVED_LABEL_ATTRIBUTE_MAPPING */].vertexByteSize);\n    }\n    /**\n     * Writes curved label to buffers.\n     *\n     * @param label Label to be written to buffers.\n     * @param style Style of the label, that directly affects written data.\n     * @param fontRegistry Registry of all system fonts, it should contain fonts used in this label styles.\n     * @param glyphAtlas Atlas of all system glyphs, it should contain glyphs used in this label.\n     *\n     * @returns Location of the data in buffers.\n     */\n    writeLabel(label, style, fontRegistry, glyphAtlas) {\n        const id = __WEBPACK_IMPORTED_MODULE_6__render_primitive_renderer_colliding_primitive_colliding_primitive_id_manager__[\"a\" /* default */].getId();\n        const idHigh = id >> 8;\n        const idLow = id & 0xff;\n        const textLayouts = Object(__WEBPACK_IMPORTED_MODULE_5__layout_curved_label__[\"a\" /* default */])(label, style, fontRegistry);\n        const priority = Object(__WEBPACK_IMPORTED_MODULE_2__util_gputypes__[\"c\" /* int24ToFloat */])(label.priority);\n        // To make layouting on GPU possible guiding polyline should be splitted on left/right parts,\n        // mid point of the polyline is used to anchor the label. This information is not changed at runtime and\n        // simplifies calculations in shaders.\n        const polyline = Object(__WEBPACK_IMPORTED_MODULE_7__util_polyline__[\"b\" /* splitPolyline */])(label.polyline);\n        const midPoint = polyline[1][0];\n        polyline[0].reverse(); // left part must be reversed to write both parts alike\n        for (const polylinePart of polyline) {\n            const maxIndex = Math.min(polylinePart.length, POLYLINE_SIDE_LENGTH + 1);\n            for (let i = 1; i < maxIndex; i++) {\n                // write polyline vertex as delta to the mid point to get reasonable precision from float\n                __WEBPACK_IMPORTED_MODULE_0__math_vector2__[\"p\" /* sub */](polylinePart[i], midPoint, polylinePart[i]);\n            }\n        }\n        for (const [textLayout, textStyle] of Object(__WEBPACK_IMPORTED_MODULE_3__util_iterable__[\"b\" /* zipIterables */])(textLayouts, style.styles)) {\n            const textColorRgba8 = Object(__WEBPACK_IMPORTED_MODULE_4__util_color__[\"c\" /* encodeRgba8 */])(textStyle.color);\n            const outlineColorRgba8 = Object(__WEBPACK_IMPORTED_MODULE_4__util_color__[\"c\" /* encodeRgba8 */])(textStyle.outlineColor);\n            for (const glyph of textLayout) {\n                const allocatedGlyph = glyphAtlas.getGlyphLocation(glyph.fontId, glyph.glyphId);\n                const v1 = this._writeVertex(idHigh, idLow, midPoint, glyph.topLeft, {\n                    x: allocatedGlyph.minX,\n                    y: allocatedGlyph.minY\n                }, textColorRgba8, outlineColorRgba8, priority, glyph.lineDisplacement, polyline, glyph.scale);\n                const v2 = this._writeVertex(idHigh, idLow, midPoint, glyph.topRight, {\n                    x: allocatedGlyph.maxX,\n                    y: allocatedGlyph.minY\n                }, textColorRgba8, outlineColorRgba8, priority, glyph.lineDisplacement, polyline, glyph.scale);\n                const v3 = this._writeVertex(idHigh, idLow, midPoint, glyph.bottomRight, {\n                    x: allocatedGlyph.maxX,\n                    y: allocatedGlyph.maxY\n                }, textColorRgba8, outlineColorRgba8, priority, glyph.lineDisplacement, polyline, glyph.scale);\n                const v4 = this._writeVertex(idHigh, idLow, midPoint, glyph.bottomLeft, {\n                    x: allocatedGlyph.minX,\n                    y: allocatedGlyph.maxY\n                }, textColorRgba8, outlineColorRgba8, priority, glyph.lineDisplacement, polyline, glyph.scale);\n                this.writeIndices([v1, v2, v3, v1, v3, v4]);\n            }\n        }\n        return this.endMesh();\n    }\n    /**\n     * Writes a vertex to the vertex buffer. See attribute descriptions in the ATTRIBUTE_MAPPING property.\n     */\n    _writeVertex(idHigh, idLow, position, displacement, uv, colorRgba8, outlineColorRgba8, priority, lineDisplacement, polyline, scale) {\n        const vertexIdx = this.getCurrentVertexIdx();\n        this._writeBytes(idHigh, idLow, 0, 0);\n        this._writeWorldCoordinate(position);\n        this._writeFloat32(displacement.x);\n        this._writeFloat32(displacement.y);\n        this._writeFloat32(lineDisplacement);\n        this._writeHalfWords(uv.x, uv.y);\n        this._writeWord(colorRgba8);\n        this._writeWord(outlineColorRgba8);\n        this._writeFloat32(priority);\n        for (const polylinePart of polyline) {\n            for (let i = 1; i <= POLYLINE_SIDE_LENGTH; i++) {\n                const delta = polylinePart[i];\n                this._writeFloat32(delta ? delta.x : 0);\n                this._writeFloat32(delta ? delta.y : 0);\n            }\n        }\n        this._writeFloat32(scale);\n        return vertexIdx;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = CurvedLabelBufferWriter;\n\n\n\n/***/ }),\n/* 91 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = layoutCurvedLabel;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_array__ = __webpack_require__(13);\n\n/**\n * Label layouting is done partially on CPU and partially on GPU. This helper method is responsible for the CPU part,\n * it calculates glyph's corner positions on a straight line, that will lay on a curved  polyline later in GPU.\n * All the metrics are given in pixels.\n *\n * @returns Position of each glyph for each text separately.\n */\nfunction layoutCurvedLabel(label, labelStyle, fontRegistry) {\n    const layout = [];\n    let lineDisplacement = 0;\n    for (const [text, style] of Object(__WEBPACK_IMPORTED_MODULE_0__util_array__[\"d\" /* zip */])(label.texts, labelStyle.styles)) {\n        const textLayout = [];\n        const font = fontRegistry.get(style.fontId);\n        const scale = style.fontSize / font.xheight;\n        const baselineOffset = style.fontSize / 2;\n        for (const line of text.textLines) {\n            for (const glyphId of line.glyphIds) {\n                const glyph = font.getGlyph(glyphId);\n                const top = (glyph.bearingY + font.margin) * scale;\n                const bottom = (glyph.bearingY - glyph.height - font.margin) * scale;\n                const left = (glyph.bearingX - font.margin) * scale;\n                const right = (glyph.bearingX + glyph.width + font.margin) * scale;\n                const widthHalf = (right - left) / 2;\n                const leftShifted = left - widthHalf;\n                const rightShifted = right - widthHalf;\n                const topShifted = top - baselineOffset;\n                const bottomShifted = bottom - baselineOffset;\n                textLayout.push({\n                    fontId: font.id,\n                    glyphId: glyphId,\n                    scale,\n                    topLeft: { x: leftShifted, y: topShifted },\n                    topRight: { x: rightShifted, y: topShifted },\n                    bottomRight: { x: rightShifted, y: bottomShifted },\n                    bottomLeft: { x: leftShifted, y: bottomShifted },\n                    lineDisplacement: lineDisplacement + widthHalf\n                });\n                lineDisplacement += glyph.advance * scale;\n            }\n        }\n        lineDisplacement += labelStyle.distance;\n        layout.push(textLayout);\n    }\n    // remove trailing style distance (added at the end of each text above), as it must be in between texts only\n    lineDisplacement -= labelStyle.distance;\n    const lineDisplacementHalf = lineDisplacement / 2;\n    for (const textLayout of layout) {\n        for (const glyphLayout of textLayout) {\n            glyphLayout.lineDisplacement -= lineDisplacementHalf;\n        }\n    }\n    return layout;\n}\n\n\n/***/ }),\n/* 92 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(6);\n\n/** Description of how a writer stores vertex data. */\nconst CURVED_LABEL_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__[\"a\" /* AttributeMapping */]([\n    [\n        2 /* ID */,\n        {\n            size: 4,\n            type: 5121 /* UNSIGNED_BYTE */,\n            normalized: true\n        }\n    ],\n    [\n        0 /* POSITION_HIGH */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        1 /* POSITION_LOW */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: true\n        }\n    ],\n    [\n        6 /* DISPLACEMENT */,\n        {\n            size: 3,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        4 /* UV */,\n        {\n            size: 2,\n            type: 5123 /* UNSIGNED_SHORT */,\n            normalized: false\n        }\n    ],\n    [\n        7 /* COLOR */,\n        {\n            size: 4,\n            type: 5121 /* UNSIGNED_BYTE */,\n            normalized: true\n        }\n    ],\n    [\n        8 /* OUTLINE_COLOR */,\n        {\n            size: 4,\n            type: 5121 /* UNSIGNED_BYTE */,\n            normalized: true\n        }\n    ],\n    [\n        9 /* PRIORITY */,\n        {\n            size: 1,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        12 /* AUX1 */,\n        {\n            size: 2,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        13 /* AUX2 */,\n        {\n            size: 2,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        14 /* AUX3 */,\n        {\n            size: 2,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        15 /* AUX4 */,\n        {\n            size: 2,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ],\n    [\n        11 /* AUX */,\n        {\n            size: 1,\n            type: 5126 /* FLOAT */,\n            normalized: false\n        }\n    ]\n]);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = CURVED_LABEL_ATTRIBUTE_MAPPING;\n\n\n\n/***/ }),\n/* 93 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = calculatePointLabelBBox;\n/**\n * Calculates bbox of a layouted label, it just find the left/right/top/bottom-most points and adds paddings.\n */\nfunction calculatePointLabelBBox(layout, verticalPadding, horizontalPadding) {\n    const bbox = {\n        minX: Number.MAX_VALUE,\n        maxX: -Number.MAX_VALUE,\n        minY: Number.MAX_VALUE,\n        maxY: -Number.MAX_VALUE\n    };\n    for (const textLayout of layout) {\n        for (const glyphLayout of textLayout) {\n            bbox.minX = Math.min(bbox.minX, glyphLayout.topLeft.x);\n            bbox.maxX = Math.max(bbox.maxX, glyphLayout.topRight.x);\n            bbox.minY = Math.min(bbox.minY, glyphLayout.bottomLeft.y);\n            bbox.maxY = Math.max(bbox.maxY, glyphLayout.topLeft.y);\n        }\n    }\n    bbox.minX -= horizontalPadding;\n    bbox.maxX += horizontalPadding;\n    bbox.minY -= verticalPadding;\n    bbox.maxY += verticalPadding;\n    return bbox;\n}\n\n\n/***/ }),\n/* 94 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__trimesh_parse_trimesh__ = __webpack_require__(95);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_scalar__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__primitive_model_model_buffer_writer__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_color__ = __webpack_require__(0);\n\n\n\n\n/**\n * Buffer writer that writes trimesh object into common mesh buffers.\n */\nclass TrimeshPolygonBufferWriter extends __WEBPACK_IMPORTED_MODULE_2__primitive_model_model_buffer_writer__[\"a\" /* default */] {\n    /**\n     * Writes a mesh from raw trimesh file data. Uses parseTrimesh() utility function\n     * to get vertices and write them in correct order.\n     *\n     * @param data Raw (unzipped) trimesh file data.\n     * @param mesh Description of the mesh in the world space.\n     * @returns The location of the mesh in a buffer.\n     */\n    writeModel(data, mesh, color) {\n        this._currentMesh = mesh;\n        this._currentColor = Object(__WEBPACK_IMPORTED_MODULE_3__util_color__[\"c\" /* encodeRgba8 */])(color);\n        let prevManifoldLocation;\n        for (const manifoldLocation of Object(__WEBPACK_IMPORTED_MODULE_0__trimesh_parse_trimesh__[\"a\" /* parseTrimesh */])(data, this)) {\n            if (prevManifoldLocation) {\n                // manifolds are written consequently, it allows to \"accumulate\" vertices and return\n                // the location of the first one and the sum of the lengths\n                if (prevManifoldLocation.bufferIndex === manifoldLocation.bufferIndex) {\n                    prevManifoldLocation.vertexByteLength += manifoldLocation.vertexByteLength;\n                    prevManifoldLocation.indexByteLength += manifoldLocation.indexByteLength;\n                }\n                else {\n                    // return the first portion, very large (~65k vertices) object will be truncated\n                    // TODO: consider support of such objects\n                    break;\n                }\n            }\n            else {\n                prevManifoldLocation = manifoldLocation;\n            }\n        }\n        return prevManifoldLocation;\n    }\n    /**\n     * Stores converted to world space vertices to refer them later in indices writing.\n     */\n    writeVertex(vertex) {\n        const mesh = this._currentMesh;\n        if (mesh) {\n            const bbox = mesh.bbox;\n            vertex.x = __WEBPACK_IMPORTED_MODULE_1__math_scalar__[\"b\" /* mix */](bbox.minX, bbox.maxX, vertex.x);\n            vertex.y = __WEBPACK_IMPORTED_MODULE_1__math_scalar__[\"b\" /* mix */](bbox.minY, bbox.maxY, vertex.y);\n            vertex.z = __WEBPACK_IMPORTED_MODULE_1__math_scalar__[\"b\" /* mix */](bbox.maxZ, bbox.minZ, vertex.z);\n            return this._writeVertex(vertex, this._currentColor);\n        }\n        else {\n            return -1;\n        }\n    }\n    /**\n     * Finishes current manifold and returns its location in a buffer.\n     */\n    flush() {\n        return this.endMesh();\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = TrimeshPolygonBufferWriter;\n\n\n\n/***/ }),\n/* 95 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = parseTrimesh;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__file_reader__ = __webpack_require__(96);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_manifold__ = __webpack_require__(98);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vertex_decoder__ = __webpack_require__(100);\n\n\n\n/**\n * Streaming parser of a trimesh file. It writes the model into an abstract output buffer, that have to manage\n * vertices storing. The model can be quite big, that is why it is flushed out by portions (manifolds) that could\n * be placed into separate buffers.\n * The format overview and motivation see here: https://wiki.yandex-team.ru/maps/dev/core/renderer/vec3d/.\n */\nfunction* parseTrimesh(data, output) {\n    const reader = new __WEBPACK_IMPORTED_MODULE_0__file_reader__[\"a\" /* default */](data);\n    const decoder = new __WEBPACK_IMPORTED_MODULE_2__vertex_decoder__[\"a\" /* default */](reader.header.precision);\n    while (reader.hasCommands()) {\n        yield Object(__WEBPACK_IMPORTED_MODULE_1__parse_manifold__[\"a\" /* parseManifold */])(reader, decoder, output);\n    }\n}\n\n\n/***/ }),\n/* 96 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector3__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(18);\n\n\nconst VALENCE_BIAS = {\n    [0 /* ADD */]: 3,\n    [1 /* HOLE */]: 3,\n    [2 /* SPLIT */]: 1,\n    [3 /* MERGE */]: 1\n};\nconst HEADER_BYTE_SIZE = 13;\n/**\n * Parses raw trimesh file data. See the format described here:\n * https://wiki.yandex-team.ru/maps/dev/core/renderer/vec3d/#strukturafajjla.\n */\nclass FileReader {\n    constructor(data) {\n        this._view = new DataView(data);\n        this.header = {\n            signature: this._view.getUint32(0, true),\n            nCmdAdd: this._view.getUint32(4, true),\n            nCmdEtc: this._view.getUint16(8, true),\n            nAux: this._view.getUint16(10, true),\n            precision: this._view.getUint8(12)\n        };\n        this._auxOffset = HEADER_BYTE_SIZE;\n        this._cmdOffset = this._auxOffset + this.header.nAux * 2;\n        this._diffOffset = this._cmdOffset + this.header.nCmdAdd + this.header.nCmdEtc;\n        this._cmdEnd = this._diffOffset;\n    }\n    /**\n     * @returns The next command and increases the command cursor.\n     */\n    readCommand(dst = { type: 0 /* ADD */, valence: 0, shift: 0 }) {\n        const commandPacked = this._view.getUint8(this._cmdOffset++);\n        const type = commandPacked & 0b11;\n        let valence = commandPacked >> 2;\n        valence = valence !== 0 ? valence - 1 : this._readAux() + 62;\n        valence += VALENCE_BIAS[type];\n        const shift = type === 2 /* SPLIT */ || type === 3 /* MERGE */ ? this._readAux() : 0;\n        dst.type = type;\n        dst.valence = valence;\n        dst.shift = shift;\n        return dst;\n    }\n    /**\n     * @returns The next diff and increases the diff cursor.\n     */\n    readDiff(dst = __WEBPACK_IMPORTED_MODULE_0__math_vector3__[\"c\" /* create */](0, 0, 0)) {\n        dst.x = this._readDiff(this._diffOffset + this.header.nCmdAdd * 3, this._diffOffset + this.header.nCmdAdd * 0);\n        dst.y = this._readDiff(this._diffOffset + this.header.nCmdAdd * 4, this._diffOffset + this.header.nCmdAdd * 1);\n        dst.z = this._readDiff(this._diffOffset + this.header.nCmdAdd * 5, this._diffOffset + this.header.nCmdAdd * 2);\n        this._diffOffset++;\n        return dst;\n    }\n    /**\n     * @returns Is there command unread.\n     */\n    hasCommands() {\n        return this._cmdOffset < this._cmdEnd;\n    }\n    _readAux() {\n        const low = this._view.getUint8(this._auxOffset);\n        const high = this._view.getUint8(this._auxOffset + this.header.nAux);\n        const aux = (high << 8) | low;\n        this._auxOffset++;\n        return aux;\n    }\n    _readDiff(highPartIndex, lowPartIndex) {\n        return Object(__WEBPACK_IMPORTED_MODULE_1__utils__[\"e\" /* zigZagUnpack */])(this._view.getUint8(highPartIndex) << 8 |\n            this._view.getUint8(lowPartIndex));\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = FileReader;\n\n\n\n/***/ }),\n/* 97 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export create */\n/* unused harmony export zero */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = fromRows;\n/* unused harmony export columns */\n/* unused harmony export fromColumns */\n/* unused harmony export determinant */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = solve;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector3__ = __webpack_require__(10);\n\nconst MATRIX_SIZE = 9;\n/**\n * Creates and returns a new **uninitialized** matrix.\n */\nfunction create() {\n    return new Array(MATRIX_SIZE);\n}\n/**\n * Zeroes a matrix.\n *\n * @param dst The matrix.\n * @returns `dst`.\n */\nfunction zero(dst = create()) {\n    for (let i = 0; i < MATRIX_SIZE; ++i) {\n        dst[i] = 0;\n    }\n    return dst;\n}\n/**\n * Copies three vectors to a matrix as rows.\n *\n * @param r0 The first row.\n * @param r1 The second row.\n * @param r2 The third row.\n * @param dst The matrix the rows will be written to.\n * @returns `dst`.\n */\nfunction fromRows(r0, r1, r2, dst = create()) {\n    dst[0] = r0.x;\n    dst[1] = r1.x;\n    dst[2] = r2.x;\n    dst[3] = r0.y;\n    dst[4] = r1.y;\n    dst[5] = r2.y;\n    dst[6] = r0.z;\n    dst[7] = r1.z;\n    dst[8] = r2.z;\n    return dst;\n}\n/**\n * Returns array of columns of a matrix.\n *\n * @param m The matrix.\n * @param dst The array columns of the matrix will be written to.\n * @returns `dst`.\n */\nfunction columns(m, dst = [\n    __WEBPACK_IMPORTED_MODULE_0__vector3__[\"c\" /* create */](0, 0, 0),\n    __WEBPACK_IMPORTED_MODULE_0__vector3__[\"c\" /* create */](0, 0, 0),\n    __WEBPACK_IMPORTED_MODULE_0__vector3__[\"c\" /* create */](0, 0, 0)\n]) {\n    for (let i = 0, j = 0; i < 3; ++i, j += 3) {\n        dst[i].x = m[j];\n        dst[i].y = m[j + 1];\n        dst[i].z = m[j + 2];\n    }\n    return dst;\n}\n/**\n * Copies three vectors to a matrix as columns.\n *\n * @param c0 The first column.\n * @param c1 The second column.\n * @param c2 The third column.\n * @param dst The matrix the columns will be written to.\n * @returns `dst`.\n */\nfunction fromColumns(c0, c1, c2, dst = create()) {\n    dst[0] = c0.x;\n    dst[1] = c0.y;\n    dst[2] = c0.z;\n    dst[3] = c1.x;\n    dst[4] = c1.y;\n    dst[5] = c1.z;\n    dst[6] = c2.x;\n    dst[7] = c2.y;\n    dst[8] = c2.z;\n    return dst;\n}\n/**\n * Computes determinant of a matrix.\n *\n * @param m The matrix.\n * @returns The determinant.\n */\nfunction determinant(m) {\n    return m[0] * (m[4] * m[8] - m[7] * m[5]) +\n        m[3] * (m[1] * m[8] - m[7] * m[2]) +\n        m[6] * (m[1] * m[5] - m[4] * m[2]);\n}\nconst staticMatrixColumns = [\n    // Not using vector3.create here due to circular dependency.\n    { x: 0, y: 0, z: 0 },\n    { x: 0, y: 0, z: 0 },\n    { x: 0, y: 0, z: 0 }\n];\nconst staticMatrix = create();\n/**\n * Solves a system of linear equations represented with a matrix and a vector,\n * i.e.:\n *\n * ```\n * m * (x, y ,z)^T = v\n * ```\n *\n * Uses Cramer's rule.\n * @see https://en.wikipedia.org/wiki/Cramer's_rule\n *\n * @param m The matrix of the system.\n * @param v The vector of the system.\n * @param dst The vector solution of the system will be written to.\n * @return `dst`.\n */\nfunction solve(m, v, dst = __WEBPACK_IMPORTED_MODULE_0__vector3__[\"c\" /* create */](0, 0, 0)) {\n    const revDet = 1 / determinant(m);\n    const [c0, c1, c2] = columns(m, staticMatrixColumns);\n    dst.x = revDet * determinant(fromColumns(v, c1, c2, staticMatrix));\n    dst.y = revDet * determinant(fromColumns(c0, v, c2, staticMatrix));\n    dst.z = revDet * determinant(fromColumns(c0, c1, v, staticMatrix));\n    return dst;\n}\n\n\n/***/ }),\n/* 98 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = parseManifold;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector3__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_array__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__node__ = __webpack_require__(99);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils__ = __webpack_require__(18);\n\n\n\n\nconst tmpDiff = __WEBPACK_IMPORTED_MODULE_0__math_vector3__[\"c\" /* create */](0, 0, 0);\nconst tmpVertex = __WEBPACK_IMPORTED_MODULE_0__math_vector3__[\"c\" /* create */](0, 0, 0);\nconst tmpCommand = { type: 0 /* ADD */, valence: 0, shift: 0 };\n/**\n * Writes vertices of three node into the output buffer if the is no a hole node between them.\n */\nfunction writeTriangle(node1, node2, node3, output) {\n    if (!__WEBPACK_IMPORTED_MODULE_2__node__[\"a\" /* HoleNode */].isHoleNode(node1) &&\n        !__WEBPACK_IMPORTED_MODULE_2__node__[\"a\" /* HoleNode */].isHoleNode(node2) &&\n        !__WEBPACK_IMPORTED_MODULE_2__node__[\"a\" /* HoleNode */].isHoleNode(node3)) {\n        output.writeIndices([node1.index, node2.index, node3.index]);\n    }\n}\n/**\n * Each manifold restoring starts with a triangle. This function read the first three vertices, forms a triangle\n * of them and return this initialized node ring to be processed further.\n */\nfunction getInitTriangle(reader, decoder, output) {\n    const vertex = __WEBPACK_IMPORTED_MODULE_0__math_vector3__[\"c\" /* create */](0, 0, 0);\n    const ring = new Array(3);\n    for (let i = 0; i < 3; i++) {\n        const command = reader.readCommand();\n        if (command.type == 1 /* HOLE */) {\n            ring[i] = new __WEBPACK_IMPORTED_MODULE_2__node__[\"a\" /* HoleNode */](command.valence);\n        }\n        else if (command.type == 0 /* ADD */) {\n            reader.readDiff(tmpDiff);\n            __WEBPACK_IMPORTED_MODULE_0__math_vector3__[\"a\" /* add */](vertex, tmpDiff, vertex);\n            ring[i] = new __WEBPACK_IMPORTED_MODULE_2__node__[\"b\" /* default */](command.valence, __WEBPACK_IMPORTED_MODULE_0__math_vector3__[\"b\" /* copy */](vertex), output.writeVertex(decoder.decode(vertex)));\n        }\n    }\n    for (let i = 0; i < ring.length; i++) {\n        ring[i].setNeighbors(Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"a\" /* cyclicNext */])(ring, i), Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"c\" /* cyclicPrev */])(ring, i));\n    }\n    writeTriangle(ring[0], ring[1], ring[2], output);\n    return ring;\n}\nconst spanComparator = (a, b) => a - b;\n/**\n * Removes finished (with all edges processed) nodes from the active ring before processing the next command.\n */\nfunction prepareActiveRing(ring, output) {\n    const spans = new Array(ring.length);\n    for (let i = 0, unprocessedNodes = ring.length; unprocessedNodes > 0;) {\n        spans[i] = ring[i].calculateSpan(Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"c\" /* cyclicPrev */])(ring, i), Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"a\" /* cyclicNext */])(ring, i));\n        if (spans[i] > 1) {\n            i = Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"b\" /* cyclicNextIndex */])(ring, i);\n            unprocessedNodes--;\n        }\n        else if (spans[i] === 1) {\n            const node1 = ring[i];\n            const node2 = Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"c\" /* cyclicPrev */])(ring, i);\n            const node3 = Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"a\" /* cyclicNext */])(ring, i);\n            node3.setAfter(node1, node2);\n            node2.setBefore(node1, node3);\n            writeTriangle(node1, node2, node3, output);\n            for (let j = i; j < spans.length - 1; j++) {\n                spans[j] = spans[j + 1];\n            }\n            ring.splice(i, 1);\n            i = Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"d\" /* cyclicPrevIndex */])(ring, i);\n            unprocessedNodes++;\n        }\n        else {\n            __WEBPACK_IMPORTED_MODULE_1__util_array__[\"b\" /* rotate */](ring, ring.length - Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"b\" /* cyclicNextIndex */])(ring, i));\n            ring.splice(ring.length - 2, 2);\n            i = 0;\n            unprocessedNodes = ring.length;\n        }\n        if (ring.length < 3) {\n            return;\n        }\n    }\n    let minIndex = 0;\n    let min = [spans[minIndex], spans[Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"d\" /* cyclicPrevIndex */])(ring, minIndex)], spans[Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"b\" /* cyclicNextIndex */])(ring, minIndex)]];\n    for (let i = 1; i < ring.length; i++) {\n        const triangleSpans = [spans[i], spans[Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"d\" /* cyclicPrevIndex */])(ring, i)], spans[Object(__WEBPACK_IMPORTED_MODULE_3__utils__[\"b\" /* cyclicNextIndex */])(ring, i)]];\n        if (__WEBPACK_IMPORTED_MODULE_1__util_array__[\"a\" /* compare */](spanComparator, triangleSpans, min) < 0) {\n            min = triangleSpans;\n            minIndex = i;\n        }\n    }\n    __WEBPACK_IMPORTED_MODULE_1__util_array__[\"b\" /* rotate */](ring, ring.length - minIndex);\n}\n/**\n * Writes triangle that arises from the next node using the two ends of the active ring.\n */\nfunction closeTriangle(output, front, back, add, dist, base) {\n    add.setNeighbors(front, back, dist, base);\n    front.setAfter(back, add);\n    back.setBefore(front, add);\n    writeTriangle(add, front, back, output);\n}\n/**\n * Process the next command.\n */\nfunction processCommand(cmd, queue, reader, decoder, output) {\n    const active = queue[0];\n    const front = active[0];\n    const back = active[active.length - 1];\n    switch (cmd.type) {\n        case 0 /* ADD */: {\n            const m = front.getPrevNeighbor(back);\n            let base;\n            if (__WEBPACK_IMPORTED_MODULE_2__node__[\"a\" /* HoleNode */].isHoleNode(front) || __WEBPACK_IMPORTED_MODULE_2__node__[\"a\" /* HoleNode */].isHoleNode(back) || __WEBPACK_IMPORTED_MODULE_2__node__[\"a\" /* HoleNode */].isHoleNode(m)) {\n                base = __WEBPACK_IMPORTED_MODULE_2__node__[\"a\" /* HoleNode */].isHoleNode(front) ? back.vertex : front.vertex;\n            }\n            else {\n                // diff is a diff to predicted position:\n                // https://wiki.yandex-team.ru/maps/dev/core/renderer/vec3d/#geometrijaupakovkakoordinatvershin\n                __WEBPACK_IMPORTED_MODULE_0__math_vector3__[\"a\" /* add */](back.vertex, front.vertex, tmpVertex);\n                __WEBPACK_IMPORTED_MODULE_0__math_vector3__[\"d\" /* sub */](tmpVertex, m.vertex, tmpVertex);\n                decoder.clamp(tmpVertex, tmpVertex);\n                base = tmpVertex;\n            }\n            reader.readDiff(tmpDiff);\n            __WEBPACK_IMPORTED_MODULE_0__math_vector3__[\"a\" /* add */](base, tmpDiff, tmpVertex);\n            const vertex = __WEBPACK_IMPORTED_MODULE_0__math_vector3__[\"b\" /* copy */](tmpVertex);\n            const vertexDecoded = decoder.decode(vertex);\n            const node = new __WEBPACK_IMPORTED_MODULE_2__node__[\"b\" /* default */](cmd.valence, vertex, output.writeVertex(vertexDecoded));\n            closeTriangle(output, front, back, node, 0);\n            active.push(node);\n            break;\n        }\n        case 1 /* HOLE */: {\n            const node = new __WEBPACK_IMPORTED_MODULE_2__node__[\"a\" /* HoleNode */](cmd.valence);\n            closeTriangle(output, front, back, node, 0);\n            active.push(node);\n            break;\n        }\n        case 2 /* SPLIT */: {\n            const add = cmd.shift;\n            closeTriangle(output, front, back, active[add], cmd.valence, active[add - 1]);\n            queue.push(active.slice(0, add + 1));\n            active.splice(0, add);\n            break;\n        }\n        case 3 /* MERGE */: {\n            let other = 1;\n            for (; other !== queue.length && queue[other].length <= cmd.shift; other++) {\n                cmd.shift -= queue[other].length;\n            }\n            __WEBPACK_IMPORTED_MODULE_1__util_array__[\"b\" /* rotate */](queue[other], queue[other].length - cmd.shift);\n            const add = queue[other][0];\n            closeTriangle(output, front, back, add, cmd.valence, queue[other][queue[other].length - 1]);\n            queue[other].push(queue[other][0]);\n            active.splice(0, 0, ...queue[other]);\n            queue.splice(other, 1);\n            break;\n        }\n    }\n}\n/**\n * Read a portion of the model (manifold) from the file and writes vertices/triangles into the output.\n */\nfunction parseManifold(reader, decoder, output) {\n    const ring = getInitTriangle(reader, decoder, output);\n    const queue = [ring];\n    while (queue.length !== 0) {\n        // active ring is the first element int the queue\n        prepareActiveRing(queue[0], output);\n        while (queue[0].length > 2) {\n            processCommand(reader.readCommand(tmpCommand), queue, reader, decoder, output);\n            prepareActiveRing(queue[0], output);\n        }\n        queue.shift();\n    }\n    return output.flush();\n}\n\n\n/***/ }),\n/* 99 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector3__ = __webpack_require__(10);\n\n\n/**\n * A node of the model mesh. Basically it is a vertex, but also contains some intermediate data to\n * restore the mesh during parsing.\n */\nclass Node {\n    /**\n     * @param valence Number adjacent vertices.\n     * @param vertex Coordinates of the node.\n     * @param index Position of the vertex in a storage (like GL buffer or an intermediate array buffer).\n     */\n    constructor(valence, vertex, index) {\n        this.vertex = vertex;\n        this.index = index;\n        this._neighbours = new Array(valence).fill(undefined);\n    }\n    /**\n     * @returns Distance between two neighbors in the node's neighbors list.\n     */\n    calculateSpan(a, b) {\n        const aIndex = this._neighbours.indexOf(a);\n        const bIndex = this._neighbours.indexOf(b);\n        return (this._neighbours.length + (bIndex - aIndex)) % this._neighbours.length;\n    }\n    /**\n     * Sets two neighbors that forms a triangle with the current one.\n     */\n    setNeighbors(a, b, span = 0, prev) {\n        let index = (this._neighbours.indexOf(prev) + span) % this._neighbours.length;\n        this._neighbours[index] = a;\n        index = Object(__WEBPACK_IMPORTED_MODULE_0__utils__[\"b\" /* cyclicNextIndex */])(this._neighbours, index);\n        this._neighbours[index] = b;\n    }\n    /**\n     * Sets a neighbor before the specified one.\n     */\n    setBefore(next, val) {\n        const index = this._neighbours.indexOf(next);\n        this._neighbours[Object(__WEBPACK_IMPORTED_MODULE_0__utils__[\"d\" /* cyclicPrevIndex */])(this._neighbours, index)] = val;\n    }\n    /**\n     * Sets a neighbor next to the specified one.\n     */\n    setAfter(prev, val) {\n        const index = this._neighbours.indexOf(prev);\n        this._neighbours[Object(__WEBPACK_IMPORTED_MODULE_0__utils__[\"b\" /* cyclicNextIndex */])(this._neighbours, index)] = val;\n    }\n    /**\n     * @returns Neighbor previous to the specified one.\n     */\n    getPrevNeighbor(val) {\n        const index = this._neighbours.indexOf(val);\n        return Object(__WEBPACK_IMPORTED_MODULE_0__utils__[\"c\" /* cyclicPrev */])(this._neighbours, index);\n    }\n    /**\n     * @returns Neighbor next to the specified one.\n     */\n    getNextNeighbor(val) {\n        const index = this._neighbours.indexOf(val);\n        return Object(__WEBPACK_IMPORTED_MODULE_0__utils__[\"a\" /* cyclicNext */])(this._neighbours, index);\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = Node;\n\nconst STUB_HOLE_NODE_VERTEX = __WEBPACK_IMPORTED_MODULE_1__math_vector3__[\"c\" /* create */](-1, -1, -1);\nconst STUB_HOLE_NODE_INDEX = -1;\n/**\n * A special type of nodes that do not represent a real vertex (and is not supposed to be written into a buffer),\n * but required to support the mesh structure.\n */\nclass HoleNode extends Node {\n    constructor(valence) {\n        super(valence, STUB_HOLE_NODE_VERTEX, STUB_HOLE_NODE_INDEX);\n    }\n    static isHoleNode(node) {\n        return node instanceof HoleNode;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = HoleNode;\n\n\n\n/***/ }),\n/* 100 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector3__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_scalar__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_gputypes__ = __webpack_require__(3);\n\n\n\n/**\n * Vertex components are encoded in two bytes with specified precision to facilitate better compression.\n * This decoder translate those values into floats.\n */\nclass VertexDecoder {\n    constructor(precision) {\n        this._precisionXY = precision & 0xF;\n        this._precisionZ = precision >> 4;\n        this._shiftXY = 16 - this._precisionXY;\n        this._shiftZ = 16 - this._precisionZ;\n        this._maxXY = (1 << this._precisionXY) - 1;\n        this._maxZ = (1 << this._precisionZ) - 1;\n    }\n    /**\n     * @returns Vector with components clamped to their max values.\n     */\n    clamp(vertex, dst = __WEBPACK_IMPORTED_MODULE_0__math_vector3__[\"c\" /* create */](0, 0, 0)) {\n        dst.x = Object(__WEBPACK_IMPORTED_MODULE_1__math_scalar__[\"a\" /* clamp */])(vertex.x, 0, this._maxXY);\n        dst.y = Object(__WEBPACK_IMPORTED_MODULE_1__math_scalar__[\"a\" /* clamp */])(vertex.y, 0, this._maxXY);\n        dst.z = Object(__WEBPACK_IMPORTED_MODULE_1__math_scalar__[\"a\" /* clamp */])(vertex.z, 0, this._maxZ);\n        return dst;\n    }\n    /**\n     * @param vertex Encoded vertex.\n     * @param dst The output vector.\n     * @returns Decoded vertex (components are adjusted by the precision and converted into floats)\n     */\n    decode(vertex, dst = __WEBPACK_IMPORTED_MODULE_0__math_vector3__[\"c\" /* create */](0, 0, 0)) {\n        dst.x = VertexDecoder._decode(vertex.x, this._precisionXY, this._shiftXY);\n        dst.y = VertexDecoder._decode(vertex.y, this._precisionXY, this._shiftXY);\n        dst.z = VertexDecoder._decode(vertex.z, this._precisionZ, this._shiftZ);\n        return dst;\n    }\n    static _decode(value, precision, shift) {\n        value = value << shift;\n        value |= value >> precision;\n        value = Object(__WEBPACK_IMPORTED_MODULE_2__util_gputypes__[\"d\" /* uint16ToFloat */])(value);\n        return value;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = VertexDecoder;\n\n\n\n/***/ }),\n/* 101 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = appendToBatch;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = batchAllocatedObjects;\n/**\n * Appends portion of memory to batch if they are adjacent.\n *\n * @returns `true` if both params are adjacent and the batch was successfully updated, `false` otherwise.\n */\nfunction appendToBatch(memoryLocation, batch) {\n    if (batch.vertexByteOffset + batch.vertexByteLength === memoryLocation.vertexByteOffset &&\n        batch.indexByteOffset + batch.indexByteLength === memoryLocation.indexByteOffset) {\n        batch.vertexByteLength += memoryLocation.vertexByteLength;\n        batch.indexByteLength += memoryLocation.indexByteLength;\n        return true;\n    }\n    return false;\n}\n/**\n * Combines objects allocated in memory into batches. No sorting is done in this method, the objects are supposed\n * to be sorted by index/vertex offsets to make batching effective. The batch is created by factory since it can\n * contains problem specific information.\n *\n * @param objects List of allocated objects.\n * @param getMemoryLocation Returns memory location of specific object.\n * @param createBatch Initiates batch by the first object.\n * @param canBatch Checks if two objects can be allocated.\n * @returns Iterable list of batches.\n */\nfunction* batchAllocatedObjects(objects, getMemoryLocation, createBatch, canBatch = () => true) {\n    const iterator = objects[Symbol.iterator]();\n    let primitive = iterator.next().value;\n    if (!primitive) {\n        return;\n    }\n    let prev = primitive;\n    let batch = createBatch(prev);\n    while (primitive = iterator.next().value) {\n        const primitiveMemoryLocation = getMemoryLocation(primitive);\n        if (!canBatch(prev, primitive, batch) || !appendToBatch(primitiveMemoryLocation, batch)) {\n            yield batch;\n            batch = createBatch(primitive);\n        }\n        prev = primitive;\n    }\n    yield batch;\n}\n\n\n/***/ }),\n/* 102 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__priority_queue__ = __webpack_require__(103);\n\nconst DEQUEUE_TIMEOUT = 1; // ms\n/**\n * Prioritized task queue.\n */\nclass TaskQueue {\n    /**\n     * Constructs an empty task queue.\n     */\n    constructor() {\n        this._queue = new __WEBPACK_IMPORTED_MODULE_0__priority_queue__[\"a\" /* default */]();\n        this._dequeueTimeoutHandle = 0;\n    }\n    /**\n     * Destroys the queue. Any remaining tasks won't be executed.\n     */\n    destroy() {\n        clearTimeout(this._dequeueTimeoutHandle);\n    }\n    /**\n     * Enqueues a task to the queue and schedules processing of the queue.\n     *\n     * @param task The task.\n     */\n    enqueue(task) {\n        this._queue.enqueue(task);\n        if (!this._dequeueTimeoutHandle) {\n            this._dequeueTimeoutHandle = setTimeout(() => this._dequeue(), DEQUEUE_TIMEOUT);\n        }\n    }\n    _dequeue() {\n        const task = this._queue.dequeue();\n        if (task) {\n            task.execute();\n        }\n        this._dequeueTimeoutHandle = this._queue.isEmpty() ?\n            0 :\n            setTimeout(() => this._dequeue(), DEQUEUE_TIMEOUT);\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = TaskQueue;\n\n\n\n/***/ }),\n/* 103 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__binary_heap__ = __webpack_require__(104);\n\nfunction itemComparator(a, b) {\n    return a.priority - b.priority;\n}\n/**\n * Priority queue based on a heap.\n */\nclass PriorityQueue {\n    /**\n     * Constructs new empty priority queue.\n     */\n    constructor() {\n        this._heap = new __WEBPACK_IMPORTED_MODULE_0__binary_heap__[\"a\" /* default */](itemComparator);\n    }\n    /**\n     * Adds an item into the queue.\n     *\n     * @param item The item.\n     */\n    enqueue(item) {\n        this._heap.insert(item);\n    }\n    /**\n     * Removes next item from the queue.\n     *\n     * @returns The next item or `undefined` if the queue's empty.\n     */\n    dequeue() {\n        return this._heap.pop();\n    }\n    /**\n     * Checks if the queue has no items in it.\n     *\n     * @returns `true` if there're no items it the queue and `false` otherwise.\n     */\n    isEmpty() {\n        return this._heap.size === 0;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = PriorityQueue;\n\n\n\n/***/ }),\n/* 104 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__comparator__ = __webpack_require__(105);\n\n\n/**\n * Computes index of the parent of an item.\n *\n * @param idx Index of the item.\n * @returns Index of the parent.\n */\nfunction getParentIdx(idx) {\n    return (idx + 1 >> 1) - 1;\n}\n/**\n * Computes index of the left child of an item.\n *\n * @param idx Index of the item.\n * @returns Index of the child.\n */\nfunction getFirstChildIdx(idx) {\n    return (idx + 1 << 1) - 1;\n}\nclass BinaryHeap {\n    /**\n     * Constructs a new empty heap. Order of items in the heap will be defined\n     * by a given comparator.\n     *\n     * @param comparator The comparator.\n     */\n    constructor(comparator = __WEBPACK_IMPORTED_MODULE_1__comparator__[\"a\" /* DEFAULT_COMPARATOR */]) {\n        // TODO(dmikis) Investigate preallocation.\n        this._items = [];\n        this._comparator = comparator;\n    }\n    /**\n     * Inserts an item into the heap.\n     *\n     * @param item The item to be inserted.\n     */\n    insert(item) {\n        const items = this._items;\n        const comparator = this._comparator;\n        // Insert the new item as bottom right-most child of the heap.\n        let idx = items.push(item) - 1;\n        let parentIdx = getParentIdx(idx);\n        // Walk the heap upward and restore heap property on the way.\n        while (parentIdx > -1 &&\n            comparator(items[idx], items[parentIdx]) > 0) {\n            Object(__WEBPACK_IMPORTED_MODULE_0__array__[\"c\" /* swap */])(items, idx, parentIdx);\n            idx = parentIdx;\n            parentIdx = getParentIdx(idx);\n        }\n    }\n    /**\n     * Removes \"maximum\" item from the head.\n     *\n     * @returns The removed item or `undefined` is the heap's empty.\n     */\n    pop() {\n        const items = this._items;\n        if (items.length === 0) {\n            return undefined;\n        }\n        const newSize = items.length - 1;\n        // Place max item at the end of the items array.\n        Object(__WEBPACK_IMPORTED_MODULE_0__array__[\"c\" /* swap */])(items, 0, newSize);\n        // Walk downward from the new root to restore heap property.\n        let idx = 0;\n        let childIdx = 1;\n        const comparator = this._comparator;\n        while (childIdx < newSize) {\n            if (childIdx + 1 < newSize &&\n                comparator(items[childIdx], items[childIdx + 1]) < 0) {\n                childIdx += 1;\n            }\n            if (comparator(items[idx], items[childIdx]) > 0) {\n                break;\n            }\n            Object(__WEBPACK_IMPORTED_MODULE_0__array__[\"c\" /* swap */])(items, idx, childIdx);\n            idx = childIdx;\n            childIdx = getFirstChildIdx(childIdx);\n        }\n        // Remove previously placed at the end previous max item.\n        return items.pop();\n    }\n    /**\n     * @returns \"Maximum\" item in the heap or `undefined` if the head is empty.\n     */\n    peek() {\n        return this._items[0];\n    }\n    /**\n     * @returns Iterator over all items in the heap. Note that order of items\n     *      is undefined.\n     */\n    *[Symbol.iterator]() {\n        for (const item of this._items) {\n            yield item;\n        }\n    }\n    /**\n     * @returns Number of items in the heap.\n     */\n    get size() {\n        return this._items.length;\n    }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = BinaryHeap;\n\n\n\n/***/ }),\n/* 105 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = DEFAULT_COMPARATOR;\nfunction DEFAULT_COMPARATOR(a, b) {\n    if (a > b) {\n        return 1;\n    }\n    if (a < b) {\n        return -1;\n    }\n    return 0;\n}\n\n\n/***/ })\n/******/ ]);"],{type:'text/javascript'})));});